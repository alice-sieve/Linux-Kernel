<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier -->
<!--X-From-R13: Rna [hecul &#60;qzheculNgv.pbz> -->
<!--X-Date: Wed, 2 Jul 2014 07:53:32 &#45;0700 -->
<!--X-Message-Id: 53B41CD6.8090403@ti.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 1404307852&#45;10456&#45;1&#45;git&#45;send&#45;email&#45;dmurphy@ti.com -->
<!--X-Reference: 20140702141001.GA5541@saruman.home -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Sound: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Sound &mdash; Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</title>
<link rel="alternate" type="application/rss+xml" title="Linux Sound" href="//feeds.feedburner.com/LinuxSound">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:6612422167" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</h1>
[<a href="msg00481.html">Date Prev</a>][<a href="msg00483.html">Date Next</a>][<a href="msg00481.html">Thread Prev</a>][<a href="msg00484.html">Thread Next</a>][<a href="maillist.html#00482">Date Index</a>][<a href="index.html#00482">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</li>
<li><em>From</em>: Dan Murphy &lt;<a href="mailto:dmurphy@DOMAIN.HIDDEN">dmurphy@xxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 2 Jul 2014 09:53:10 -0500</li>
<li><em>Cc</em>: &lt;<a href="mailto:linux-sound@DOMAIN.HIDDEN">linux-sound@xxxxxxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:linux-kernel@DOMAIN.HIDDEN">linux-kernel@xxxxxxxxxxxxxxx</a>&gt;,        &lt;<a href="mailto:alsa-devel@DOMAIN.HIDDEN">alsa-devel@xxxxxxxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:broonie@DOMAIN.HIDDEN">broonie@xxxxxxxxxx</a>&gt;,        &lt;<a href="mailto:devicetree@DOMAIN.HIDDEN">devicetree@xxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg00481.html">20140702141001.GA5541@saruman.home</a>&gt;</li>
<li><em>User-agent</em>: Mozilla/5.0 (X11; Linux x86_64; rv:24.0) Gecko/20100101 Thunderbird/24.6.0</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Felipe
Thanks for the review

On 07/02/2014 09:10 AM, Felipe Balbi wrote:
&gt; Hi,
&gt;
&gt; On Wed, Jul 02, 2014 at 08:30:52AM -0500, Dan Murphy wrote:
&gt;&gt; Support the TI TAS2552 Class D amplifier.
&gt;&gt;
&gt;&gt; The TAS2552 is a high efficiency Class-D audio
&gt;&gt; power amplifier with advanced battery current
&gt;&gt; management and an integrated Class-G boost
&gt;&gt; The device constantly measures the
&gt;&gt; current and voltage across the load and provides a
&gt;&gt; digital stream of this information.
&gt;&gt;
&gt;&gt; Signed-off-by: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt;&gt; ---
&gt;&gt;
&gt;&gt; v3 - Updated bindings doc per comments, rearranged probe pdata vs 
&gt;&gt; np check - <a  rel="nofollow" href="https://patchwork.kernel.org/patch/4453481/">https://patchwork.kernel.org/patch/4453481/</a>
&gt;&gt;
&gt;&gt;  .../devicetree/bindings/sound/tas2552.txt          |   22 +
&gt;&gt;  include/sound/tas2552-plat.h                       |   25 ++
&gt;&gt;  sound/soc/codecs/Kconfig                           |    5 +
&gt;&gt;  sound/soc/codecs/Makefile                          |    2 +
&gt;&gt;  sound/soc/codecs/tas2552.c                         |  463 ++++++++++++++++++++
&gt;&gt;  sound/soc/codecs/tas2552.h                         |   75 ++++
&gt;&gt;  6 files changed, 592 insertions(+)
&gt;&gt;  create mode 100644 Documentation/devicetree/bindings/sound/tas2552.txt
&gt;&gt;  create mode 100644 include/sound/tas2552-plat.h
&gt;&gt;  create mode 100644 sound/soc/codecs/tas2552.c
&gt;&gt;  create mode 100644 sound/soc/codecs/tas2552.h
&gt;&gt;
&gt;&gt; diff --git a/Documentation/devicetree/bindings/sound/tas2552.txt b/Documentation/devicetree/bindings/sound/tas2552.txt
&gt;&gt; new file mode 100644
&gt;&gt; index 0000000..ada8fd4
&gt;&gt; --- /dev/null
&gt;&gt; +++ b/Documentation/devicetree/bindings/sound/tas2552.txt
&gt;&gt; @@ -0,0 +1,22 @@
&gt;&gt; +Texas Instruments - tas2552 Codec module
&gt;&gt; +
&gt;&gt; +The tas2552 serial control bus communicates through I2C protocols
&gt;&gt; +
&gt;&gt; +Required properties:
&gt;&gt; +
&gt;&gt; +- compatible - One of:
&gt;&gt; +    &quot;ti,tas2552&quot; - TAS2552
&gt;&gt; +
&gt;&gt; +- reg -  I2C slave address
&gt;&gt; +
&gt;&gt; +Optional properties:
&gt;&gt; +
&gt;&gt; +- power-gpio - gpio pin to enable/disable the device
&gt;&gt; +
&gt;&gt; +Example:
&gt;&gt; +
&gt;&gt; +tas2552: tas2552@41 {
&gt;&gt; +	compatible = &quot;ti,tas2552&quot;;
&gt;&gt; +	reg = &lt;0x41&gt;;
&gt;&gt; +	enable-gpio = &lt;&amp;gpio4 2 GPIO_ACTIVE_HIGH&gt;;
&gt; you probably want to add:
&gt;
&gt; 	pvdd-supply = &lt;&amp;pvdd&gt;;
&gt; 	vbat-supply = &lt;&amp;vbat&gt;;
&gt; 	avdd-supply = &lt;&amp;avdd&gt;;
&gt; 	iovdd-supply = &lt;&amp;iovdd&gt;;
&gt;
&gt; that way you can make sure to switch your regulators on from the driver.
&gt; Since they must be all on, you can just grab them all with
&gt; regulator_bulk_get() and enable them all with regulator_bulk_enable().

I could add this but I don't have a use case for this so I did not add the code.

The supplies I used were always-on so adding the regulators was not testable in this
patchset.

I could add this but it would be untested.

&gt; Also, I wonder if it makes sense to add a link to [1] here.

Any reference to documentation is a good reference as long as the URL is
going to always be available.

&gt;
&gt; [1] <a  rel="nofollow" href="http://www.ti.com/product/TAS2552">http://www.ti.com/product/TAS2552</a>

&gt;&gt; +};
&gt;&gt; diff --git a/include/sound/tas2552-plat.h b/include/sound/tas2552-plat.h
&gt;&gt; new file mode 100644
&gt;&gt; index 0000000..65e7627
&gt;&gt; --- /dev/null
&gt;&gt; +++ b/include/sound/tas2552-plat.h
&gt; platform-data is usually placed under include/linux/platform_data/

I can move it if others agree.  There seems to be a mix of platform data
for sound drivers between sound and platform_data so it is up to the
maintainer if they want it moved.

I am OK with either location.

&gt;
&gt;&gt; @@ -0,0 +1,25 @@
&gt;&gt; +/*
&gt;&gt; + * TAS2552 driver platform header
&gt;&gt; + *
&gt;&gt; + * Copyright (C) 2014 Texas Instruments Inc.
&gt;&gt; + *
&gt;&gt; + * Author: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt;&gt; + *
&gt;&gt; + * This program is free software; you can redistribute it and/or
&gt;&gt; + * modify it under the terms of the GNU General Public License
&gt;&gt; + * version 2 as published by the Free Software Foundation.
&gt;&gt; + *
&gt;&gt; + * This program is distributed in the hope that it will be useful, but
&gt;&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of
&gt;&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&gt;&gt; + * General Public License for more details.
&gt;&gt; + */
&gt;&gt; +
&gt;&gt; +#ifndef TAS2552_PLAT_H
&gt;&gt; +#define TAS2552_PLAT_H
&gt;&gt; +
&gt;&gt; +struct tas2552_platform_data {
&gt;&gt; +	int enable_gpio;
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +#endif
&gt;&gt; diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
&gt;&gt; index 0b9571c..cc09261 100644
&gt;&gt; --- a/sound/soc/codecs/Kconfig
&gt;&gt; +++ b/sound/soc/codecs/Kconfig
&gt;&gt; @@ -99,6 +99,7 @@ config SND_SOC_ALL_CODECS
&gt;&gt;  	select SND_SOC_TLV320AIC32X4 if I2C
&gt;&gt;  	select SND_SOC_TLV320AIC3X if I2C
&gt;&gt;  	select SND_SOC_TPA6130A2 if I2C
&gt;&gt; +	select SND_SOC_TAS2552 if I2C
&gt;&gt;  	select SND_SOC_TLV320DAC33 if I2C
&gt;&gt;  	select SND_SOC_TWL4030 if TWL4030_CORE
&gt;&gt;  	select SND_SOC_TWL6040 if TWL6040_CORE
&gt;&gt; @@ -754,4 +755,8 @@ config SND_SOC_TPA6130A2
&gt;&gt;  	tristate &quot;Texas Instruments TPA6130A2 headphone amplifier&quot;
&gt;&gt;  	depends on I2C
&gt;&gt;  
&gt;&gt; +config SND_SOC_TAS2552
&gt;&gt; +	tristate &quot;Texas Instruments TAS2552 Mono Audio amplifier&quot;
&gt;&gt; +	depends on I2C
&gt;&gt; +
&gt;&gt;  endmenu
&gt;&gt; diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
&gt;&gt; index 1bd6e1c..33bc7228 100644
&gt;&gt; --- a/sound/soc/codecs/Makefile
&gt;&gt; +++ b/sound/soc/codecs/Makefile
&gt;&gt; @@ -162,6 +162,7 @@ snd-soc-wm-hubs-objs := wm_hubs.o
&gt;&gt;  # Amp
&gt;&gt;  snd-soc-max9877-objs := max9877.o
&gt;&gt;  snd-soc-tpa6130a2-objs := tpa6130a2.o
&gt;&gt; +snd-soc-tas2552-objs := tas2552.o
&gt;&gt;  
&gt;&gt;  obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
&gt;&gt;  obj-$(CONFIG_SND_SOC_AB8500_CODEC)	+= snd-soc-ab8500-codec.o
&gt;&gt; @@ -325,3 +326,4 @@ obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
&gt;&gt;  # Amp
&gt;&gt;  obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
&gt;&gt;  obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
&gt;&gt; +obj-$(CONFIG_SND_SOC_TAS2552)	+= snd-soc-tas2552.o
&gt;&gt; diff --git a/sound/soc/codecs/tas2552.c b/sound/soc/codecs/tas2552.c
&gt;&gt; new file mode 100644
&gt;&gt; index 0000000..79b8212
&gt;&gt; --- /dev/null
&gt;&gt; +++ b/sound/soc/codecs/tas2552.c
&gt;&gt; @@ -0,0 +1,463 @@
&gt;&gt; +/*
&gt;&gt; + * ALSA SoC Texas Instruments TAS2552 Mono Audio Amplifier
&gt;&gt; + *
&gt;&gt; + * Copyright (C) 2014 Texas Instruments Inc.
&gt;&gt; + *
&gt;&gt; + * Author: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt;&gt; + *
&gt;&gt; + * This program is free software; you can redistribute it and/or
&gt;&gt; + * modify it under the terms of the GNU General Public License
&gt;&gt; + * version 2 as published by the Free Software Foundation.
&gt;&gt; + *
&gt;&gt; + * This program is distributed in the hope that it will be useful, but
&gt;&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of
&gt;&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&gt;&gt; + * General Public License for more details.
&gt;&gt; + */
&gt;&gt; +
&gt;&gt; +#include &lt;linux/module.h&gt;
&gt;&gt; +#include &lt;linux/errno.h&gt;
&gt;&gt; +#include &lt;linux/device.h&gt;
&gt;&gt; +#include &lt;linux/i2c.h&gt;
&gt;&gt; +#include &lt;linux/gpio.h&gt;
&gt;&gt; +#include &lt;linux/of_gpio.h&gt;
&gt;&gt; +#include &lt;linux/regmap.h&gt;
&gt;&gt; +#include &lt;linux/slab.h&gt;
&gt;&gt; +
&gt;&gt; +#include &lt;sound/pcm.h&gt;
&gt;&gt; +#include &lt;sound/pcm_params.h&gt;
&gt;&gt; +#include &lt;sound/soc.h&gt;
&gt;&gt; +#include &lt;sound/soc-dapm.h&gt;
&gt;&gt; +#include &lt;sound/tlv.h&gt;
&gt;&gt; +#include &lt;sound/tas2552-plat.h&gt;
&gt;&gt; +
&gt;&gt; +#include &quot;tas2552.h&quot;
&gt;&gt; +
&gt;&gt; +static struct reg_default tas2552_reg_defs[] = {
&gt;&gt; +	{TAS2552_CFG_1, 0x16},
&gt;&gt; +	{TAS2552_CFG_3, 0x5E},
&gt;&gt; +	{TAS2552_DOUT, 0x00},
&gt;&gt; +	{TAS2552_OUTPUT_DATA, 0xC8},
&gt;&gt; +	{TAS2552_PDM_CFG, 0x02},
&gt;&gt; +	{TAS2552_PGA_GAIN, 0x10},
&gt;&gt; +	{TAS2552_BOOST_PT_CTRL, 0x0F},
&gt;&gt; +	{TAS2552_LIMIT_LVL_CTRL, 0x0C},
&gt;&gt; +	{TAS2552_LIMIT_RATE_HYS, 0x20},
&gt;&gt; +	{TAS2552_CFG_2, 0xEA},
&gt;&gt; +	{TAS2552_SER_CTRL_1, 0x00},
&gt;&gt; +	{TAS2552_SER_CTRL_2, 0x00},
&gt;&gt; +	{TAS2552_PLL_CTRL_1, 0x10},
&gt;&gt; +	{TAS2552_PLL_CTRL_2, 0x00},
&gt;&gt; +	{TAS2552_PLL_CTRL_3, 0x00},
&gt;&gt; +	{TAS2552_BTIP, 0x8f},
&gt;&gt; +	{TAS2552_BTS_CTRL, 0x80},
&gt;&gt; +	{TAS2552_LIMIT_RELEASE, 0x05},
&gt;&gt; +	{TAS2552_LIMIT_INT_COUNT, 0x00},
&gt;&gt; +	{TAS2552_EDGE_RATE_CTRL, 0x40},
&gt;&gt; +	{TAS2552_VBAT_DATA, 0x00},
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +struct tas2552_data {
&gt;&gt; +	struct mutex mutex;
&gt;&gt; +	struct snd_soc_codec *codec;
&gt;&gt; +	struct regmap *regmap;
&gt;&gt; +	struct i2c_client *tas2552_client;
&gt;&gt; +	unsigned char regs[TAS2552_VBAT_DATA];
&gt;&gt; +	int power_gpio;
&gt;&gt; +	u8 power_state:1;
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +static int tas2552_power(struct tas2552_data *data, u8 power)
&gt;&gt; +{
&gt;&gt; +	int	ret = 0;
&gt;&gt; +
&gt;&gt; +	BUG_ON(data-&gt;tas2552_client == NULL);
&gt; don't hang the entire machine because of a bug on the amplifier driver,
&gt; WARN() should be enough, followed by the return of an error code.
&gt;
&gt; In fact, is this really necessary ? It would be a simple bug on the
&gt; driver to fix.

Yeah I can remove this.  I was following an older example.

&gt;
&gt;&gt; +
&gt;&gt; +	mutex_lock(&amp;data-&gt;mutex);
&gt;&gt; +	if (power == data-&gt;power_state)
&gt; Same here. Is this really necessary ? It's simple to guarantee this case
&gt; won't happen in code.

Yes this LOC is necessary.  It is checking the current state of the tas2552.

&gt;&gt; +		goto exit;
&gt;&gt; +
&gt;&gt; +	if (power) {
&gt;&gt; +		if (data-&gt;power_gpio &gt;= 0)
&gt;&gt; +			gpio_set_value(data-&gt;power_gpio, 1);
&gt;&gt; +
&gt;&gt; +		data-&gt;power_state = 1;
&gt;&gt; +	} else {
&gt;&gt; +		if (data-&gt;power_gpio &gt;= 0)
&gt;&gt; +			gpio_set_value(data-&gt;power_gpio, 0);
&gt;&gt; +
&gt;&gt; +		data-&gt;power_state = 0;
&gt;&gt; +	}
&gt;&gt; +
&gt;&gt; +exit:
&gt;&gt; +	mutex_unlock(&amp;data-&gt;mutex);
&gt;&gt; +	return ret;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void tas2552_sw_shutdown(struct tas2552_data *tas_data, int sw_shutdown)
&gt;&gt; +{
&gt;&gt; +	u8 cfg1_reg = 0x0;
&gt;&gt; +
&gt;&gt; +	if (sw_shutdown)
&gt;&gt; +		cfg1_reg |= (sw_shutdown &lt;&lt; 1);
&gt; this line is dangerous. You're using a 32-bit variable to write a single
&gt; bit on cfg1 register. What if user passes 0xff on sw_shutdown ?
&gt;
&gt; I think a better approach would be to:
&gt;
&gt; a) first of all, move this sw_shutdown function to
&gt; runtime_suspend/runtime_resume.

Yeah that is not the intent of this API.  This API is called when the ALSA layer
opens/closes the device.  It is not governed by pm calls.

&gt;
&gt; b) to the check as below:
&gt;
&gt; 	if (shutdown)
&gt; 		cfg1_reg |= TAS2552_SWS;
&gt; 	else
&gt; 		cfg1_reg &amp;= ~TAS2552_SWS;
&gt;
&gt; then, of course #define TAS2552_SWS (1 &lt;&lt; 1) (or BIT(1), even)

But I will make this change.

&gt;
&gt;&gt; +	else
&gt;&gt; +		cfg1_reg &amp;= ~TAS2552_SWS_MASK;
&gt;&gt; +
&gt;&gt; +	snd_soc_update_bits(tas_data-&gt;codec, TAS2552_CFG_1,
&gt;&gt; +						 TAS2552_SWS_MASK, cfg1_reg);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void tas2552_init(struct snd_soc_codec *codec)
&gt;&gt; +{
&gt;&gt; +	snd_soc_write(codec, TAS2552_CFG_1, 0x16);
&gt;&gt; +	snd_soc_write(codec, TAS2552_CFG_3, 0x5E);
&gt;&gt; +	snd_soc_write(codec, TAS2552_DOUT, 0x00);
&gt;&gt; +	snd_soc_write(codec, TAS2552_OUTPUT_DATA, 0xC8);
&gt;&gt; +	snd_soc_write(codec, TAS2552_PDM_CFG, 0x02);
&gt;&gt; +	snd_soc_write(codec, TAS2552_PGA_GAIN, 0x10);
&gt;&gt; +	snd_soc_write(codec, TAS2552_BOOST_PT_CTRL, 0x0F);
&gt;&gt; +	snd_soc_write(codec, TAS2552_LIMIT_LVL_CTRL, 0x0C);
&gt;&gt; +	snd_soc_write(codec, TAS2552_LIMIT_RATE_HYS, 0x20);
&gt;&gt; +	snd_soc_write(codec, TAS2552_CFG_2, 0xEA);
&gt; what do all these magic constants mean ? Also, lower case hex numbers
&gt; are usually preferred.

I will add comments to what the numbers mean and change to lower case

&gt;
&gt; No battery tracking ?  Any plans to add that at a later date ? It's
&gt; probably not needed to have functional audio, but might have some use
&gt; cases where you want it.

The battery tracking was not the scope of the driver.  We just need to get the basic
driver in place with audio functional and add the battery tracking later.

I also did not have a device that had the battery tracking enabled so I could not develop
that level of code anyway.

&gt;
&gt; /* goes re-read datasheet */
&gt;
&gt; Actually, I strongly believe you want to enable battery tracking (LIM_EN
&gt; on cfg2).
&gt;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static int tas2552_hw_params(struct snd_pcm_substream *substream,
&gt;&gt; +			     struct snd_pcm_hw_params *params,
&gt;&gt; +			     struct snd_soc_dai *dai)
&gt;&gt; +{
&gt;&gt; +	u8 wclk_reg;
&gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt;&gt; +
&gt;&gt; +	/* Setting DAC clock dividers based on substream sample rate. */
&gt;&gt; +	switch (params_rate(params)) {
&gt;&gt; +	case 8000:
&gt;&gt; +		wclk_reg = TAS2552_8KHZ;
&gt;&gt; +		break;
&gt;&gt; +	case 11025:
&gt;&gt; +		wclk_reg = TAS2552_11_12KHZ;
&gt;&gt; +		break;
&gt;&gt; +	case 16000:
&gt;&gt; +		wclk_reg = TAS2552_16KHZ;
&gt;&gt; +		break;
&gt;&gt; +	case 32000:
&gt;&gt; +		wclk_reg = TAS2552_32KHZ;
&gt;&gt; +		break;
&gt;&gt; +	case 22050:
&gt;&gt; +	case 24000:
&gt;&gt; +		wclk_reg = TAS2552_22_24KHZ;
&gt;&gt; +		break;
&gt;&gt; +	case 44100:
&gt;&gt; +	case 48000:
&gt;&gt; +		wclk_reg = TAS2552_44_48KHZ;
&gt;&gt; +		break;
&gt;&gt; +	case 96000:
&gt;&gt; +		wclk_reg = TAS2552_88_96KHZ;
&gt;&gt; +		break;
&gt;&gt; +	default:
&gt; might be worth adding a dev_vdbg() here.

I could, but trying to not add a lot of logging in the code.

&gt;
&gt;&gt; +		return -EINVAL;
&gt;&gt; +	}
&gt;&gt; +
&gt;&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_3, TAS2552_WCLK_MASK, wclk_reg);
&gt;&gt; +
&gt;&gt; +	return 0;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static int tas2552_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
&gt;&gt; +{
&gt;&gt; +	u8 serial_format;
&gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt;&gt; +
&gt;&gt; +	switch (fmt &amp; SND_SOC_DAIFMT_MASTER_MASK) {
&gt;&gt; +	case SND_SOC_DAIFMT_CBS_CFS:
&gt;&gt; +		serial_format = 0x00;
&gt;&gt; +		break;
&gt;&gt; +	case SND_SOC_DAIFMT_CBS_CFM:
&gt;&gt; +		serial_format = TAS2552_WORD_CLK_MASK;
&gt;&gt; +		break;
&gt;&gt; +	case SND_SOC_DAIFMT_CBM_CFS:
&gt;&gt; +		serial_format = TAS2552_BIT_CLK_MASK;
&gt;&gt; +		break;
&gt;&gt; +	case SND_SOC_DAIFMT_CBM_CFM:
&gt;&gt; +		serial_format = (TAS2552_BIT_CLK_MASK | TAS2552_WORD_CLK_MASK);
&gt;&gt; +		break;
&gt;&gt; +	default:
&gt;&gt; +		return -EINVAL;
&gt;&gt; +	}
&gt;&gt; +
&gt;&gt; +	snd_soc_update_bits(codec, TAS2552_SER_CTRL_1,
&gt;&gt; +			    (TAS2552_BIT_CLK_MASK | TAS2552_WORD_CLK_MASK),
&gt;&gt; +			    serial_format);
&gt;&gt; +
&gt;&gt; +	switch (fmt &amp; SND_SOC_DAIFMT_FORMAT_MASK) {
&gt;&gt; +	case SND_SOC_DAIFMT_I2S:
&gt;&gt; +		serial_format = 0x0;
&gt;&gt; +		break;
&gt;&gt; +	case SND_SOC_DAIFMT_DSP_A:
&gt;&gt; +		serial_format = TAS2552_DAIFMT_DSP;
&gt;&gt; +		break;
&gt;&gt; +	case SND_SOC_DAIFMT_RIGHT_J:
&gt;&gt; +		serial_format = TAS2552_DAIFMT_RIGHT_J;
&gt;&gt; +		break;
&gt;&gt; +	case SND_SOC_DAIFMT_LEFT_J:
&gt;&gt; +		serial_format = TAS2552_DAIFMT_LEFT_J;
&gt;&gt; +		break;
&gt;&gt; +
&gt;&gt; +	default:
&gt;&gt; +		return -EINVAL;
&gt;&gt; +	}
&gt;&gt; +
&gt;&gt; +	snd_soc_update_bits(codec, TAS2552_SER_CTRL_1, TAS2552_DATA_FORMAT_MASK,
&gt;&gt; +						serial_format);
&gt;&gt; +
&gt;&gt; +	return 0;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static int tas2552_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
&gt;&gt; +				  unsigned int freq, int dir)
&gt;&gt; +{
&gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt;&gt; +	struct tas2552_data *data = dev_get_drvdata(dai-&gt;dev);
&gt;&gt; +
&gt;&gt; +	/* Fill in the PLL control registers for J &amp; D
&gt;&gt; +	 * PLL_CLK = (.5 * freq * J.D) / 2^p
&gt;&gt; +	 * Need to fill in J and D here based on incoming freq
&gt;&gt; +	 */
&gt;&gt; +
&gt;&gt; +	tas2552_sw_shutdown(data, 1);
&gt; if you move sw_shutdown to runtime_suspend/resume, you could implement
&gt; this as follows:
&gt;
&gt; 	ret = pm_runtime_get_sync(data-&gt;dev);
&gt; 	if (ret)
&gt; 		return ret;

See above comment about these APIs not being related to power management

&gt;
&gt;&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_PLL_ENABLE, 0);
&gt;&gt; +
&gt;&gt; +	snd_soc_write(codec, TAS2552_PLL_CTRL_1, 0x10);
&gt;&gt; +	snd_soc_write(codec, TAS2552_PLL_CTRL_2, 0x00);
&gt;&gt; +	snd_soc_write(codec, TAS2552_PLL_CTRL_3, 0x00);
&gt;&gt; +
&gt;&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_PLL_ENABLE,
&gt;&gt; +						TAS2552_PLL_ENABLE);
&gt;&gt; +
&gt;&gt; +	tas2552_sw_shutdown(data, 0);
&gt; and this as:
&gt;
&gt; 	pm_runtime_mark_last_busy(data-&gt;dev);
&gt; 	pm_runtime_put_autosuspend(data-&gt;dev);
&gt;
&gt; then use a 1000 ms default timeout and you're good to go. In fact, you
&gt; can make this even better by trying to make sure device is already
&gt; powered when you get here. Also, I'm not sure what kind of latency you'd
&gt; causing by constantly powering device on and off as you currently are.

Same as above

&gt;
&gt;&gt; +
&gt;&gt; +	return 0;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static int tas2552_mute(struct snd_soc_dai *dai, int mute)
&gt;&gt; +{
&gt;&gt; +	u8 cfg1_reg = 0x0;
&gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt;&gt; +
&gt;&gt; +	if (mute)
&gt;&gt; +		cfg1_reg |= TAS2552_MUTE_MASK;
&gt;&gt; +	else
&gt;&gt; +		cfg1_reg &amp;= ~TAS2552_MUTE_MASK;
&gt;&gt; +
&gt;&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_1, TAS2552_MUTE_MASK, cfg1_reg);
&gt;&gt; +
&gt;&gt; +	return 0;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static int tas2552_startup(struct snd_pcm_substream *substream,
&gt;&gt; +			   struct snd_soc_dai *dai)
&gt;&gt; +{
&gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt;&gt; +	struct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);
&gt;&gt; +
&gt;&gt; +	tas2552_sw_shutdown(tas2552, 1);
&gt;&gt; +	tas2552_power(tas2552, 1);
&gt; shouldn't you power first ? Looking at datasheet, if pin EN isn't high,
&gt; device won't be enabled. It'd be surprising that it still responds to
&gt; i2c.

Yes this is backwards.  Will fix

&gt;&gt; +
&gt;&gt; +	/* Turn on Class D amplifier */
&gt;&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_CLASSD_EN_MASK,
&gt;&gt; +						TAS2552_CLASSD_EN);
&gt;&gt; +
&gt;&gt; +	tas2552_sw_shutdown(tas2552, 0);
&gt;&gt; +
&gt;&gt; +	return 0;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void tas2552_shutdown(struct snd_pcm_substream *substream,
&gt;&gt; +			   struct snd_soc_dai *dai)
&gt;&gt; +{
&gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt;&gt; +	struct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);
&gt;&gt; +
&gt;&gt; +	tas2552_sw_shutdown(tas2552, 1);
&gt;&gt; +	tas2552_power(tas2552, 0);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static struct snd_soc_dai_ops tas2552_speaker_dai_ops = {
&gt;&gt; +	.hw_params	= tas2552_hw_params,
&gt;&gt; +	.set_sysclk	= tas2552_set_dai_sysclk,
&gt;&gt; +	.set_fmt	= tas2552_set_dai_fmt,
&gt;&gt; +	.startup	= tas2552_startup,
&gt;&gt; +	.shutdown	= tas2552_shutdown,
&gt;&gt; +	.digital_mute = tas2552_mute,
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +/* Formats supported by TAS2552 driver. */
&gt;&gt; +#define TAS2552_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
&gt;&gt; +			 SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
&gt;&gt; +
&gt;&gt; +/* TAS2552 dai structure. */
&gt;&gt; +static struct snd_soc_dai_driver tas2552_dai[] = {
&gt;&gt; +	{
&gt;&gt; +		.name = &quot;tas2552-amplifier&quot;,
&gt;&gt; +		.playback = {
&gt;&gt; +			.stream_name = &quot;Speaker&quot;,
&gt;&gt; +			.channels_min = 2,
&gt;&gt; +			.channels_max = 2,
&gt;&gt; +			.rates = SNDRV_PCM_RATE_8000_192000,
&gt;&gt; +			.formats = TAS2552_FORMATS,
&gt;&gt; +		},
&gt;&gt; +		.ops = &amp;tas2552_speaker_dai_ops,
&gt;&gt; +	},
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +/*
&gt;&gt; + * DAC digital volumes. From -7 to 24 dB in 1 dB steps
&gt;&gt; + */
&gt;&gt; +static DECLARE_TLV_DB_SCALE(dac_tlv, -7, 100, 24);
&gt;&gt; +
&gt;&gt; +static const struct snd_kcontrol_new tas2552_snd_controls[] = {
&gt;&gt; +	SOC_SINGLE_TLV(&quot;Speaker Driver Playback Volume&quot;,
&gt;&gt; +			 TAS2552_PGA_GAIN, 0, 0x1f, 1, dac_tlv),
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +static int tas2552_codec_probe(struct snd_soc_codec *codec)
&gt;&gt; +{
&gt;&gt; +	struct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);
&gt;&gt; +
&gt;&gt; +	tas2552-&gt;codec = codec;
&gt;&gt; +	tas2552_power(tas2552, 1);
&gt;&gt; +	tas2552_init(codec);
&gt;&gt; +
&gt;&gt; +	return 0;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static int tas2552_codec_remove(struct snd_soc_codec *codec)
&gt;&gt; +{
&gt;&gt; +	struct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);
&gt;&gt; +
&gt;&gt; +	tas2552_power(tas2552, 0);
&gt;&gt; +
&gt;&gt; +	return 0;
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +static struct snd_soc_codec_driver soc_codec_dev_tas2552 = {
&gt;&gt; +	.probe = tas2552_codec_probe,
&gt;&gt; +	.remove = tas2552_codec_remove,
&gt;&gt; +	.controls = tas2552_snd_controls,
&gt;&gt; +	.num_controls = ARRAY_SIZE(tas2552_snd_controls),
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +static const struct regmap_config tas2552_regmap_config = {
&gt;&gt; +	.reg_bits = 8,
&gt;&gt; +	.val_bits = 8,
&gt;&gt; +
&gt;&gt; +	.max_register = TAS2552_MAX_REG,
&gt;&gt; +	.reg_defaults = tas2552_reg_defs,
&gt;&gt; +	.num_reg_defaults = ARRAY_SIZE(tas2552_reg_defs),
&gt;&gt; +	.cache_type = REGCACHE_RBTREE,
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +static int tas2552_probe(struct i2c_client *client,
&gt;&gt; +			   const struct i2c_device_id *id)
&gt;&gt; +{
&gt;&gt; +	struct device *dev;
&gt;&gt; +	struct tas2552_data *data;
&gt;&gt; +	struct tas2552_platform_data *pdata = client-&gt;dev.platform_data;
&gt;&gt; +	struct device_node *np = client-&gt;dev.of_node;
&gt;&gt; +	int ret;
&gt;&gt; +
&gt;&gt; +	dev = &amp;client-&gt;dev;
&gt;&gt; +	data = devm_kzalloc(&amp;client-&gt;dev, sizeof(*data), GFP_KERNEL);
&gt;&gt; +	if (data == NULL)
&gt;&gt; +		return -ENOMEM;
&gt;&gt; +
&gt;&gt; +	if (np) {
&gt;&gt; +		data-&gt;power_gpio = of_get_named_gpio(np, &quot;enable-gpio&quot;, 0);
&gt;&gt; +	} else if (pdata) {
&gt;&gt; +		data-&gt;power_gpio = pdata-&gt;enable_gpio;
&gt;&gt; +	} else {
&gt;&gt; +		dev_err(dev, &quot;Platform or dev tree data not set\n&quot;);
&gt;&gt; +		return -ENODEV;
&gt;&gt; +	}
&gt;&gt; +
&gt;&gt; +	data-&gt;regmap = devm_regmap_init_i2c(client, &amp;tas2552_regmap_config);
&gt;&gt; +	if (IS_ERR(data-&gt;regmap)) {
&gt;&gt; +		ret = PTR_ERR(data-&gt;regmap);
&gt;&gt; +		dev_err(&amp;client-&gt;dev, &quot;Failed to allocate register map: %d\n&quot;,
&gt;&gt; +			ret);
&gt;&gt; +		return ret;
&gt;&gt; +	}
&gt;&gt; +
&gt;&gt; +	data-&gt;tas2552_client = client;
&gt;&gt; +	data-&gt;regmap = devm_regmap_init_i2c(client, &amp;tas2552_regmap_config);
&gt;&gt; +	if (IS_ERR(data-&gt;regmap)) {
&gt;&gt; +		ret = PTR_ERR(data-&gt;regmap);
&gt;&gt; +		dev_err(&amp;client-&gt;dev, &quot;Failed to allocate register map: %d\n&quot;,
&gt;&gt; +			ret);
&gt;&gt; +		return ret;
&gt;&gt; +	}
&gt;&gt; +
&gt;&gt; +	dev_set_drvdata(&amp;client-&gt;dev, data);
&gt;&gt; +
&gt;&gt; +	mutex_init(&amp;data-&gt;mutex);
&gt;&gt; +
&gt;&gt; +	if (data-&gt;power_gpio &gt;= 0) {
&gt;&gt; +		ret = devm_gpio_request(dev, data-&gt;power_gpio,
&gt;&gt; +					&quot;tas2552 enable&quot;);
&gt;&gt; +		if (ret &lt; 0) {
&gt;&gt; +			dev_err(dev, &quot;Failed to request power GPIO (%d)\n&quot;,
&gt;&gt; +				data-&gt;power_gpio);
&gt;&gt; +			goto err_gpio;
&gt;&gt; +		}
&gt;&gt; +		gpio_direction_output(data-&gt;power_gpio, 0);
&gt;&gt; +	}
&gt;&gt; +
&gt;&gt; +	ret = snd_soc_register_codec(&amp;client-&gt;dev,
&gt;&gt; +				      &amp;soc_codec_dev_tas2552,
&gt;&gt; +				      tas2552_dai, ARRAY_SIZE(tas2552_dai));
&gt;&gt; +	if (ret &lt; 0)
&gt;&gt; +		dev_err(&amp;client-&gt;dev, &quot;Failed to register codec: %d\n&quot;, ret);
&gt;&gt; +
&gt;&gt; +	return 0;
&gt;&gt; +
&gt;&gt; +err_gpio:
&gt;&gt; +	data-&gt;tas2552_client = NULL;
&gt;&gt; +	return ret;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static int tas2552_i2c_remove(struct i2c_client *client)
&gt;&gt; +{
&gt;&gt; +	snd_soc_unregister_codec(&amp;client-&gt;dev);
&gt;&gt; +	return 0;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static const struct i2c_device_id tas2552_id[] = {
&gt;&gt; +	{ &quot;tas2552-codec&quot;, 0 },
&gt;&gt; +	{ }
&gt;&gt; +};
&gt;&gt; +MODULE_DEVICE_TABLE(i2c, tas2552_id);
&gt;&gt; +
&gt;&gt; +#if IS_ENABLED(CONFIG_OF)
&gt;&gt; +static const struct of_device_id tas2552_of_match[] = {
&gt;&gt; +	{ .compatible = &quot;ti,tas2552&quot;, },
&gt;&gt; +	{},
&gt;&gt; +};
&gt;&gt; +MODULE_DEVICE_TABLE(of, tas2552_of_match);
&gt;&gt; +#endif
&gt;&gt; +
&gt;&gt; +static struct i2c_driver tas2552_i2c_driver = {
&gt;&gt; +	.driver = {
&gt;&gt; +		.name = &quot;tas2552-codec&quot;,
&gt;&gt; +		.owner = THIS_MODULE,
&gt;&gt; +		.of_match_table = of_match_ptr(tas2552_of_match),
&gt;&gt; +	},
&gt;&gt; +	.probe = tas2552_probe,
&gt;&gt; +	.remove = tas2552_i2c_remove,
&gt;&gt; +	.id_table = tas2552_id,
&gt;&gt; +};
&gt;&gt; +
&gt;&gt; +module_i2c_driver(tas2552_i2c_driver);
&gt;&gt; +
&gt;&gt; +MODULE_AUTHOR(&quot;Dan Muprhy &lt;dmurphy@xxxxxx&gt;&quot;);
&gt;&gt; +MODULE_DESCRIPTION(&quot;TAS2552 Audio amplifier driver&quot;);
&gt;&gt; +MODULE_LICENSE(&quot;GPL&quot;);
&gt;&gt; diff --git a/sound/soc/codecs/tas2552.h b/sound/soc/codecs/tas2552.h
&gt;&gt; new file mode 100644
&gt;&gt; index 0000000..174c64d
&gt;&gt; --- /dev/null
&gt;&gt; +++ b/sound/soc/codecs/tas2552.h
&gt;&gt; @@ -0,0 +1,75 @@
&gt;&gt; +/*
&gt;&gt; + * ALSA SoC Texas Instruments TAS2552 Mono Audio Amplifier
&gt;&gt; + *
&gt;&gt; + * Copyright (C) 2014 Texas Instruments Inc.
&gt;&gt; + *
&gt;&gt; + * Author: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt;&gt; + *
&gt;&gt; + * This program is free software; you can redistribute it and/or
&gt;&gt; + * modify it under the terms of the GNU General Public License
&gt;&gt; + * version 2 as published by the Free Software Foundation.
&gt;&gt; + *
&gt;&gt; + * This program is distributed in the hope that it will be useful, but
&gt;&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of
&gt;&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&gt;&gt; + * General Public License for more details.
&gt;&gt; + */
&gt;&gt; +
&gt;&gt; +#ifndef __TAS2552_H__
&gt;&gt; +#define __TAS2552_H__
&gt;&gt; +
&gt;&gt; +/* Register Address Map */
&gt;&gt; +#define TAS2552_DEVICE_STATUS	0x00
&gt;&gt; +#define TAS2552_CFG_1			0x01
&gt;&gt; +#define TAS2552_CFG_2			0x02
&gt;&gt; +#define TAS2552_CFG_3			0x03
&gt;&gt; +#define TAS2552_DOUT			0x04
&gt;&gt; +#define TAS2552_SER_CTRL_1		0x05
&gt;&gt; +#define TAS2552_SER_CTRL_2		0x06
&gt;&gt; +#define TAS2552_OUTPUT_DATA		0x07
&gt;&gt; +#define TAS2552_PLL_CTRL_1		0x08
&gt;&gt; +#define TAS2552_PLL_CTRL_2		0x09
&gt;&gt; +#define TAS2552_PLL_CTRL_3		0x0a
&gt;&gt; +#define TAS2552_BTIP			0x0b
&gt;&gt; +#define TAS2552_BTS_CTRL		0x0c
&gt;&gt; +#define TAS2552_LIMIT_LVL_CTRL	0x0d
&gt;&gt; +#define TAS2552_LIMIT_RATE_HYS	0x0e
&gt;&gt; +#define TAS2552_LIMIT_RELEASE	0x0f
&gt;&gt; +#define TAS2552_LIMIT_INT_COUNT	0x10
&gt;&gt; +#define TAS2552_PDM_CFG			0x11
&gt;&gt; +#define TAS2552_PGA_GAIN		0x12
&gt;&gt; +#define TAS2552_EDGE_RATE_CTRL	0x13
&gt;&gt; +#define TAS2552_BOOST_PT_CTRL	0x14
&gt;&gt; +#define TAS2552_VER_NUM			0x16
&gt;&gt; +#define TAS2552_VBAT_DATA		0x19
&gt;&gt; +#define TAS2552_MAX_REG			0x20
&gt;&gt; +
&gt;&gt; +/* CFG1 Register Masks */
&gt;&gt; +#define TAS2552_MUTE_MASK		(1 &lt;&lt; 2)
&gt;&gt; +#define TAS2552_SWS_MASK		(1 &lt;&lt; 1)
&gt;&gt; +#define TAS2552_WCLK_MASK		0x07
&gt;&gt; +#define TAS2552_CLASSD_EN_MASK	(1 &lt;&lt; 7)
&gt;&gt; +#define TAS2552_CLASSD_EN		0x80
&gt;&gt; +
&gt;&gt; +#define TAS2552_PLL_ENABLE		(1 &lt;&lt; 3)
&gt;&gt; +
&gt;&gt; +/* CFG3 Register Masks */
&gt;&gt; +#define TAS2552_WORD_CLK_MASK		0x80
&gt;&gt; +#define TAS2552_BIT_CLK_MASK		0x40
&gt;&gt; +#define TAS2552_DATA_FORMAT_MASK	0x0c
&gt;&gt; +
&gt;&gt; +#define TAS2552_DAIFMT_DSP			0x04
&gt;&gt; +#define TAS2552_DAIFMT_RIGHT_J		0x08
&gt;&gt; +#define TAS2552_DAIFMT_LEFT_J		0x0c
&gt;&gt; +
&gt;&gt; +/* WCLK Dividers */
&gt;&gt; +#define TAS2552_8KHZ		0x00
&gt;&gt; +#define TAS2552_11_12KHZ	0x01
&gt;&gt; +#define TAS2552_16KHZ		0x02
&gt;&gt; +#define TAS2552_22_24KHZ	0x03
&gt;&gt; +#define TAS2552_32KHZ		0x04
&gt;&gt; +#define TAS2552_44_48KHZ	0x05
&gt;&gt; +#define TAS2552_88_96KHZ	0x06
&gt;&gt; +#define TAS2552_176_192KHZ	0x07
&gt;&gt; +
&gt;&gt; +#endif
&gt;&gt; -- 
&gt;&gt; 1.7.9.5
&gt;&gt;
&gt;&gt; --
&gt;&gt; To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
&gt;&gt; the body of a message to majordomo@xxxxxxxxxxxxxxx
&gt;&gt; More majordomo info at  <a  rel="nofollow" href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a>
&gt;&gt; Please read the FAQ at  <a  rel="nofollow" href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a>


-- 
------------------
Dan Murphy

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-sound&quot; in
the body of a message to majordomo@xxxxxxxxxxxxxxx
More majordomo info at  <a  rel="nofollow" href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a>



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00484" href="msg00484.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Felipe Balbi</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00479" href="msg00479.html">[PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Dan Murphy</li></ul></li>
<li><strong><a name="00481" href="msg00481.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Felipe Balbi</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00481.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00483.html">Re: [alsa-devel] [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00481.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00484.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00482"><strong>Date</strong></a></li>
<li><a href="index.html#00482"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/Pulseaudio/>[Pulseaudio]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/alsa-devel/>[ALSA&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=http://www.ske-art.com/z/biglist.html>[Big&nbsp;List&nbsp;of&nbsp;Linux&nbsp;Books]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td valign=top align=left>&nbsp;</td>
<td valign=top align=right>
<a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
