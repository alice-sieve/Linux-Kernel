<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH v2 1/2] hid&#45;lenovo: Add support for X1 Tablet special keys and LED control -->
<!--X-From-R13: Prawnzva Fvffbverf &#60;orawnzva.gvffbverfNerqung.pbz> -->
<!--X-Date: Wed, 14 Sep 2016 08:33:12 &#45;0700 -->
<!--X-Message-Id: 20160914153247.GL25951@mail.corp.redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: b8f9c56c&#45;2dfc&#45;8895&#45;2f2a&#45;e17a34be06d2@secunet.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Sound: Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Sound &mdash; Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</title>
<link rel="alternate" type="application/rss+xml" title="Linux Sound" href="//feeds.feedburner.com/LinuxSound">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:6612422167" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</h1>
[<a href="msg00627.html">Date Prev</a>][<a href="msg00629.html">Date Next</a>][<a href="msg00626.html">Thread Prev</a>][<a href="msg00630.html">Thread Next</a>][<a href="maillist.html#00628">Date Index</a>][<a href="index.html#00628">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</li>
<li><em>From</em>: Benjamin Tissoires &lt;benjamin.tissoires@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Wed, 14 Sep 2016 17:32:47 +0200</li>
<li><em>Cc</em>: linux-input@xxxxxxxxxxxxxxx, linux-sound@xxxxxxxxxxxxxxx,        alsa-devel@xxxxxxxxxxxxxxxx, Takashi Iwai &lt;tiwai@xxxxxxx&gt;,        lukas@xxxxxxxxx, Andrew Duggan &lt;aduggan@xxxxxxxxxxxxx&gt;, perex@xxxxxxxx,        vinod.koul@xxxxxxxxx, hui.wang@xxxxxxxxxxxxx,        rafael.j.wysocki@xxxxxxxxx, jikos@xxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg00626.html">b8f9c56c-2dfc-8895-2f2a-e17a34be06d2@secunet.com</a>&gt;</li>
<li><em>References</em>: &lt;<a href="msg00626.html">b8f9c56c-2dfc-8895-2f2a-e17a34be06d2@secunet.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Hi Dennis,

On Sep 14 2016 or thereabouts, Dennis Wassenberg wrote:
&gt; The Lenovo X1 Tablet Cover is connected via USB. It constists of
&gt; 1 device with 3 usb interfaces. Interface 0 represents keyboard,
&gt; interface 1 the function / special keys and LED control, interface 2
&gt; is the Synaptics touchpad and pointing stick.
&gt; 
&gt; This driver will bind to interfaces 0 and 1 and handle function / special keys
&gt; including LED control.
&gt; HID: add device id for Lenovo X1 Tablet Cover
&gt; 
&gt; Signed-off-by: Dennis Wassenberg &lt;dennis.wassenberg@xxxxxxxxxxx&gt;
&gt; ---
&gt; Changes v1 -&gt; v2 (suggested by Benjamin Tissoires):
&gt;  * Squashed add of device IDs for Lenovo Thinkpad X1 Tablet Cover together with add of support for Lenovo Thinkpad X1 Tablet Cover into one patch
&gt; 

I wanted to review the first version, but got sidetracked.

So here it comes :)

&gt; 
&gt;  drivers/hid/hid-core.c     |   1 +
&gt;  drivers/hid/hid-ids.h      |   1 +
&gt;  drivers/hid/hid-lenovo.c   | 549 +++++++++++++++++++++++++++++++++++++++++++++

This seems to be too big for a single patch. Especially when you have
actually several changes that could be split for easier reviewing (LED,
special keys and keys stuck at least).

&gt;  include/linux/hid-lenovo.h |  15 ++
&gt;  4 files changed, 566 insertions(+)
&gt;  create mode 100644 include/linux/hid-lenovo.h
&gt; 
&gt; diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
&gt; index 6add0b6..ba6a200 100644
&gt; --- a/drivers/hid/hid-core.c
&gt; +++ b/drivers/hid/hid-core.c
&gt; @@ -2111,6 +2111,7 @@ void hid_disconnect(struct hid_device *hdev)
&gt;  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE2) },
&gt;  	{ HID_USB_DEVICE(USB_VENDOR_ID_RAZER, USB_DEVICE_ID_RAZER_BLADE_14) },
&gt;  	{ HID_USB_DEVICE(USB_VENDOR_ID_CMEDIA, USB_DEVICE_ID_CM6533) },
&gt; +	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_COVER) },

I know it's hard given the existing code, but please try to keep the
list sorted and insert your device in the appropriate place.

&gt;  	{ }
&gt;  };
&gt;  
&gt; diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
&gt; index 3466f0d..1f08fb5 100644
&gt; --- a/drivers/hid/hid-ids.h
&gt; +++ b/drivers/hid/hid-ids.h
&gt; @@ -615,6 +615,7 @@
&gt;  #define USB_DEVICE_ID_LENOVO_CUSBKBD	0x6047
&gt;  #define USB_DEVICE_ID_LENOVO_CBTKBD	0x6048
&gt;  #define USB_DEVICE_ID_LENOVO_TPPRODOCK	0x6067
&gt; +#define USB_DEVICE_ID_LENOVO_X1_COVER	0x6085
&gt;  
&gt;  #define USB_VENDOR_ID_LG		0x1fd2
&gt;  #define USB_DEVICE_ID_LG_MULTITOUCH	0x0064
&gt; diff --git a/drivers/hid/hid-lenovo.c b/drivers/hid/hid-lenovo.c
&gt; index 1ac4ff4..4251aac 100644
&gt; --- a/drivers/hid/hid-lenovo.c
&gt; +++ b/drivers/hid/hid-lenovo.c
&gt; @@ -3,9 +3,11 @@
&gt;   *  - ThinkPad USB Keyboard with TrackPoint (tpkbd)
&gt;   *  - ThinkPad Compact Bluetooth Keyboard with TrackPoint (cptkbd)
&gt;   *  - ThinkPad Compact USB Keyboard with TrackPoint (cptkbd)
&gt; + *  - ThinkPad X1 Cover USB Keyboard with TrackPoint and Touchpad (tpx1cover)
&gt;   *
&gt;   *  Copyright (c) 2012 Bernhard Seibold
&gt;   *  Copyright (c) 2014 Jamie Lentin &lt;jm@xxxxxxxxxxxx&gt;
&gt; + *  Copyright (c) 2016 Dennis Wassenberg &lt;dennis.wassenberg@xxxxxxxxxxx&gt;
&gt;   */
&gt;  
&gt;  /*
&gt; @@ -19,11 +21,19 @@
&gt;  #include &lt;linux/sysfs.h&gt;
&gt;  #include &lt;linux/device.h&gt;
&gt;  #include &lt;linux/hid.h&gt;
&gt; +#include &lt;linux/hid-lenovo.h&gt;
&gt;  #include &lt;linux/input.h&gt;
&gt;  #include &lt;linux/leds.h&gt;
&gt;  
&gt;  #include &quot;hid-ids.h&quot;
&gt;  
&gt; +struct led_table_entry {
&gt; +	struct led_classdev *dev;
&gt; +	uint8_t state;
&gt; +};
&gt; +
&gt; +static struct led_table_entry hid_lenovo_led_table[HID_LENOVO_LED_MAX];

Ouch. Please no static arrays containing random devices. The device is
USB, so you could have several of its kind plugged at once.

So, please include this array in the driver data in the hid device, and
if you need a list of hid device connected, use an actual list of struct
hid_device.
Well, you can also use a list of struct led_table_entry if you add a
field with the type, and iterate over the list for each call on the API
in case there are 2 or more LEDs of the same type.

&gt; +
&gt;  struct lenovo_drvdata_tpkbd {
&gt;  	int led_state;
&gt;  	struct led_classdev led_mute;
&gt; @@ -42,6 +52,37 @@ struct lenovo_drvdata_cptkbd {
&gt;  	int sensitivity;
&gt;  };
&gt;  
&gt; +struct lenovo_drvdata_tpx1cover {
&gt; +	uint16_t led_state;
&gt; +	uint8_t fnlock_state;
&gt; +	uint8_t led_present;
&gt; +	struct led_classdev led_mute;
&gt; +	struct led_classdev led_micmute;
&gt; +	struct led_classdev led_fnlock;
&gt; +};
&gt; +
&gt; +int hid_lenovo_led_set(int led_num, bool on)

You are declaring an enum for LEDs, I'd prefer see it used here (so you
have to give it a name first).

&gt; +{
&gt; +	struct led_classdev *dev;
&gt; +
&gt; +	if (led_num &gt;= HID_LENOVO_LED_MAX)
&gt; +		return -EINVAL;
&gt; +
&gt; +	dev = hid_lenovo_led_table[led_num].dev;
&gt; +	hid_lenovo_led_table[led_num].state = on;
&gt; +
&gt; +	if (!dev)
&gt; +		return -ENODEV;
&gt; +
&gt; +	if (!dev-&gt;brightness_set)
&gt; +		return -ENODEV;
&gt; +
&gt; +	dev-&gt;brightness_set(dev, on ? LED_FULL : LED_OFF);
&gt; +
&gt; +	return 0;
&gt; +}
&gt; +EXPORT_SYMBOL_GPL(hid_lenovo_led_set);
&gt; +
&gt;  #define map_key_clear(c) hid_map_usage_clear(hi, usage, bit, max, EV_KEY, (c))
&gt;  
&gt;  static const __u8 lenovo_pro_dock_need_fixup_collection[] = {
&gt; @@ -86,6 +127,84 @@ static int lenovo_input_mapping_tpkbd(struct hid_device *hdev,
&gt;  	return 0;
&gt;  }
&gt;  
&gt; +static int lenovo_input_mapping_tpx1cover(struct hid_device *hdev,
&gt; +		struct hid_input *hi, struct hid_field *field,
&gt; +		struct hid_usage *usage, unsigned long **bit, int *max)
&gt; +{
&gt; +	if ((usage-&gt;hid &amp; HID_USAGE_PAGE) == HID_UP_CONSUMER) {
&gt; +		switch (usage-&gt;hid &amp; HID_USAGE) {
&gt; +		case 0x0001: // Unknown keys -&gt; Idenditied by usage index!

Why don't use directly usage-&gt;hid and check for HID_CP_CONSUMERCONTROL (0x000c0001)?

Note that here you are working with keys while previously it was LED.
Split in 2 patches please.


&gt; +			map_key_clear(KEY_UNKNOWN);

why?
If the key doesn't seem to be used, please don't map it and return -1.

&gt; +			switch (usage-&gt;usage_index) {
&gt; +			case 0x8:

It feels weird to have an hexadecimal representation when dealing with
indexes.

&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_FN);

You should consider using map_key_clear(KEY_FN); instead. This way the
event handling code will be cheaper.

Rince, wash reapeat in the following cases.

&gt; +				break;
&gt; +
&gt; +			case 0x9:
&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_MICMUTE);
&gt; +				break;
&gt; +
&gt; +			case 0xa:
&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_CONFIG);
&gt; +				break;
&gt; +
&gt; +			case 0xb:
&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_SEARCH);
&gt; +				break;
&gt; +
&gt; +			case 0xc:
&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_SETUP);
&gt; +				break;
&gt; +
&gt; +			case 0xd:
&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_SWITCHVIDEOMODE);
&gt; +				break;
&gt; +
&gt; +			case 0xe:
&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_RFKILL);
&gt; +				break;
&gt; +
&gt; +			default:
&gt; +				return -1;
&gt; +			}
&gt; +
&gt; +			return 1;
&gt; +
&gt; +		case 0x006f: // Consumer.006f ---&gt; Key.BrightnessUp
&gt; +			map_key_clear(KEY_BRIGHTNESSUP);

Why are you overriding the existing behavior from hid-input if you are
using the same code?

Just return 0 and hid-input will set the values for you.

Rince, wash repeat for the rest of the cases.

&gt; +			return 1;
&gt; +
&gt; +		case 0x0070: // Consumer.0070 ---&gt; Key.BrightnessDown
&gt; +			map_key_clear(KEY_BRIGHTNESSDOWN);
&gt; +			return 1;
&gt; +
&gt; +		case 0x00b7:// Consumer.00b7 ---&gt; Key.StopCD
&gt; +			map_key_clear(KEY_STOPCD);
&gt; +			return 1;
&gt; +
&gt; +		case 0x00cd: // Consumer.00cd ---&gt; Key.PlayPause
&gt; +			map_key_clear(KEY_PLAYPAUSE);
&gt; +			return 1;
&gt; +
&gt; +		case 0x00e0: // Consumer.00e0 ---&gt; Absolute.Volume
&gt; +			return 0;
&gt; +		case 0x00e2: // Consumer.00e2 ---&gt; Key.Mute
&gt; +			map_key_clear(KEY_MUTE);
&gt; +			return 1;
&gt; +
&gt; +		case 0x00e9: // Consumer.00e9 ---&gt; Key.VolumeUp
&gt; +			map_key_clear(KEY_VOLUMEUP);
&gt; +			return 1;
&gt; +
&gt; +		case 0x00ea: // Consumer.00ea ---&gt; Key.VolumeDown
&gt; +			map_key_clear(KEY_VOLUMEDOWN);
&gt; +			return 1;
&gt; +		}
&gt; +	}
&gt; +
&gt; +	return 0;
&gt; +}
&gt; +
&gt;  static int lenovo_input_mapping_cptkbd(struct hid_device *hdev,
&gt;  		struct hid_input *hi, struct hid_field *field,
&gt;  		struct hid_usage *usage, unsigned long **bit, int *max)
&gt; @@ -172,6 +291,9 @@ static int lenovo_input_mapping(struct hid_device *hdev,
&gt;  	case USB_DEVICE_ID_LENOVO_CBTKBD:
&gt;  		return lenovo_input_mapping_cptkbd(hdev, hi, field,
&gt;  							usage, bit, max);
&gt; +	case USB_DEVICE_ID_LENOVO_X1_COVER:
&gt; +		return lenovo_input_mapping_tpx1cover(hdev, hi, field,
&gt; +							usage, bit, max);
&gt;  	default:
&gt;  		return 0;
&gt;  	}
&gt; @@ -362,6 +484,143 @@ static int lenovo_event_cptkbd(struct hid_device *hdev,
&gt;  	return 0;
&gt;  }
&gt;  
&gt; +static enum led_brightness lenovo_led_brightness_get_tpx1cover(
&gt; +			struct led_classdev *led_cdev)
&gt; +{
&gt; +	struct device *dev = led_cdev-&gt;dev-&gt;parent;
&gt; +	struct hid_device *hdev = to_hid_device(dev);
&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt; +	int led_nr = 0;

Would be even better to use the enum.

&gt; +
&gt; +	if (led_cdev == &amp;drv_data-&gt;led_mute)
&gt; +		led_nr = 0;
&gt; +	else if (led_cdev == &amp;drv_data-&gt;led_micmute)
&gt; +		led_nr = 1;
&gt; +	else if (led_cdev == &amp;drv_data-&gt;led_fnlock)
&gt; +		led_nr = 2;
&gt; +	else
&gt; +		return LED_OFF;
&gt; +
&gt; +	return drv_data-&gt;led_state &amp; (1 &lt;&lt; led_nr)
&gt; +				? LED_FULL
&gt; +				: LED_OFF;
&gt; +}
&gt; +
&gt; +static void lenovo_led_brightness_set_tpx1cover(struct led_classdev *led_cdev,
&gt; +			enum led_brightness value)
&gt; +{
&gt; +	struct device *dev = led_cdev-&gt;dev-&gt;parent;
&gt; +	struct hid_device *hdev = to_hid_device(dev);
&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt; +	struct hid_report *report;
&gt; +	int led_nr = -1;

Likewise, the enum would be nice

&gt; +	int led_nr_hw = -1;
&gt; +
&gt; +	if (led_cdev == &amp;drv_data-&gt;led_mute) {
&gt; +		led_nr = 0;
&gt; +		led_nr_hw = 0x64;

Are you sure you are not overriding bits in 0x44?

If you reorder the enum, I'd say the led_nr_hw could be represented as:
((led_nr + 1) &lt;&lt; 4) | 0x44

So I think this is too much to be just a coincidence.

&gt; +	} else if (led_cdev == &amp;drv_data-&gt;led_micmute) {
&gt; +		led_nr = 1;
&gt; +		led_nr_hw = 0x74;
&gt; +	} else if (led_cdev == &amp;drv_data-&gt;led_fnlock) {
&gt; +		led_nr = 2;
&gt; +		led_nr_hw = 0x54;
&gt; +	} else {
&gt; +		hid_warn(hdev, &quot;Invalid LED to set.\n&quot;);
&gt; +		return;
&gt; +	}
&gt; +
&gt; +	if (value == LED_OFF)
&gt; +		drv_data-&gt;led_state &amp;= ~(1 &lt;&lt; led_nr);
&gt; +	else
&gt; +		drv_data-&gt;led_state |= 1 &lt;&lt; led_nr;
&gt; +
&gt; +	report = hdev-&gt;report_enum[HID_OUTPUT_REPORT].report_id_hash[9];
&gt; +	if (report) {
&gt; +		report-&gt;field[0]-&gt;value[0] = led_nr_hw;
&gt; +		report-&gt;field[0]-&gt;value[1] = (drv_data-&gt;led_state &amp; (1 &lt;&lt; led_nr))
&gt; +			? 0x02 : 0x01;
&gt; +		hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
&gt; +	}
&gt; +}
&gt; +
&gt; +static int lenovo_event_tpx1cover(struct hid_device *hdev,
&gt; +		struct hid_field *field, struct hid_usage *usage, __s32 value)
&gt; +{
&gt; +	int ret = 0;
&gt; +
&gt; +	if ((usage-&gt;hid &amp; HID_USAGE_PAGE) == HID_UP_CONSUMER
&gt; +		&amp;&amp; (usage-&gt;hid &amp; HID_USAGE) == 0x0001) {
&gt; +
&gt; +		if (usage-&gt;usage_index == 0x8 &amp;&amp; value == 1) {
&gt; +			struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt; +
&gt; +			if (drv_data &amp;&amp; drv_data-&gt;led_present) {
&gt; +				drv_data-&gt;fnlock_state = lenovo_led_brightness_get_tpx1cover(
&gt; +						&amp;drv_data-&gt;led_fnlock) == LED_OFF ? 1 : 0;
&gt; +				lenovo_led_brightness_set_tpx1cover(
&gt; +					&amp;drv_data-&gt;led_fnlock,
&gt; +					drv_data-&gt;fnlock_state ? LED_FULL : LED_OFF);
&gt; +			}

This looks like a different semantic change where you sync the actual LED with the incoming event.
This is not something we usually do from the kernel but rely on the
userspace to do it for us. Not sure about the FN lock state though.

Anyway, if this needs to be there, it should have its own patch

&gt; +		}
&gt; +
&gt; +		if (usage-&gt;usage_index == 0x9 &amp;&amp; value == 1) {
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_MICMUTE, 1);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_MICMUTE, 0);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +			ret = 1;

Aren't you notified when the key is released?

If so, you should just drop the change because you used map_key_clear
above and hid-input will simply do the right thing for you.

If you are not notified, this is big enough a difference to have its own
patch.

Rince wash repeat

&gt; +		}
&gt; +
&gt; +		if (usage-&gt;usage_index == 0xa &amp;&amp; value == 1) {
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_CONFIG, 1);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_CONFIG, 0);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +
&gt; +			ret = 1;
&gt; +		}
&gt; +
&gt; +		if (usage-&gt;usage_index == 0xb &amp;&amp; value == 1) {
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SEARCH, 1);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SEARCH, 0);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +
&gt; +			ret = 1;
&gt; +		}
&gt; +
&gt; +		if (usage-&gt;usage_index == 0xc &amp;&amp; value == 1) {
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SETUP, 1);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SETUP, 0);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +
&gt; +			ret = 1;
&gt; +		}
&gt; +
&gt; +		if (usage-&gt;usage_index == 0xd &amp;&amp; value == 1) {
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SWITCHVIDEOMODE, 1);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SWITCHVIDEOMODE, 0);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +
&gt; +			ret = 1;
&gt; +		}
&gt; +
&gt; +		if (usage-&gt;usage_index == 0xe &amp;&amp; value == 1) {
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_RFKILL, 1);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_RFKILL, 0);
&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt; +
&gt; +			ret = 1;
&gt; +		}
&gt; +	}
&gt; +
&gt; +	return ret;
&gt; +}
&gt; +
&gt;  static int lenovo_event(struct hid_device *hdev, struct hid_field *field,
&gt;  		struct hid_usage *usage, __s32 value)
&gt;  {
&gt; @@ -369,6 +628,8 @@ static int lenovo_event(struct hid_device *hdev, struct hid_field *field,
&gt;  	case USB_DEVICE_ID_LENOVO_CUSBKBD:
&gt;  	case USB_DEVICE_ID_LENOVO_CBTKBD:
&gt;  		return lenovo_event_cptkbd(hdev, field, usage, value);
&gt; +	case USB_DEVICE_ID_LENOVO_X1_COVER:
&gt; +		return lenovo_event_tpx1cover(hdev, field, usage, value);
&gt;  	default:
&gt;  		return 0;
&gt;  	}
&gt; @@ -731,6 +992,251 @@ static int lenovo_probe_tpkbd(struct hid_device *hdev)
&gt;  	return ret;
&gt;  }
&gt;  
&gt; +static int lenovo_probe_tpx1cover_configure(struct hid_device *hdev)
&gt; +{
&gt; +	struct hid_report *report = hdev-&gt;report_enum[HID_OUTPUT_REPORT].report_id_hash[9];
&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt; +
&gt; +	if (!drv_data)
&gt; +		return -ENODEV;

Can this really happen?

&gt; +
&gt; +	if (!report)
&gt; +		return -ENOENT;
&gt; +
&gt; +	report-&gt;field[0]-&gt;value[0] = 0x54;
&gt; +	report-&gt;field[0]-&gt;value[1] = 0x20;
&gt; +	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
&gt; +	hid_hw_wait(hdev);
&gt; +
&gt; +	report-&gt;field[0]-&gt;value[0] = 0x54;
&gt; +	report-&gt;field[0]-&gt;value[1] = 0x08;
&gt; +	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
&gt; +	hid_hw_wait(hdev);
&gt; +
&gt; +	report-&gt;field[0]-&gt;value[0] = 0xA0;
&gt; +	report-&gt;field[0]-&gt;value[1] = 0x02;
&gt; +	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
&gt; +	hid_hw_wait(hdev);
&gt; +
&gt; +	lenovo_led_brightness_set_tpx1cover(&amp;drv_data-&gt;led_mute,
&gt; +		hid_lenovo_led_table[HID_LENOVO_LED_MUTE].state ? LED_FULL : LED_OFF);
&gt; +	hid_hw_wait(hdev);
&gt; +
&gt; +	lenovo_led_brightness_set_tpx1cover(&amp;drv_data-&gt;led_micmute,
&gt; +		hid_lenovo_led_table[HID_LENOVO_LED_MICMUTE].state ? LED_FULL : LED_OFF);
&gt; +	hid_hw_wait(hdev);
&gt; +
&gt; +	lenovo_led_brightness_set_tpx1cover(&amp;drv_data-&gt;led_fnlock, LED_FULL);
&gt; +
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static int lenovo_probe_tpx1cover_special_functions(struct hid_device *hdev)
&gt; +{
&gt; +	struct device *dev = &amp;hdev-&gt;dev;
&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = NULL;
&gt; +
&gt; +	size_t name_sz = strlen(dev_name(dev)) + 16;
&gt; +	char *name_led = NULL;
&gt; +
&gt; +	struct hid_report *report;
&gt; +	bool report_match = 1;
&gt; +
&gt; +	int ret = 0;
&gt; +
&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 2, 0, 3);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 3, 0, 16);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_OUTPUT_REPORT, 9, 0, 2);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 32, 0, 1);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 84, 0, 1);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 100, 0, 1);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 116, 0, 1);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 132, 0, 1);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 144, 0, 1);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 162, 0, 1);
&gt; +	report_match &amp;= report ? 1 : 0;

It feels weird to have you check if those reports are actually long
enough. I think this is related to checking which interface you have,
but you should be able to reduce the list to only those you are actually
using (report id &quot;9&quot; seems like a good candidate).

And please add a comment why you are checking some specific report IDs.

&gt; +
&gt; +	if (!report_match) {
&gt; +		ret = -ENODEV;
&gt; +		goto err;

just return -ENODEV here.

&gt; +	}
&gt; +
&gt; +	drv_data = devm_kzalloc(&amp;hdev-&gt;dev,
&gt; +			sizeof(struct lenovo_drvdata_tpx1cover),
&gt; +			GFP_KERNEL);
&gt; +
&gt; +	if (!drv_data) {
&gt; +		hid_err(hdev,
&gt; +			&quot;Could not allocate memory for tpx1cover driver data\n&quot;);
&gt; +		ret = -ENOMEM;
&gt; +		goto err;

Just return -ENODEV too, the devres manager will kfree drv_data for you.

&gt; +	}
&gt; +
&gt; +	name_led = devm_kzalloc(&amp;hdev-&gt;dev, name_sz, GFP_KERNEL);
&gt; +	if (!name_led) {
&gt; +		hid_err(hdev, &quot;Could not allocate memory for mute led data\n&quot;);
&gt; +		ret = -ENOMEM;
&gt; +		goto err_cleanup;

likewise

&gt; +	}
&gt; +	snprintf(name_led, name_sz, &quot;%s:amber:mute&quot;, dev_name(dev));
&gt; +
&gt; +	drv_data-&gt;led_mute.name = name_led;
&gt; +	drv_data-&gt;led_mute.brightness_get = lenovo_led_brightness_get_tpx1cover;
&gt; +	drv_data-&gt;led_mute.brightness_set = lenovo_led_brightness_set_tpx1cover;
&gt; +	drv_data-&gt;led_mute.dev = dev;
&gt; +	hid_lenovo_led_table[HID_LENOVO_LED_MUTE].dev = &amp;drv_data-&gt;led_mute;
&gt; +	led_classdev_register(dev, &amp;drv_data-&gt;led_mute);

Isn't devm_led_class_register working?

That would be nice because you could drop all of your cleanup paths

&gt; +
&gt; +
&gt; +	name_led = devm_kzalloc(&amp;hdev-&gt;dev, name_sz, GFP_KERNEL);
&gt; +	if (!name_led) {
&gt; +		hid_err(hdev,
&gt; +			&quot;Could not allocate memory for mic mute led data\n&quot;);
&gt; +		ret = -ENOMEM;
&gt; +		goto err_cleanup;

ditto

&gt; +	}
&gt; +	snprintf(name_led, name_sz, &quot;%s:amber:micmute&quot;, dev_name(dev));
&gt; +
&gt; +	drv_data-&gt;led_micmute.name = name_led;
&gt; +	drv_data-&gt;led_micmute.brightness_get = lenovo_led_brightness_get_tpx1cover;
&gt; +	drv_data-&gt;led_micmute.brightness_set = lenovo_led_brightness_set_tpx1cover;
&gt; +	drv_data-&gt;led_micmute.dev = dev;
&gt; +	hid_lenovo_led_table[HID_LENOVO_LED_MICMUTE].dev = &amp;drv_data-&gt;led_micmute;
&gt; +	led_classdev_register(dev, &amp;drv_data-&gt;led_micmute);
&gt; +
&gt; +
&gt; +	name_led = devm_kzalloc(&amp;hdev-&gt;dev, name_sz, GFP_KERNEL);
&gt; +	if (!name_led) {
&gt; +		hid_err(hdev,
&gt; +			&quot;Could not allocate memory for FN lock led data\n&quot;);
&gt; +		ret = -ENOMEM;
&gt; +		goto err_cleanup;

ditto

&gt; +	}
&gt; +
&gt; +	snprintf(name_led, name_sz, &quot;%s:amber:fnlock&quot;, dev_name(dev));
&gt; +
&gt; +	drv_data-&gt;led_fnlock.name = name_led;
&gt; +	drv_data-&gt;led_fnlock.brightness_get = lenovo_led_brightness_get_tpx1cover;
&gt; +	drv_data-&gt;led_fnlock.brightness_set = lenovo_led_brightness_set_tpx1cover;
&gt; +	drv_data-&gt;led_fnlock.dev = dev;
&gt; +	hid_lenovo_led_table[HID_LENOVO_LED_FNLOCK].dev = &amp;drv_data-&gt;led_fnlock;
&gt; +	led_classdev_register(dev, &amp;drv_data-&gt;led_fnlock);

ditto

&gt; +
&gt; +	drv_data-&gt;led_state = 0;
&gt; +	drv_data-&gt;fnlock_state = 1;
&gt; +	drv_data-&gt;led_present = 1;
&gt; +
&gt; +	hid_set_drvdata(hdev, drv_data);
&gt; +
&gt; +	return lenovo_probe_tpx1cover_configure(hdev);
&gt; +
&gt; +err_cleanup:

Shouldn't be required if you use devm_led_classdev_register().

&gt; +	if (drv_data-&gt;led_fnlock.name) {
&gt; +		led_classdev_unregister(&amp;drv_data-&gt;led_fnlock);
&gt; +		devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_fnlock.name);
&gt; +	}
&gt; +
&gt; +	if (drv_data-&gt;led_micmute.name) {
&gt; +		led_classdev_unregister(&amp;drv_data-&gt;led_micmute);
&gt; +		devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_micmute.name);
&gt; +	}
&gt; +
&gt; +	if (drv_data-&gt;led_mute.name) {
&gt; +		led_classdev_unregister(&amp;drv_data-&gt;led_mute);
&gt; +		devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_mute.name);
&gt; +	}
&gt; +
&gt; +	if (drv_data)
&gt; +		kfree(drv_data);
&gt; +
&gt; +err:
&gt; +	return ret;
&gt; +}
&gt; +
&gt; +static int lenovo_probe_tpx1cover_touch(struct hid_device *hdev)
&gt; +{
&gt; +	struct hid_report *report;
&gt; +	bool report_match = 1;
&gt; +	int ret = 0;
&gt; +
&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 2, 0, 2);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 2, 1, 2);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 11, 0, 61);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 12, 0, 61);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 16, 0, 3);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 16, 1, 2);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_OUTPUT_REPORT, 9, 0, 20);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_OUTPUT_REPORT, 10, 0, 20);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 14, 0, 1);
&gt; +	report_match &amp;= report ? 1 : 0;
&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 15, 0, 3);
&gt; +	report_match &amp;= report ? 1 : 0;

Feels weird too (especially if there is no comment explaining why you
are doing those checks).

&gt; +
&gt; +	if (!report_match)
&gt; +		ret = -ENODEV;
&gt; +
&gt; +	return ret;
&gt; +}
&gt; +
&gt; +static int lenovo_probe_tpx1cover(struct hid_device *hdev)
&gt; +{
&gt; +	int ret = 0;
&gt; +
&gt; +	/*
&gt; +	 * Probing for special function keys and LED control -&gt; usb intf 1
&gt; +	 * Probing for touch input -&gt; usb intf 2 (handled by rmi4 driver)
&gt; +	 * Other (keyboard) -&gt; usb intf 0
&gt; +	 */
&gt; +	if (!lenovo_probe_tpx1cover_special_functions(hdev)) {
&gt; +		// special function keys and LED control

No C++ style comments please.

&gt; +		ret = 0;
&gt; +	} else if (!lenovo_probe_tpx1cover_touch(hdev)) {
&gt; +		// handled by rmi
&gt; +		ret = -ENODEV;

I don't quite get how the touch can be handled if you just return
-ENODEV here. Given that the device has been added to
hid_have_special_driver, if you don't claim the device, no one else will
unless you add the ID in the other HID driver.

&gt; +	} else {
&gt; +		// keyboard

Why is that keyboard chunk not given it's own probe function?

&gt; +		struct lenovo_drvdata_tpx1cover *drv_data;
&gt; +
&gt; +		drv_data = devm_kzalloc(&amp;hdev-&gt;dev,
&gt; +					sizeof(struct lenovo_drvdata_tpx1cover),
&gt; +					GFP_KERNEL);
&gt; +
&gt; +		if (!drv_data) {
&gt; +			hid_err(hdev,
&gt; +				&quot;Could not allocate memory for tpx1cover driver data\n&quot;);
&gt; +			ret = -ENOMEM;
&gt; +			goto out;

no need for a goto here. Just a plain return -ENOMEM should be good
enough.

&gt; +		}
&gt; +
&gt; +		drv_data-&gt;led_state = 0;
&gt; +		drv_data-&gt;led_present = 0;
&gt; +		drv_data-&gt;fnlock_state = 0;
&gt; +		hid_set_drvdata(hdev, drv_data);
&gt; +
&gt; +		ret = 0;
&gt; +	}
&gt; +
&gt; +out:
&gt; +	return ret;
&gt; +}
&gt; +
&gt;  static int lenovo_probe_cptkbd(struct hid_device *hdev)
&gt;  {
&gt;  	int ret;
&gt; @@ -803,6 +1309,9 @@ static int lenovo_probe(struct hid_device *hdev,
&gt;  	case USB_DEVICE_ID_LENOVO_CBTKBD:
&gt;  		ret = lenovo_probe_cptkbd(hdev);
&gt;  		break;
&gt; +	case USB_DEVICE_ID_LENOVO_X1_COVER:
&gt; +		ret = lenovo_probe_tpx1cover(hdev);
&gt; +		break;
&gt;  	default:
&gt;  		ret = 0;
&gt;  		break;
&gt; @@ -843,6 +1352,42 @@ static void lenovo_remove_cptkbd(struct hid_device *hdev)
&gt;  			&amp;lenovo_attr_group_cptkbd);
&gt;  }
&gt;  
&gt; +static void lenovo_remove_tpx1cover(struct hid_device *hdev)
&gt; +{
&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt; +
&gt; +	if (!drv_data)
&gt; +		return;
&gt; +
&gt; +	if (drv_data-&gt;led_present) {
&gt; +		if (drv_data-&gt;led_fnlock.name) {
&gt; +			hid_lenovo_led_table[HID_LENOVO_LED_FNLOCK].dev = NULL;
&gt; +
&gt; +			led_classdev_unregister(&amp;drv_data-&gt;led_fnlock);
&gt; +			devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_fnlock.name);

Calling yourself devm_kfree usually means there is something wrong.
Here, if you used devm_led_*, you could just drop the entire remove
function.

&gt; +		}
&gt; +
&gt; +		if (drv_data-&gt;led_micmute.name) {
&gt; +			hid_lenovo_led_table[HID_LENOVO_LED_MICMUTE].dev = NULL;
&gt; +
&gt; +			led_classdev_unregister(&amp;drv_data-&gt;led_micmute);
&gt; +			devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_micmute.name);
&gt; +		}
&gt; +
&gt; +		if (drv_data-&gt;led_mute.name) {
&gt; +			hid_lenovo_led_table[HID_LENOVO_LED_MUTE].dev = NULL;
&gt; +
&gt; +			led_classdev_unregister(&amp;drv_data-&gt;led_mute);
&gt; +			devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_mute.name);
&gt; +		}
&gt; +	}
&gt; +
&gt; +	if (drv_data)
&gt; +		devm_kfree(&amp;hdev-&gt;dev, drv_data);
&gt; +
&gt; +	hid_set_drvdata(hdev, NULL);
&gt; +}
&gt; +
&gt;  static void lenovo_remove(struct hid_device *hdev)
&gt;  {
&gt;  	switch (hdev-&gt;product) {
&gt; @@ -853,6 +1398,9 @@ static void lenovo_remove(struct hid_device *hdev)
&gt;  	case USB_DEVICE_ID_LENOVO_CBTKBD:
&gt;  		lenovo_remove_cptkbd(hdev);
&gt;  		break;
&gt; +	case USB_DEVICE_ID_LENOVO_X1_COVER:
&gt; +		lenovo_remove_tpx1cover(hdev);
&gt; +		break;
&gt;  	}
&gt;  
&gt;  	hid_hw_stop(hdev);
&gt; @@ -883,6 +1431,7 @@ static int lenovo_input_configured(struct hid_device *hdev,
&gt;  	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CUSBKBD) },
&gt;  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CBTKBD) },
&gt;  	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPPRODOCK) },
&gt; +	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_COVER) },
&gt;  	{ }
&gt;  };
&gt;  
&gt; diff --git a/include/linux/hid-lenovo.h b/include/linux/hid-lenovo.h
&gt; new file mode 100644
&gt; index 0000000..d0b0145
&gt; --- /dev/null
&gt; +++ b/include/linux/hid-lenovo.h
&gt; @@ -0,0 +1,15 @@
&gt; +
&gt; +#ifndef __HID_LENOVO_H__
&gt; +#define __HID_LENOVO_H__
&gt; +
&gt; +
&gt; +enum {
&gt; +	HID_LENOVO_LED_MUTE,

I'd rather have a name for the enum (so you can reuse it), and also have
each enum given its numerical value (or at least the first and last.

&gt; +	HID_LENOVO_LED_MICMUTE,
&gt; +	HID_LENOVO_LED_FNLOCK,
&gt; +	HID_LENOVO_LED_MAX,
&gt; +};
&gt; +
&gt; +int hid_lenovo_led_set(int led_num, bool on);
&gt; +
&gt; +#endif /* __HID_LENOVO_H_ */
&gt; -- 
&gt; 1.i9.1


Cheers,
Benjamin
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-sound&quot; in
the body of a message to majordomo@xxxxxxxxxxxxxxx
More majordomo info at  <a  rel="nofollow" href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00630" href="msg00630.html">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
<ul><li><em>From:</em> Dennis Wassenberg</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00626" href="msg00626.html">[PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
<ul><li><em>From:</em> Dennis Wassenberg</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00627.html">[PATCH v2 2/2] hda: thinkpad_helper: Add support for hid-lenovo LED control</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00629.html">Re: [alsa-devel] [PATCH v2 2/2] hda: thinkpad_helper: Add support for hid-lenovo LED control</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00626.html">[PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00630.html">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00628"><strong>Date</strong></a></li>
<li><a href="index.html#00628"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/Pulseaudio/>[Pulseaudio]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/alsa-devel/>[ALSA&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=http://www.ske-art.com/z/biglist.html>[Big&nbsp;List&nbsp;of&nbsp;Linux&nbsp;Books]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td valign=top align=left>&nbsp;</td>
<td valign=top align=right>
<a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
