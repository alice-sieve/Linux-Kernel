<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier -->
<!--X-From-R13: Tryvcr Pnyov &#60;onyovNgv.pbz> -->
<!--X-Date: Wed, 2 Jul 2014 08:03:28 &#45;0700 -->
<!--X-Message-Id: 20140702150259.GC5541@saruman.home -->
<!--X-Content-Type: multipart/signed -->
<!--X-Reference: 1404307852&#45;10456&#45;1&#45;git&#45;send&#45;email&#45;dmurphy@ti.com -->
<!--X-Reference: 20140702141001.GA5541@saruman.home -->
<!--X-Reference: 53B41CD6.8090403@ti.com -->
<!--X-Derived: pgp1OPrqucdhX.pgp -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Sound: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Sound &mdash; Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</title>
<link rel="alternate" type="application/rss+xml" title="Linux Sound" href="//feeds.feedburner.com/LinuxSound">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:6612422167" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</h1>
[<a href="msg00483.html">Date Prev</a>][<a href="msg00485.html">Date Next</a>][<a href="msg00482.html">Thread Prev</a>][<a href="msg00485.html">Thread Next</a>][<a href="maillist.html#00484">Date Index</a>][<a href="index.html#00484">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</li>
<li><em>From</em>: Felipe Balbi &lt;<a href="mailto:balbi@DOMAIN.HIDDEN">balbi@xxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 2 Jul 2014 10:03:00 -0500</li>
<li><em>Cc</em>: &lt;<a href="mailto:balbi@DOMAIN.HIDDEN">balbi@xxxxxx</a>&gt;, &lt;<a href="mailto:linux-sound@DOMAIN.HIDDEN">linux-sound@xxxxxxxxxxxxxxx</a>&gt;,        &lt;<a href="mailto:linux-kernel@DOMAIN.HIDDEN">linux-kernel@xxxxxxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:alsa-devel@DOMAIN.HIDDEN">alsa-devel@xxxxxxxxxxxxxxxx</a>&gt;,        &lt;<a href="mailto:broonie@DOMAIN.HIDDEN">broonie@xxxxxxxxxx</a>&gt;, &lt;<a href="mailto:devicetree@DOMAIN.HIDDEN">devicetree@xxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg00482.html">53B41CD6.8090403@ti.com</a>&gt;</li>
<li><em>Reply-to</em>: &lt;<a href="mailto:balbi@DOMAIN.HIDDEN">balbi@xxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.5.23 (2014-03-12)</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Hi,

On Wed, Jul 02, 2014 at 09:53:10AM -0500, Dan Murphy wrote:
&gt; Felipe
&gt; Thanks for the review
&gt; 
&gt; On 07/02/2014 09:10 AM, Felipe Balbi wrote:
&gt; &gt; Hi,
&gt; &gt;
&gt; &gt; On Wed, Jul 02, 2014 at 08:30:52AM -0500, Dan Murphy wrote:
&gt; &gt;&gt; Support the TI TAS2552 Class D amplifier.
&gt; &gt;&gt;
&gt; &gt;&gt; The TAS2552 is a high efficiency Class-D audio
&gt; &gt;&gt; power amplifier with advanced battery current
&gt; &gt;&gt; management and an integrated Class-G boost
&gt; &gt;&gt; The device constantly measures the
&gt; &gt;&gt; current and voltage across the load and provides a
&gt; &gt;&gt; digital stream of this information.
&gt; &gt;&gt;
&gt; &gt;&gt; Signed-off-by: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt; &gt;&gt; ---
&gt; &gt;&gt;
&gt; &gt;&gt; v3 - Updated bindings doc per comments, rearranged probe pdata vs 
&gt; &gt;&gt; np check - <a  rel="nofollow" href="https://patchwork.kernel.org/patch/4453481/">https://patchwork.kernel.org/patch/4453481/</a>
&gt; &gt;&gt;
&gt; &gt;&gt;  .../devicetree/bindings/sound/tas2552.txt          |   22 +
&gt; &gt;&gt;  include/sound/tas2552-plat.h                       |   25 ++
&gt; &gt;&gt;  sound/soc/codecs/Kconfig                           |    5 +
&gt; &gt;&gt;  sound/soc/codecs/Makefile                          |    2 +
&gt; &gt;&gt;  sound/soc/codecs/tas2552.c                         |  463 ++++++++++++++++++++
&gt; &gt;&gt;  sound/soc/codecs/tas2552.h                         |   75 ++++
&gt; &gt;&gt;  6 files changed, 592 insertions(+)
&gt; &gt;&gt;  create mode 100644 Documentation/devicetree/bindings/sound/tas2552.txt
&gt; &gt;&gt;  create mode 100644 include/sound/tas2552-plat.h
&gt; &gt;&gt;  create mode 100644 sound/soc/codecs/tas2552.c
&gt; &gt;&gt;  create mode 100644 sound/soc/codecs/tas2552.h
&gt; &gt;&gt;
&gt; &gt;&gt; diff --git a/Documentation/devicetree/bindings/sound/tas2552.txt b/Documentation/devicetree/bindings/sound/tas2552.txt
&gt; &gt;&gt; new file mode 100644
&gt; &gt;&gt; index 0000000..ada8fd4
&gt; &gt;&gt; --- /dev/null
&gt; &gt;&gt; +++ b/Documentation/devicetree/bindings/sound/tas2552.txt
&gt; &gt;&gt; @@ -0,0 +1,22 @@
&gt; &gt;&gt; +Texas Instruments - tas2552 Codec module
&gt; &gt;&gt; +
&gt; &gt;&gt; +The tas2552 serial control bus communicates through I2C protocols
&gt; &gt;&gt; +
&gt; &gt;&gt; +Required properties:
&gt; &gt;&gt; +
&gt; &gt;&gt; +- compatible - One of:
&gt; &gt;&gt; +    &quot;ti,tas2552&quot; - TAS2552
&gt; &gt;&gt; +
&gt; &gt;&gt; +- reg -  I2C slave address
&gt; &gt;&gt; +
&gt; &gt;&gt; +Optional properties:
&gt; &gt;&gt; +
&gt; &gt;&gt; +- power-gpio - gpio pin to enable/disable the device
&gt; &gt;&gt; +
&gt; &gt;&gt; +Example:
&gt; &gt;&gt; +
&gt; &gt;&gt; +tas2552: tas2552@41 {
&gt; &gt;&gt; +	compatible = &quot;ti,tas2552&quot;;
&gt; &gt;&gt; +	reg = &lt;0x41&gt;;
&gt; &gt;&gt; +	enable-gpio = &lt;&amp;gpio4 2 GPIO_ACTIVE_HIGH&gt;;
&gt; &gt; you probably want to add:
&gt; &gt;
&gt; &gt; 	pvdd-supply = &lt;&amp;pvdd&gt;;
&gt; &gt; 	vbat-supply = &lt;&amp;vbat&gt;;
&gt; &gt; 	avdd-supply = &lt;&amp;avdd&gt;;
&gt; &gt; 	iovdd-supply = &lt;&amp;iovdd&gt;;
&gt; &gt;
&gt; &gt; that way you can make sure to switch your regulators on from the driver.
&gt; &gt; Since they must be all on, you can just grab them all with
&gt; &gt; regulator_bulk_get() and enable them all with regulator_bulk_enable().
&gt; 
&gt; I could add this but I don't have a use case for this so I did not add
&gt; the code.

actually, you do. Right now you have a device which is powered by
several different sources (fixed or not).

&gt; The supplies I used were always-on so adding the regulators was not
&gt; testable in this patchset.

it _is_ testable. regulator_get()/regulator_enable() still works on
fixed regulators.

&gt; &gt;&gt; @@ -325,3 +326,4 @@ obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
&gt; &gt;&gt;  # Amp
&gt; &gt;&gt;  obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
&gt; &gt;&gt;  obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
&gt; &gt;&gt; +obj-$(CONFIG_SND_SOC_TAS2552)	+= snd-soc-tas2552.o
&gt; &gt;&gt; diff --git a/sound/soc/codecs/tas2552.c b/sound/soc/codecs/tas2552.c
&gt; &gt;&gt; new file mode 100644
&gt; &gt;&gt; index 0000000..79b8212
&gt; &gt;&gt; --- /dev/null
&gt; &gt;&gt; +++ b/sound/soc/codecs/tas2552.c
&gt; &gt;&gt; @@ -0,0 +1,463 @@
&gt; &gt;&gt; +/*
&gt; &gt;&gt; + * ALSA SoC Texas Instruments TAS2552 Mono Audio Amplifier
&gt; &gt;&gt; + *
&gt; &gt;&gt; + * Copyright (C) 2014 Texas Instruments Inc.
&gt; &gt;&gt; + *
&gt; &gt;&gt; + * Author: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt; &gt;&gt; + *
&gt; &gt;&gt; + * This program is free software; you can redistribute it and/or
&gt; &gt;&gt; + * modify it under the terms of the GNU General Public License
&gt; &gt;&gt; + * version 2 as published by the Free Software Foundation.
&gt; &gt;&gt; + *
&gt; &gt;&gt; + * This program is distributed in the hope that it will be useful, but
&gt; &gt;&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of
&gt; &gt;&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&gt; &gt;&gt; + * General Public License for more details.
&gt; &gt;&gt; + */
&gt; &gt;&gt; +
&gt; &gt;&gt; +#include &lt;linux/module.h&gt;
&gt; &gt;&gt; +#include &lt;linux/errno.h&gt;
&gt; &gt;&gt; +#include &lt;linux/device.h&gt;
&gt; &gt;&gt; +#include &lt;linux/i2c.h&gt;
&gt; &gt;&gt; +#include &lt;linux/gpio.h&gt;
&gt; &gt;&gt; +#include &lt;linux/of_gpio.h&gt;
&gt; &gt;&gt; +#include &lt;linux/regmap.h&gt;
&gt; &gt;&gt; +#include &lt;linux/slab.h&gt;
&gt; &gt;&gt; +
&gt; &gt;&gt; +#include &lt;sound/pcm.h&gt;
&gt; &gt;&gt; +#include &lt;sound/pcm_params.h&gt;
&gt; &gt;&gt; +#include &lt;sound/soc.h&gt;
&gt; &gt;&gt; +#include &lt;sound/soc-dapm.h&gt;
&gt; &gt;&gt; +#include &lt;sound/tlv.h&gt;
&gt; &gt;&gt; +#include &lt;sound/tas2552-plat.h&gt;
&gt; &gt;&gt; +
&gt; &gt;&gt; +#include &quot;tas2552.h&quot;
&gt; &gt;&gt; +
&gt; &gt;&gt; +static struct reg_default tas2552_reg_defs[] = {
&gt; &gt;&gt; +	{TAS2552_CFG_1, 0x16},
&gt; &gt;&gt; +	{TAS2552_CFG_3, 0x5E},
&gt; &gt;&gt; +	{TAS2552_DOUT, 0x00},
&gt; &gt;&gt; +	{TAS2552_OUTPUT_DATA, 0xC8},
&gt; &gt;&gt; +	{TAS2552_PDM_CFG, 0x02},
&gt; &gt;&gt; +	{TAS2552_PGA_GAIN, 0x10},
&gt; &gt;&gt; +	{TAS2552_BOOST_PT_CTRL, 0x0F},
&gt; &gt;&gt; +	{TAS2552_LIMIT_LVL_CTRL, 0x0C},
&gt; &gt;&gt; +	{TAS2552_LIMIT_RATE_HYS, 0x20},
&gt; &gt;&gt; +	{TAS2552_CFG_2, 0xEA},
&gt; &gt;&gt; +	{TAS2552_SER_CTRL_1, 0x00},
&gt; &gt;&gt; +	{TAS2552_SER_CTRL_2, 0x00},
&gt; &gt;&gt; +	{TAS2552_PLL_CTRL_1, 0x10},
&gt; &gt;&gt; +	{TAS2552_PLL_CTRL_2, 0x00},
&gt; &gt;&gt; +	{TAS2552_PLL_CTRL_3, 0x00},
&gt; &gt;&gt; +	{TAS2552_BTIP, 0x8f},
&gt; &gt;&gt; +	{TAS2552_BTS_CTRL, 0x80},
&gt; &gt;&gt; +	{TAS2552_LIMIT_RELEASE, 0x05},
&gt; &gt;&gt; +	{TAS2552_LIMIT_INT_COUNT, 0x00},
&gt; &gt;&gt; +	{TAS2552_EDGE_RATE_CTRL, 0x40},
&gt; &gt;&gt; +	{TAS2552_VBAT_DATA, 0x00},
&gt; &gt;&gt; +};
&gt; &gt;&gt; +
&gt; &gt;&gt; +struct tas2552_data {
&gt; &gt;&gt; +	struct mutex mutex;
&gt; &gt;&gt; +	struct snd_soc_codec *codec;
&gt; &gt;&gt; +	struct regmap *regmap;
&gt; &gt;&gt; +	struct i2c_client *tas2552_client;
&gt; &gt;&gt; +	unsigned char regs[TAS2552_VBAT_DATA];
&gt; &gt;&gt; +	int power_gpio;
&gt; &gt;&gt; +	u8 power_state:1;
&gt; &gt;&gt; +};
&gt; &gt;&gt; +
&gt; &gt;&gt; +static int tas2552_power(struct tas2552_data *data, u8 power)
&gt; &gt;&gt; +{
&gt; &gt;&gt; +	int	ret = 0;
&gt; &gt;&gt; +
&gt; &gt;&gt; +	BUG_ON(data-&gt;tas2552_client == NULL);
&gt; &gt; don't hang the entire machine because of a bug on the amplifier driver,
&gt; &gt; WARN() should be enough, followed by the return of an error code.
&gt; &gt;
&gt; &gt; In fact, is this really necessary ? It would be a simple bug on the
&gt; &gt; driver to fix.
&gt; 
&gt; Yeah I can remove this.  I was following an older example.
&gt; 
&gt; &gt;
&gt; &gt;&gt; +
&gt; &gt;&gt; +	mutex_lock(&amp;data-&gt;mutex);
&gt; &gt;&gt; +	if (power == data-&gt;power_state)
&gt; &gt; Same here. Is this really necessary ? It's simple to guarantee this case
&gt; &gt; won't happen in code.
&gt; 
&gt; Yes this LOC is necessary.  It is checking the current state of the tas2552.

heh, the point is that all your calls to this function can be balanced
easily, so this check becomes pointless, as it will never be true.

&gt; &gt;&gt; +		goto exit;
&gt; &gt;&gt; +
&gt; &gt;&gt; +	if (power) {
&gt; &gt;&gt; +		if (data-&gt;power_gpio &gt;= 0)
&gt; &gt;&gt; +			gpio_set_value(data-&gt;power_gpio, 1);
&gt; &gt;&gt; +
&gt; &gt;&gt; +		data-&gt;power_state = 1;
&gt; &gt;&gt; +	} else {
&gt; &gt;&gt; +		if (data-&gt;power_gpio &gt;= 0)
&gt; &gt;&gt; +			gpio_set_value(data-&gt;power_gpio, 0);
&gt; &gt;&gt; +
&gt; &gt;&gt; +		data-&gt;power_state = 0;
&gt; &gt;&gt; +	}
&gt; &gt;&gt; +
&gt; &gt;&gt; +exit:
&gt; &gt;&gt; +	mutex_unlock(&amp;data-&gt;mutex);
&gt; &gt;&gt; +	return ret;
&gt; &gt;&gt; +}
&gt; &gt;&gt; +
&gt; &gt;&gt; +static void tas2552_sw_shutdown(struct tas2552_data *tas_data, int sw_shutdown)
&gt; &gt;&gt; +{
&gt; &gt;&gt; +	u8 cfg1_reg = 0x0;
&gt; &gt;&gt; +
&gt; &gt;&gt; +	if (sw_shutdown)
&gt; &gt;&gt; +		cfg1_reg |= (sw_shutdown &lt;&lt; 1);
&gt; &gt; this line is dangerous. You're using a 32-bit variable to write a single
&gt; &gt; bit on cfg1 register. What if user passes 0xff on sw_shutdown ?
&gt; &gt;
&gt; &gt; I think a better approach would be to:
&gt; &gt;
&gt; &gt; a) first of all, move this sw_shutdown function to
&gt; &gt; runtime_suspend/runtime_resume.
&gt; 
&gt; Yeah that is not the intent of this API.  This API is called when the ALSA layer
&gt; opens/closes the device.  It is not governed by pm calls.

and PM calls are exactly for that. You start with a powered off device,
then when user wants to use it, you power it up. This is exactly what's
you're doing here.

&gt; &gt; b) to the check as below:
&gt; &gt;
&gt; &gt; 	if (shutdown)
&gt; &gt; 		cfg1_reg |= TAS2552_SWS;
&gt; &gt; 	else
&gt; &gt; 		cfg1_reg &amp;= ~TAS2552_SWS;
&gt; &gt;
&gt; &gt; then, of course #define TAS2552_SWS (1 &lt;&lt; 1) (or BIT(1), even)
&gt; 
&gt; But I will make this change.
&gt; 
&gt; &gt;
&gt; &gt;&gt; +	else
&gt; &gt;&gt; +		cfg1_reg &amp;= ~TAS2552_SWS_MASK;
&gt; &gt;&gt; +
&gt; &gt;&gt; +	snd_soc_update_bits(tas_data-&gt;codec, TAS2552_CFG_1,
&gt; &gt;&gt; +						 TAS2552_SWS_MASK, cfg1_reg);
&gt; &gt;&gt; +}
&gt; &gt;&gt; +
&gt; &gt;&gt; +static void tas2552_init(struct snd_soc_codec *codec)
&gt; &gt;&gt; +{
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_CFG_1, 0x16);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_CFG_3, 0x5E);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_DOUT, 0x00);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_OUTPUT_DATA, 0xC8);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_PDM_CFG, 0x02);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_PGA_GAIN, 0x10);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_BOOST_PT_CTRL, 0x0F);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_LIMIT_LVL_CTRL, 0x0C);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_LIMIT_RATE_HYS, 0x20);
&gt; &gt;&gt; +	snd_soc_write(codec, TAS2552_CFG_2, 0xEA);
&gt; &gt; what do all these magic constants mean ? Also, lower case hex numbers
&gt; &gt; are usually preferred.
&gt; 
&gt; I will add comments to what the numbers mean and change to lower case

I would rather see proper bit macros and the driver using them.

&gt; &gt; No battery tracking ?  Any plans to add that at a later date ? It's
&gt; &gt; probably not needed to have functional audio, but might have some use
&gt; &gt; cases where you want it.
&gt; 
&gt; The battery tracking was not the scope of the driver.  We just need to
&gt; get the basic driver in place with audio functional and add the
&gt; battery tracking later.

it's a single bit

&gt; I also did not have a device that had the battery tracking enabled so
&gt; I could not develop that level of code anyway.

device will track your constant VBAT and, ideally, since voltage would
never drop on VBAT, it shouldn't have to adjust gain.

&gt; &gt; /* goes re-read datasheet */
&gt; &gt;
&gt; &gt; Actually, I strongly believe you want to enable battery tracking (LIM_EN
&gt; &gt; on cfg2).
&gt; &gt;
&gt; &gt;&gt; +}
&gt; &gt;&gt; +
&gt; &gt;&gt; +static int tas2552_hw_params(struct snd_pcm_substream *substream,
&gt; &gt;&gt; +			     struct snd_pcm_hw_params *params,
&gt; &gt;&gt; +			     struct snd_soc_dai *dai)
&gt; &gt;&gt; +{
&gt; &gt;&gt; +	u8 wclk_reg;
&gt; &gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; &gt;&gt; +
&gt; &gt;&gt; +	/* Setting DAC clock dividers based on substream sample rate. */
&gt; &gt;&gt; +	switch (params_rate(params)) {
&gt; &gt;&gt; +	case 8000:
&gt; &gt;&gt; +		wclk_reg = TAS2552_8KHZ;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case 11025:
&gt; &gt;&gt; +		wclk_reg = TAS2552_11_12KHZ;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case 16000:
&gt; &gt;&gt; +		wclk_reg = TAS2552_16KHZ;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case 32000:
&gt; &gt;&gt; +		wclk_reg = TAS2552_32KHZ;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case 22050:
&gt; &gt;&gt; +	case 24000:
&gt; &gt;&gt; +		wclk_reg = TAS2552_22_24KHZ;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case 44100:
&gt; &gt;&gt; +	case 48000:
&gt; &gt;&gt; +		wclk_reg = TAS2552_44_48KHZ;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case 96000:
&gt; &gt;&gt; +		wclk_reg = TAS2552_88_96KHZ;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	default:
&gt; &gt; might be worth adding a dev_vdbg() here.
&gt; 
&gt; I could, but trying to not add a lot of logging in the code.

dev_vdbg() is only built when CONFIG_VERBOSE_DEBUG is set. Otherwise
it's a no-op and optimized away.

&gt; &gt;&gt; +		return -EINVAL;
&gt; &gt;&gt; +	}
&gt; &gt;&gt; +
&gt; &gt;&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_3, TAS2552_WCLK_MASK, wclk_reg);
&gt; &gt;&gt; +
&gt; &gt;&gt; +	return 0;
&gt; &gt;&gt; +}
&gt; &gt;&gt; +
&gt; &gt;&gt; +static int tas2552_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
&gt; &gt;&gt; +{
&gt; &gt;&gt; +	u8 serial_format;
&gt; &gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; &gt;&gt; +
&gt; &gt;&gt; +	switch (fmt &amp; SND_SOC_DAIFMT_MASTER_MASK) {
&gt; &gt;&gt; +	case SND_SOC_DAIFMT_CBS_CFS:
&gt; &gt;&gt; +		serial_format = 0x00;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case SND_SOC_DAIFMT_CBS_CFM:
&gt; &gt;&gt; +		serial_format = TAS2552_WORD_CLK_MASK;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case SND_SOC_DAIFMT_CBM_CFS:
&gt; &gt;&gt; +		serial_format = TAS2552_BIT_CLK_MASK;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case SND_SOC_DAIFMT_CBM_CFM:
&gt; &gt;&gt; +		serial_format = (TAS2552_BIT_CLK_MASK | TAS2552_WORD_CLK_MASK);
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	default:
&gt; &gt;&gt; +		return -EINVAL;
&gt; &gt;&gt; +	}
&gt; &gt;&gt; +
&gt; &gt;&gt; +	snd_soc_update_bits(codec, TAS2552_SER_CTRL_1,
&gt; &gt;&gt; +			    (TAS2552_BIT_CLK_MASK | TAS2552_WORD_CLK_MASK),
&gt; &gt;&gt; +			    serial_format);
&gt; &gt;&gt; +
&gt; &gt;&gt; +	switch (fmt &amp; SND_SOC_DAIFMT_FORMAT_MASK) {
&gt; &gt;&gt; +	case SND_SOC_DAIFMT_I2S:
&gt; &gt;&gt; +		serial_format = 0x0;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case SND_SOC_DAIFMT_DSP_A:
&gt; &gt;&gt; +		serial_format = TAS2552_DAIFMT_DSP;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case SND_SOC_DAIFMT_RIGHT_J:
&gt; &gt;&gt; +		serial_format = TAS2552_DAIFMT_RIGHT_J;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +	case SND_SOC_DAIFMT_LEFT_J:
&gt; &gt;&gt; +		serial_format = TAS2552_DAIFMT_LEFT_J;
&gt; &gt;&gt; +		break;
&gt; &gt;&gt; +
&gt; &gt;&gt; +	default:
&gt; &gt;&gt; +		return -EINVAL;
&gt; &gt;&gt; +	}
&gt; &gt;&gt; +
&gt; &gt;&gt; +	snd_soc_update_bits(codec, TAS2552_SER_CTRL_1, TAS2552_DATA_FORMAT_MASK,
&gt; &gt;&gt; +						serial_format);
&gt; &gt;&gt; +
&gt; &gt;&gt; +	return 0;
&gt; &gt;&gt; +}
&gt; &gt;&gt; +
&gt; &gt;&gt; +static int tas2552_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
&gt; &gt;&gt; +				  unsigned int freq, int dir)
&gt; &gt;&gt; +{
&gt; &gt;&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; &gt;&gt; +	struct tas2552_data *data = dev_get_drvdata(dai-&gt;dev);
&gt; &gt;&gt; +
&gt; &gt;&gt; +	/* Fill in the PLL control registers for J &amp; D
&gt; &gt;&gt; +	 * PLL_CLK = (.5 * freq * J.D) / 2^p
&gt; &gt;&gt; +	 * Need to fill in J and D here based on incoming freq
&gt; &gt;&gt; +	 */
&gt; &gt;&gt; +
&gt; &gt;&gt; +	tas2552_sw_shutdown(data, 1);
&gt; &gt; if you move sw_shutdown to runtime_suspend/resume, you could implement
&gt; &gt; this as follows:
&gt; &gt;
&gt; &gt; 	ret = pm_runtime_get_sync(data-&gt;dev);
&gt; &gt; 	if (ret)
&gt; &gt; 		return ret;
&gt; 
&gt; See above comment about these APIs not being related to power management

shutdown is not related to PM ? interesting...

-- 
balbi
</pre><p><strong>Attachment:
<a href="pgp1OPrqucdhX.pgp" ><tt>signature.asc</tt></a></strong><br>
<em>Description:</em> Digital signature</p>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00485" href="msg00485.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Dan Murphy</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00479" href="msg00479.html">[PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Dan Murphy</li></ul></li>
<li><strong><a name="00481" href="msg00481.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Felipe Balbi</li></ul></li>
<li><strong><a name="00482" href="msg00482.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Dan Murphy</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00483.html">Re: [alsa-devel] [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00485.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00482.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00485.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00484"><strong>Date</strong></a></li>
<li><a href="index.html#00484"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/Pulseaudio/>[Pulseaudio]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/alsa-devel/>[ALSA&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=http://www.ske-art.com/z/biglist.html>[Big&nbsp;List&nbsp;of&nbsp;Linux&nbsp;Books]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td valign=top align=left>&nbsp;</td>
<td valign=top align=right>
<a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
