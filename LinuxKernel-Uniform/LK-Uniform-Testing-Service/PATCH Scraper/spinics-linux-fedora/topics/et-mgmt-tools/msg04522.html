<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH] Fossilize public virtinst.util API -->
<!--X-From-R13: wbua.yribaNfha.pbz -->
<!--X-Date: Wed, 10 Dec 2008 07:56:48 &#45;0800 -->
<!--X-Message-Id: 1f7482ff5250d388c7b2.1228924587@xenbld.SFBay.Sun.COM -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Fedora Management Tools, [PATCH] Fossilize public virtinst.util API">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<link rel="alternate" type="application/rss+xml" title="Fedora Management Tools" href="//feedproxy.google.com/Fedora/linuxManagementTools">
<title>Fedora Management Tools -- [PATCH] Fossilize public virtinst.util API</title>
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH] Fossilize public virtinst.util API</h1>
[<a href="msg04521.html">Date Prev</a>][<a href="msg04523.html">Date Next</a>][<a href="msg04521.html">Thread Prev</a>][<a href="msg04523.html">Thread Next</a>][<a href="maillist.html#04522">Date Index</a>][<a href="index.html#04522">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH] Fossilize public virtinst.util API</li>
<li><em>From</em>: <a href="mailto:john.levon@DOMAIN.HIDDEN">john.levon@xxxxxxx</a></li>
<li><em>Date</em>: Wed, 10 Dec 2008 07:56:27 -0800</li>
<li><em>Reply-to</em>: Fedora/Linux Management Tools &lt;<a href="mailto:et-mgmt-tools@DOMAIN.HIDDEN">et-mgmt-tools@xxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre># HG changeset patch
# User john.levon@xxxxxxx
# Date 1228924505 28800
# Node ID 1f7482ff5250d388c7b22376304002ce16a01301
# Parent  10a5001f9200d6377e8f016fd67c24c16742a9ad
Fossilize public virtinst.util API

Make virtinst.util API frozen, and move the utility functions into a
private namespace away from the prying eyes of API clients.

As a consequence, create a User class for checking privileges.

Signed-off-by: John Levon &lt;john.levon@xxxxxxx&gt;

diff --git a/virt-clone b/virt-clone
--- a/virt-clone
+++ b/virt-clone
@@ -29,6 +29,7 @@ import locale
 import locale
 import virtinst.cli as cli
 from virtinst.cli import fail
+from virtinst.User import User
 
 locale.setlocale(locale.LC_ALL, '')
 gettext.bindtextdomain(virtinst.gettext_app, virtinst.gettext_dir)
@@ -184,9 +185,8 @@ def main():
 
     logging.debug(&quot;start clone with HV &quot; + options.connect)
 
-    if options.connect is None or options.connect.lower()[0:3] == &quot;xen&quot;:
-        if not virtinst.util.privileged_user():
-            fail(_(&quot;Must be root to clone Xen guests&quot;))
+    if not User.current().has_priv(User.PRIV_CLONE, options.connect):
+        fail(_(&quot;Must be privileged to clone Xen guests&quot;))
 
     conn = cli.getConnection(options.connect)
     design = clmgr.CloneDesign(connection=conn)
diff --git a/virtinst/CloneManager.py b/virtinst/CloneManager.py
--- a/virtinst/CloneManager.py
+++ b/virtinst/CloneManager.py
@@ -23,7 +23,7 @@ import libxml2
 import libxml2
 import logging
 import urlgrabber.progress as progress
-import util
+import _util
 import libvirt
 import Guest
 from VirtualDisk import VirtualDisk
@@ -263,7 +263,7 @@ class CloneDesign(object):
             node[0].setContent(self._clone_uuid)
         else:
             while 1:
-                uuid = util.uuidToString(util.randomUUID())
+                uuid = _util.uuidToString(_util.randomUUID())
                 if self._check_uuid(uuid) == True:
                     continue
                 else:
@@ -278,7 +278,7 @@ class CloneDesign(object):
                 node[0].setContent(self._clone_mac[i-1])
             except Exception:
                 while 1:
-                    mac = util.randomMAC(typ)
+                    mac = _util.randomMAC(typ)
                     dummy, msg = self._check_mac(mac)
                     if msg is not None:
                         continue
@@ -396,7 +396,7 @@ class CloneDesign(object):
         for i in lst:
             mode = os.stat(i)[stat.ST_MODE]
             if stat.S_ISBLK(mode):
-                size.append(util.blkdev_size(i))
+                size.append(_util.blkdev_size(i))
                 typ.append(False)
             elif stat.S_ISREG(mode):
                 size.append(os.path.getsize(i))
@@ -450,7 +450,7 @@ class CloneDesign(object):
                 continue
             mode = os.stat(i)[stat.ST_MODE]
             if stat.S_ISBLK(mode):
-                size.append(util.blkdev_size(i))
+                size.append(_util.blkdev_size(i))
                 typ.append(False)
             elif stat.S_ISREG(mode):
                 size.append(os.path.getsize(i))
diff --git a/virtinst/DistroManager.py b/virtinst/DistroManager.py
--- a/virtinst/DistroManager.py
+++ b/virtinst/DistroManager.py
@@ -22,9 +22,10 @@
 
 import logging
 import os
-import util
+import _util
 import Guest
 from VirtualDisk import VirtualDisk
+from User import User
 from virtinst import _virtinst as _
 
 import virtinst
@@ -158,7 +159,7 @@ class DistroInstaller(Guest.Installer):
             logging.debug(&quot;DistroInstaller location is a (poolname, volname)&quot;
                           &quot; tuple&quot;)
         elif os.path.exists(os.path.abspath(val)) \
-             and (not self.conn or not util.is_uri_remote(self.conn.getURI())):
+             and (not self.conn or not _util.is_uri_remote(self.conn.getURI())):
             val = os.path.abspath(val)
             logging.debug(&quot;DistroInstaller location is a local &quot;
                           &quot;file/path: %s&quot; % val)
@@ -178,8 +179,8 @@ class DistroInstaller(Guest.Installer):
         elif (val.startswith(&quot;<a  rel="nofollow" href="http://&quot">http://&quot</a>;) or val.startswith(&quot;<a  rel="nofollow" href="ftp://&quot">ftp://&quot</a>;) or
               val.startswith(&quot;nfs:&quot;)):
             logging.debug(&quot;DistroInstaller location is a network source.&quot;)
-        elif self.conn and util.is_storage_capable(self.conn) and \
-             util.is_uri_remote(self.conn.getURI()):
+        elif self.conn and _util.is_storage_capable(self.conn) and \
+             _util.is_uri_remote(self.conn.getURI()):
             # If conn is specified, pass the path to a VirtualDisk object
             # and see what comes back
             try:
@@ -193,8 +194,9 @@ class DistroInstaller(Guest.Installer):
                                &quot;or FTP network install source, or an existing &quot;
                                &quot;local file/device&quot;))
 
-        if val.startswith(&quot;nfs:&quot;) and not util.privileged_user():
-            raise ValueError(_(&quot;NFS installations are only supported as root&quot;))
+        if (val.startswith(&quot;nfs:&quot;) and not
+            User.current().has_priv(User.PRIV_NFS_MOUNT, self.conn.getURI())):
+            raise ValueError(_('Privilege is required for NFS installations'))
 
         self._location = val
     location = property(get_location, set_location)
diff --git a/virtinst/FullVirtGuest.py b/virtinst/FullVirtGuest.py
--- a/virtinst/FullVirtGuest.py
+++ b/virtinst/FullVirtGuest.py
@@ -20,7 +20,7 @@
 # MA 02110-1301 USA.
 
 import os
-import util
+import _util
 import DistroManager
 import logging
 import time
@@ -38,7 +38,7 @@ class FullVirtGuest(Guest):
             installer = DistroManager.DistroInstaller(type = type, os_type = &quot;hvm&quot;)
         Guest.__init__(self, type, connection, hypervisorURI, installer)
         self.disknode = &quot;hd&quot;
-        self.features = { &quot;acpi&quot;: None, &quot;pae&quot;: util.is_pae_capable(), &quot;apic&quot;: None }
+        self.features = { &quot;acpi&quot;: None, &quot;pae&quot;: _util.is_pae_capable(), &quot;apic&quot;: None }
         if arch is None:
             arch = platform.machine()
         self.arch = arch
diff --git a/virtinst/Guest.py b/virtinst/Guest.py
--- a/virtinst/Guest.py
+++ b/virtinst/Guest.py
@@ -26,7 +26,7 @@ import re
 import re
 import libxml2
 import urlgrabber.progress as progress
-import util
+import _util
 import libvirt
 import platform
 import __builtin__
@@ -131,7 +131,7 @@ class VirtualNetworkInterface(VirtualDev
                 logging.warn(&quot;conflict_net: Failed to lookup domain %d&quot; % name)
 
         # get the Host's NIC MACaddress
-        hostdevs = util.get_host_network_devices()
+        hostdevs = _util.get_host_network_devices()
 
         if self.countMACaddr(vms) &gt; 0:
             return (True, _(&quot;The MAC address you entered is already in use by another active virtual machine.&quot;))
@@ -145,7 +145,7 @@ class VirtualNetworkInterface(VirtualDev
     def setup(self, conn):
         if self.macaddr is None:
             while 1:
-                self.macaddr = util.randomMAC(type=conn.getType().lower())
+                self.macaddr = _util.randomMAC(type=conn.getType().lower())
                 if self.is_conflict_net(conn)[1] is not None:
                     continue
                 else:
@@ -159,7 +159,7 @@ class VirtualNetworkInterface(VirtualDev
                     raise RuntimeError(msg)
 
         if not self.bridge and self.type == &quot;bridge&quot;:
-            self.bridge = util.default_bridge()
+            self.bridge = _util.default_bridge()
 
     def get_xml_config(self):
         src_xml = &quot;&quot;
@@ -192,7 +192,7 @@ class VirtualNetworkInterface(VirtualDev
             try:
                 for mac in ctx.xpathEval(&quot;/domain/devices/interface/mac&quot;):
                     macaddr = mac.xpathEval(&quot;attribute::address&quot;)[0].content
-                    if macaddr and util.compareMAC(self.macaddr, macaddr) == 0:
+                    if macaddr and _util.compareMAC(self.macaddr, macaddr) == 0:
                         count += 1
             finally:
                 if ctx is not None:
@@ -250,7 +250,7 @@ class VirtualGraphics(object):
         return self._keymap
     def set_keymap(self, val):
         if not val:
-            val = util.default_keymap()
+            val = _util.default_keymap()
         if not val or type(val) != type(&quot;string&quot;):
             raise ValueError, _(&quot;Keymap must be a string&quot;)
         if len(val) &gt; 16:
@@ -352,7 +352,7 @@ class Installer(object):
             return '/var/tmp'
         if self.type == &quot;xen&quot; and os.path.exists(XEN_SCRATCH):
             return XEN_SCRATCH
-        if util.privileged_user() and os.path.exists(LIBVIRT_SCRATCH):
+        if os.geteuid() == 0 and os.path.exists(LIBVIRT_SCRATCH):
             return LIBVIRT_SCRATCH
         else:
             return os.path.expanduser(&quot;~/.virtinst/boot&quot;)
@@ -407,7 +407,7 @@ class Installer(object):
                            conn=None, kernel=None, bootdev=None):
         osblob = &quot;&quot;
         if not isinstall and not ishvm:
-            return &quot;&lt;bootloader&gt;%s&lt;/bootloader&gt;&quot; % util.pygrub_path(conn)
+            return &quot;&lt;bootloader&gt;%s&lt;/bootloader&gt;&quot; % _util.pygrub_path(conn)
 
         osblob = &quot;&lt;os&gt;\n&quot;
 
@@ -425,9 +425,9 @@ class Installer(object):
             osblob += &quot;    &lt;loader&gt;%s&lt;/loader&gt;\n&quot; % loader
 
         if isinstall and kernel and kernel[&quot;kernel&quot;]:
-            osblob += &quot;    &lt;kernel&gt;%s&lt;/kernel&gt;\n&quot;   % util.xml_escape(kernel[&quot;kernel&quot;])
-            osblob += &quot;    &lt;initrd&gt;%s&lt;/initrd&gt;\n&quot;   % util.xml_escape(kernel[&quot;initrd&quot;])
-            osblob += &quot;    &lt;cmdline&gt;%s&lt;/cmdline&gt;\n&quot; % util.xml_escape(kernel[&quot;extraargs&quot;])
+            osblob += &quot;    &lt;kernel&gt;%s&lt;/kernel&gt;\n&quot;   % _util.xml_escape(kernel[&quot;kernel&quot;])
+            osblob += &quot;    &lt;initrd&gt;%s&lt;/initrd&gt;\n&quot;   % _util.xml_escape(kernel[&quot;initrd&quot;])
+            osblob += &quot;    &lt;cmdline&gt;%s&lt;/cmdline&gt;\n&quot; % _util.xml_escape(kernel[&quot;extraargs&quot;])
         elif bootdev is not None:
             osblob += &quot;    &lt;boot dev='%s'/&gt;\n&quot; % bootdev
 
@@ -466,7 +466,7 @@ class Installer(object):
         @type L{Guest}
         &quot;&quot;&quot;
 
-        if util.is_uri_remote(guest.conn.getURI()):
+        if _util.is_uri_remote(guest.conn.getURI()):
             # XXX: Use block peek for this?
             return True
 
@@ -479,7 +479,7 @@ class Installer(object):
             fd = os.open(guest.disks[0].path, os.O_RDONLY)
         except OSError, (err, msg):
             logging.debug(&quot;Failed to open guest disk: %s&quot; % msg)
-            if err == errno.EACCES and not util.privileged_user():
+            if err == errno.EACCES and os.geteuid() != 0:
                 return True # non root might not have access to block devices
             else:
                 raise
@@ -624,7 +624,7 @@ class Guest(object):
     def get_vcpus(self):
         return self._vcpus
     def set_vcpus(self, val):
-        maxvcpus = util.get_max_vcpus(self.conn, self.type)
+        maxvcpus = _util.get_max_vcpus(self.conn, self.type)
         if type(val) is not int or val &lt; 1:
             raise ValueError, _(&quot;Number of vcpus must be a postive integer.&quot;)
         if val &gt; maxvcpus:
@@ -642,7 +642,7 @@ class Guest(object):
         if re.match(&quot;^[0-9,-]*$&quot;, val) is None:
             raise ValueError, _(&quot;cpuset can only contain numeric, ',', or '-' characters&quot;)
 
-        pcpus = util.get_phy_cpus(self.conn)
+        pcpus = _util.get_phy_cpus(self.conn)
         for c in val.split(','):
             if c.find('-') != -1:
                 (x, y) = c.split('-')
@@ -1061,7 +1061,7 @@ class Guest(object):
     def _set_defaults(self):
         if self.uuid is None:
             while 1:
-                self.uuid = util.uuidToString(util.randomUUID())
+                self.uuid = _util.uuidToString(_util.randomUUID())
                 try:
                     if self.conn.lookupByUUIDString(self.uuid) is not None:
                         continue
diff --git a/virtinst/ImageManager.py b/virtinst/ImageManager.py
--- a/virtinst/ImageManager.py
+++ b/virtinst/ImageManager.py
@@ -23,7 +23,7 @@ import CapabilitiesParser as Cap
 import CapabilitiesParser as Cap
 from VirtualDisk import VirtualDisk
 import os
-import util
+import _util
 from virtinst import _virtinst as _
 
 class ImageInstallerException(Exception):
@@ -101,7 +101,7 @@ class ImageInstaller(Guest.Installer):
             d = VirtualDisk(p, s,
                             device = device,
                             type = VirtualDisk.TYPE_FILE)
-            if self.boot_caps.type == &quot;xen&quot; and util.is_blktap_capable():
+            if self.boot_caps.type == &quot;xen&quot; and _util.is_blktap_capable():
                 d.driver_name = VirtualDisk.DRIVER_TAP
             d.target = m.target
 
@@ -127,9 +127,9 @@ class ImageInstaller(Guest.Installer):
         if loader:
             osblob += &quot;    &lt;loader&gt;%s&lt;/loader&gt;\n&quot; % loader
         if self.boot_caps.kernel:
-            osblob += &quot;    &lt;kernel&gt;%s&lt;/kernel&gt;\n&quot;   % util.xml_escape(self._abspath(self.boot_caps.kernel))
-            osblob += &quot;    &lt;initrd&gt;%s&lt;/initrd&gt;\n&quot;   % util.xml_escape(self._abspath(self.boot_caps.initrd))
-            osblob += &quot;    &lt;cmdline&gt;%s&lt;/cmdline&gt;\n&quot; % util.xml_escape(self.boot_caps.cmdline)
+            osblob += &quot;    &lt;kernel&gt;%s&lt;/kernel&gt;\n&quot;   % _util.xml_escape(self._abspath(self.boot_caps.kernel))
+            osblob += &quot;    &lt;initrd&gt;%s&lt;/initrd&gt;\n&quot;   % _util.xml_escape(self._abspath(self.boot_caps.initrd))
+            osblob += &quot;    &lt;cmdline&gt;%s&lt;/cmdline&gt;\n&quot; % _util.xml_escape(self.boot_caps.cmdline)
             osblob += &quot;  &lt;/os&gt;&quot;
         elif hvm:
             if self.boot_caps.bootdev:
@@ -137,7 +137,7 @@ class ImageInstaller(Guest.Installer):
             osblob += &quot;  &lt;/os&gt;&quot;
         elif self.boot_caps.loader == &quot;pygrub&quot; or (self.boot_caps.loader is None and self.boot_caps.type == &quot;xen&quot;):
             osblob += &quot;  &lt;/os&gt;\n&quot;
-            osblob += &quot;  &lt;bootloader&gt;%s&lt;/bootloader&gt;&quot; % util.pygrub_path(conn)
+            osblob += &quot;  &lt;bootloader&gt;%s&lt;/bootloader&gt;&quot; % _util.pygrub_path(conn)
 
         return osblob
 
diff --git a/virtinst/Storage.py b/virtinst/Storage.py
--- a/virtinst/Storage.py
+++ b/virtinst/Storage.py
@@ -52,7 +52,7 @@ import logging
 import logging
 from xml.sax.saxutils import escape
 
-import util
+import _util
 from virtinst import _virtinst as _
 
 DEFAULT_DEV_TARGET = &quot;/dev&quot;
@@ -112,7 +112,7 @@ class StorageObject(object):
     def set_conn(self, val):
         if not isinstance(val, libvirt.virConnect):
             raise ValueError(_(&quot;'conn' must be a libvirt connection object.&quot;))
-        if not util.is_storage_capable(val):
+        if not _util.is_storage_capable(val):
             raise ValueError(_(&quot;Passed connection is not libvirt storage &quot;
                                &quot;capable&quot;))
         self._conn = val
@@ -278,7 +278,7 @@ class StoragePool(StorageObject):
         self._source_path = None
         if not uuid:
             self._uuid = None
-        self._random_uuid = util.uuidToString(util.randomUUID())
+        self._random_uuid = _util.uuidToString(_util.randomUUID())
 
     # Properties used by all pools
     def get_type(self):
@@ -705,7 +705,7 @@ class StorageVolume(StorageObject):
         pool_object = StorageVolume.lookup_pool_by_name(pool_object=pool_object,
                                                         pool_name=pool_name,
                                                         conn=conn)
-        return StoragePool.get_volume_for_pool(util.get_xml_path(pool_object.XMLDesc(0), &quot;/pool/@type&quot;))
+        return StoragePool.get_volume_for_pool(_util.get_xml_path(pool_object.XMLDesc(0), &quot;/pool/@type&quot;))
     get_volume_for_pool = staticmethod(get_volume_for_pool)
 
     def find_free_name(name, pool_object=None, pool_name=None, conn=None,
@@ -756,7 +756,7 @@ class StorageVolume(StorageObject):
         if pool_name is not None and pool_object is None:
             if conn is None:
                 raise ValueError(_(&quot;'conn' must be specified with 'pool_name'&quot;))
-            if not util.is_storage_capable(conn):
+            if not _util.is_storage_capable(conn):
                 raise ValueError(_(&quot;Connection does not support storage &quot;
                                    &quot;management.&quot;))
             try:
diff --git a/virtinst/User.py b/virtinst/User.py
new file mode 100644
--- /dev/null
+++ b/virtinst/User.py
@@ -0,0 +1,74 @@
+#
+# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free  Software Foundation; either version 2 of the License, or
+# (at your option)  any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+# MA 02110-1301 USA.
+
+import platform
+import os
+
+class User(object):
+    &quot;&quot;&quot;Defines a particular user account.&quot;&quot;&quot;
+
+    PRIV_CLONE = 1
+    PRIV_NFS_MOUNT = 2
+    PRIV_QEMU_SYSTEM = 3
+    PRIV_CREATE_DOMAIN = 4
+    PRIV_CREATE_NETWORK = 5
+
+    _privs = [ PRIV_CLONE, PRIV_NFS_MOUNT, PRIV_QEMU_SYSTEM,
+        PRIV_CREATE_DOMAIN, PRIV_CREATE_NETWORK ]
+
+    def __init__(self, euid):
+        self._euid = euid
+
+    def has_priv(self, priv, conn=None):
+        &quot;&quot;&quot;Return if the given user is privileged enough to perform the
+           given operation. This isn't entirely accurate currently,
+           especially on Solaris.&quot;&quot;&quot;
+
+        if priv not in self._privs:
+            raise ValueError('unknown privilege %s' % priv)
+
+        if priv == self.PRIV_QEMU_SYSTEM:
+            return self._euid == 0
+
+        if platform.system() != 'SunOS':
+            is_xen = not conn or conn.lower()[0:3] == 'xen'
+            if priv in [ self.PRIV_CLONE, self.PRIV_CREATE_DOMAIN ]:
+                if is_xen:
+                    return self._euid == 0
+                return True
+
+            return self._euid == 0
+
+        # Not easy to work out!
+        if self._euid != User.current()._euid:
+            return self._euid == 0
+
+        import ucred
+        cred = ucred.get(os.getpid())
+        if priv in [ self.PRIV_CLONE, self.PRIV_CREATE_DOMAIN, self.PRIV_CREATE_NETWORK ]:
+            return cred.has_priv('Effective', 'virt_manage')
+        if priv == self.PRIV_NFS_MOUNT:
+            return (cred.has_priv('Effective', 'sys_mount') and
+                cred.has_priv('Effective', 'net_privaddr'))
+
+    def current():
+        &quot;&quot;&quot;Return the current user.&quot;&quot;&quot;
+        return User(os.geteuid())
+
+    current = staticmethod(current)
diff --git a/virtinst/VirtualDevice.py b/virtinst/VirtualDevice.py
--- a/virtinst/VirtualDevice.py
+++ b/virtinst/VirtualDevice.py
@@ -22,7 +22,7 @@ import libvirt
 import libvirt
 
 import CapabilitiesParser
-import util
+import _util
 from virtinst import _virtinst as _
 
 class VirtualDevice(object):
@@ -45,7 +45,7 @@ class VirtualDevice(object):
 
         self.__remote = None
         if self.conn:
-            self.__remote = util.is_uri_remote(self.conn.getURI())
+            self.__remote = _util.is_uri_remote(self.conn.getURI())
 
         self._caps = None
         if self.conn:
diff --git a/virtinst/VirtualDisk.py b/virtinst/VirtualDisk.py
--- a/virtinst/VirtualDisk.py
+++ b/virtinst/VirtualDisk.py
@@ -24,7 +24,7 @@ import logging
 import logging
 import libvirt
 
-import util
+import _util
 import Storage
 from VirtualDevice import VirtualDevice
 from virtinst import _virtinst as _
@@ -302,7 +302,7 @@ class VirtualDisk(VirtualDevice):
                                &quot;('poolname', 'volname')&quot;))
         if not self.conn:
             raise ValueError(_(&quot;'volName' requires a passed connection.&quot;))
-        if not util.is_storage_capable(self.conn):
+        if not _util.is_storage_capable(self.conn):
             raise ValueError(_(&quot;Connection does not support storage lookup.&quot;))
         try:
             pool = self.conn.storagePoolLookupByName(name_tuple[0])
@@ -321,7 +321,7 @@ class VirtualDisk(VirtualDevice):
     def __check_if_path_managed(self):
         vol = None
         verr = None
-        pool = util.lookup_pool_by_path(self.conn,
+        pool = _util.lookup_pool_by_path(self.conn,
                                         os.path.dirname(self.path))
         if pool:
             try:
@@ -378,7 +378,7 @@ class VirtualDisk(VirtualDevice):
         # if no obj: if remote, error
         storage_capable = False
         if self.conn:
-            storage_capable = util.is_storage_capable(self.conn)
+            storage_capable = _util.is_storage_capable(self.conn)
         if not storage_capable and self._is_remote():
             raise ValueError, _(&quot;Connection doesn't support remote storage.&quot;)
 
@@ -528,7 +528,7 @@ class VirtualDisk(VirtualDevice):
         elif self.path:
             path = self.path
         if path:
-            path = util.xml_escape(path)
+            path = _util.xml_escape(path)
 
         ret = &quot;    &lt;disk type='%(type)s' device='%(device)s'&gt;\n&quot; % { &quot;type&quot;: self.type, &quot;device&quot;: self.device }
         if not(self.driver_name is None):
diff --git a/virtinst/__init__.py b/virtinst/__init__.py
--- a/virtinst/__init__.py
+++ b/virtinst/__init__.py
@@ -34,3 +34,4 @@ from LiveCDInstaller import LiveCDInstal
 from LiveCDInstaller import LiveCDInstaller
 from ImageManager import ImageInstaller
 from CloneManager import CloneDesign
+from User import User
diff --git a/virtinst/util.py b/virtinst/_util.py
copy from virtinst/util.py
copy to virtinst/_util.py
--- a/virtinst/_util.py
+++ b/virtinst/_util.py
@@ -1,5 +1,3 @@
-#
-# Utility functions used for guest installation
 #
 # Copyright 2006  Red Hat, Inc.
 # Jeremy Katz &lt;katzj@xxxxxxxxxx&gt;
@@ -18,246 +16,17 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 # MA 02110-1301 USA.
+#
 
-import platform
-import random
-import os.path
-import re
-import libxml2
-import logging
-from sys import stderr
+#
+# Internal utility functions. These do NOT form part of the API and must
+# not be used by clients.
+#
 
-import libvirt
-from virtinst import _virtinst as _
-from virtinst import CapabilitiesParser
+import os
 
+from virtinst import util
 
-KEYBOARD_DIR = &quot;/etc/sysconfig/keyboard&quot;
-XORG_CONF = &quot;/etc/X11/xorg.conf&quot;
-
-def default_route():
-    route_file = &quot;/proc/net/route&quot;
-    d = file(route_file)
-
-    defn = 0
-    for line in d.xreadlines():
-        info = line.split()
-        if (len(info) != 11): # 11 = typical num of fields in the file
-            print &gt;&gt; stderr, _(&quot;Invalid line length while parsing %s.&quot;) %(route_file)
-            print &gt;&gt; stderr, _(&quot;Defaulting bridge to xenbr%d&quot;) % (defn)
-            break
-        try:
-            route = int(info[1],16)
-            if route == 0:
-                return info[0]
-        except ValueError:
-            continue
-    return None
-
-# Legacy for compat only.
-def default_bridge():
-    rt = default_route()
-    if rt is None:
-        defn = None
-    else:
-        defn = int(rt[-1])
-
-    if defn is None:
-        return &quot;xenbr0&quot;
-    else:
-        return &quot;xenbr%d&quot;%(defn)
-
-def default_network(conn):
-    dev = default_route()
-
-    if dev is not None and not is_uri_remote(conn.getURI()):
-        # New style peth0 == phys dev, eth0 == bridge, eth0 == default route
-        if os.path.exists(&quot;/sys/class/net/%s/bridge&quot; % dev):
-            return [&quot;bridge&quot;, dev]
-
-        # Old style, peth0 == phys dev, eth0 == netloop, xenbr0 == bridge,
-        # vif0.0 == netloop enslaved, eth0 == default route
-        defn = int(dev[-1])
-        if os.path.exists(&quot;/sys/class/net/peth%d/brport&quot; % defn) and \
-           os.path.exists(&quot;/sys/class/net/xenbr%d/bridge&quot; % defn):
-            return [&quot;bridge&quot;, &quot;xenbr%d&quot; % defn]
-
-    return [&quot;network&quot;, &quot;default&quot;]
-
-def default_connection():
-    if os.path.exists(&quot;/var/lib/xend&quot;) and os.path.exists(&quot;/proc/xen&quot;):
-        return &quot;xen&quot;
-    elif os.path.exists(&quot;/usr/bin/qemu&quot;) or \
-         os.path.exists(&quot;/usr/bin/qemu-kvm&quot;) or \
-         os.path.exists(&quot;/usr/bin/kvm&quot;) or \
-         os.path.exists(&quot;/usr/bin/xenner&quot;):
-        if privileged_user():
-            return &quot;qemu:///system&quot;
-        else:
-            return &quot;qemu:///session&quot;
-    return None
-
-def get_cpu_flags():
-    f = open(&quot;/proc/cpuinfo&quot;)
-    lines = f.readlines()
-    f.close()
-    for line in lines:
-        if not line.startswith(&quot;flags&quot;):
-            continue
-        # get the actual flags
-        flags = line[:-1].split(&quot;:&quot;, 1)[1]
-        # and split them
-        flst = flags.split(&quot; &quot;)
-        return flst
-    return []
-
-def is_pae_capable():
-    &quot;&quot;&quot;Determine if a machine is PAE capable or not.&quot;&quot;&quot;
-    flags = get_cpu_flags()
-    if &quot;pae&quot; in flags:
-        return True
-    return False
-
-def is_hvm_capable():
-    &quot;&quot;&quot;Determine if a machine is HVM capable or not.&quot;&quot;&quot;
-
-    caps = &quot;&quot;
-    if os.path.exists(&quot;/sys/hypervisor/properties/capabilities&quot;):
-        caps = open(&quot;/sys/hypervisor/properties/capabilities&quot;).read()
-    if caps.find(&quot;hvm&quot;) != -1:
-        return True
-    return False
-
-def is_kqemu_capable():
-    return os.path.exists(&quot;/dev/kqemu&quot;)
-
-def is_kvm_capable():
-    return os.path.exists(&quot;/dev/kvm&quot;)
-
-def is_blktap_capable():
-    #return os.path.exists(&quot;/dev/xen/blktapctrl&quot;)
-    f = open(&quot;/proc/modules&quot;)
-    lines = f.readlines()
-    f.close()
-    for line in lines:
-        if line.startswith(&quot;blktap &quot;) or line.startswith(&quot;xenblktap &quot;):
-            return True
-    return False
-
-def get_default_arch():
-    arch = os.uname()[4]
-    if arch == &quot;x86_64&quot;:
-        return &quot;x86_64&quot;
-    return &quot;i686&quot;
-
-# this function is directly from xend/server/netif.py and is thus
-# available under the LGPL,
-# Copyright 2004, 2005 Mike Wray &lt;mike.wray@xxxxxx&gt;
-# Copyright 2005 XenSource Ltd
-def randomMAC(type = &quot;xen&quot;):
-    &quot;&quot;&quot;Generate a random MAC address.
-
-    00-16-3E allocated to xensource
-    54-52-00 used by qemu/kvm
-
-    The OUI list is available at <a  rel="nofollow" href="http://standards.ieee.org/regauth/oui/oui.txt">http://standards.ieee.org/regauth/oui/oui.txt</a>.
-
-    The remaining 3 fields are random, with the first bit of the first
-    random field set 0.
-
-    &gt;&gt;&gt; randomMAC().startswith(&quot;00:16:36&quot;)
-    True
-    &gt;&gt;&gt; randomMAC(&quot;foobar&quot;).startswith(&quot;00:16:36&quot;)
-    True
-    &gt;&gt;&gt; randomMAC(&quot;xen&quot;).startswith(&quot;00:16:36&quot;)
-    True
-    &gt;&gt;&gt; randomMAC(&quot;qemu&quot;).startswith(&quot;54:52:00&quot;)
-    True
-
-    @return: MAC address string
-    &quot;&quot;&quot;
-    ouis = { 'xen': [ 0x00, 0x16, 0x36 ], 'qemu': [ 0x54, 0x52, 0x00 ] }
-
-    try:
-        oui = ouis[type]
-    except KeyError:
-        oui = ouis['xen']
-
-    mac = oui + [
-            random.randint(0x00, 0x7f),
-            random.randint(0x00, 0xff),
-            random.randint(0x00, 0xff) ]
-    return ':'.join(map(lambda x: &quot;%02x&quot; % x, mac))
-
-# the following three functions are from xend/uuid.py and are thus
-# available under the LGPL,
-# Copyright 2005 Mike Wray &lt;mike.wray@xxxxxx&gt;
-# Copyright 2005 XenSource Ltd
-def randomUUID():
-    &quot;&quot;&quot;Generate a random UUID.&quot;&quot;&quot;
-
-    return [ random.randint(0, 255) for dummy in range(0, 16) ]
-
-def uuidToString(u):
-    return &quot;-&quot;.join([&quot;%02x&quot; * 4, &quot;%02x&quot; * 2, &quot;%02x&quot; * 2, &quot;%02x&quot; * 2,
-                     &quot;%02x&quot; * 6]) % tuple(u)
-
-def uuidFromString(s):
-    s = s.replace('-', '')
-    return [ int(s[i : i + 2], 16) for i in range(0, 32, 2) ]
-
-# the following function quotes from python2.5/uuid.py
-def get_host_network_devices():
-    device = []
-    for dirname in ['', '/sbin/', '/usr/sbin']:
-        executable = os.path.join(dirname, &quot;ifconfig&quot;)
-        if not os.path.exists(executable):
-            continue
-        try:
-            cmd = 'LC_ALL=C %s -a 2&gt;/dev/null' % (executable)
-            pipe = os.popen(cmd)
-        except IOError:
-            continue
-        for line in pipe:
-            if line.find(&quot;encap:Ethernet&quot;) &gt; 0:
-                words = line.lower().split()
-                for i in range(len(words)):
-                    if words[i] == &quot;hwaddr&quot;:
-                        device.append(words)
-    return device
-
-def get_max_vcpus(conn, type=None):
-    &quot;&quot;&quot;@conn libvirt connection to poll for max possible vcpus
-       @type optional guest type (kvm, etc.)&quot;&quot;&quot;
-    if type is None:
-        type = conn.getType()
-    try:
-        m = conn.getMaxVcpus(type.lower())
-    except libvirt.libvirtError:
-        m = 32
-    return m
-
-def get_phy_cpus(conn):
-    &quot;&quot;&quot;Get number of physical CPUs.&quot;&quot;&quot;
-    hostinfo = conn.getInfo()
-    pcpus = hostinfo[4] * hostinfo[5] * hostinfo[6] * hostinfo[7]
-    return pcpus
-
-def system(cmd):
-    st = os.system(cmd)
-    if os.WIFEXITED(st) and os.WEXITSTATUS(st) != 0:
-        raise OSError(&quot;Failed to run %s, exited with %d&quot; % 
-                      (cmd, os.WEXITSTATUS(st)))
-
-def xml_escape(str):
-    &quot;&quot;&quot;Replaces chars ' &quot; &lt; &gt; &amp; with xml safe counterparts&quot;&quot;&quot;
-    str = str.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
-    str = str.replace(&quot;'&quot;, &quot;&amp;apos;&quot;)
-    str = str.replace(&quot;\&quot;&quot;, &quot;&amp;quot;&quot;)
-    str = str.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
-    str = str.replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
-    return str
- 
 def blkdev_size(path):
     &quot;&quot;&quot;Return the size of the block device.  We can't use os.stat() as
     that returns zero on many platforms.&quot;&quot;&quot;
@@ -267,255 +36,33 @@ def blkdev_size(path):
     os.close(fd)
     return size
 
-def compareMAC(p, q):
-    &quot;&quot;&quot;Compare two MAC addresses&quot;&quot;&quot;
-    pa = p.split(&quot;:&quot;)
-    qa = q.split(&quot;:&quot;)
-
-    if len(pa) != len(qa):
-        if p &gt; q:
-            return 1
-        else:
-            return -1
-
-    for i in xrange(len(pa)):
-        n = int(pa[i], 0x10) - int(qa[i], 0x10)
-        if n &gt; 0:
-            return 1
-        elif n &lt; 0:
-            return -1
-    return 0
-
-def _xorg_keymap():
-    &quot;&quot;&quot;Look in /etc/X11/xorg.conf for the host machine's keymap, and attempt to
-       map it to a keymap supported by qemu&quot;&quot;&quot;
-
-    kt = None
-    try:
-        f = open(XORG_CONF, &quot;r&quot;)
-    except IOError, e:
-        logging.debug('Could not open &quot;%s&quot;: %s ' % (XORG_CONF, str(e)))
-    else:
-        keymap_re = re.compile(r'\s*Option\s+&quot;XkbLayout&quot;\s+&quot;(?P&lt;kt&gt;[a-z-]+)&quot;')
-        for line in f:
-            m = keymap_re.match(line)
-            if m:
-                kt = m.group('kt')
-                break
-        else:
-            logging.debug(&quot;Didn't find keymap in '%s'!&quot; % XORG_CONF)
-        f.close()
-    return kt
-
-def default_keymap():
-    &quot;&quot;&quot;Look in /etc/sysconfig for the host machine's keymap, and attempt to
-       map it to a keymap supported by qemu&quot;&quot;&quot;
-
-    # Set keymap to same as hosts
-    import keytable
-    keymap = &quot;en-us&quot;
-    kt = None
-    try:
-        f = open(KEYBOARD_DIR, &quot;r&quot;)
-    except IOError, e:
-        logging.debug('Could not open &quot;/etc/sysconfig/keyboard&quot; ' + str(e))
-        kt = _xorg_keymap()
-    else:
-        while 1:
-            s = f.readline()
-            if s == &quot;&quot;:
-                break
-            if re.search(&quot;KEYTABLE&quot;, s) != None or \
-               (re.search(&quot;KEYBOARD&quot;, s) != None and
-                re.search(&quot;KEYBOARDTYPE&quot;, s) == None):
-                if s.count('&quot;'):
-                    delim = '&quot;'
-                elif s.count('='):
-                    delim = '='
-                else:
-                    continue
-                kt = s.split(delim)[1].strip()
-        f.close()
-
-    if kt and keytable.keytable.has_key(kt.lower()):
-        keymap = keytable.keytable[kt]
-    else:
-        logging.debug(&quot;Didn't find keymap '%s' in keytable!&quot; % kt)
-    return keymap
-
-def pygrub_path(conn=None):
-    &quot;&quot;&quot;
-    Return the pygrub path for the current host, or connection if
-    available.
-    &quot;&quot;&quot;
-    # FIXME: This should be removed/deprecated when capabilities are
-    #        fixed to provide bootloader info
-    if conn:
-        cap = CapabilitiesParser.parse(conn.getCapabilities())
-        if (cap.host.arch == &quot;i86pc&quot;):
-            return &quot;/usr/lib/xen/bin/pygrub&quot;
-        else:
-            return &quot;/usr/bin/pygrub&quot;
-
-    if platform.system() == &quot;SunOS&quot;:
-        return &quot;/usr/lib/xen/bin/pygrub&quot;
-    return &quot;/usr/bin/pygrub&quot;
-
-def uri_split(uri):
-    &quot;&quot;&quot;
-    Parse a libvirt hypervisor uri into it's individual parts
-    @returns: tuple of the form (scheme (ex. 'qemu', 'xen+ssh'), username,
-                                 hostname, path (ex. '/system'), query,
-                                 fragment)
-    &quot;&quot;&quot;
-    def splitnetloc(url, start=0):
-        for c in '/?#': # the order is important!
-            delim = url.find(c, start)
-            if delim &gt;= 0:
-                break
-        else:
-            delim = len(url)
-        return url[start:delim], url[delim:]
-
-    username = netloc = query = fragment = ''
-    i = uri.find(&quot;:&quot;)
-    if i &gt; 0:
-        scheme, uri = uri[:i].lower(), uri[i+1:]
-        if uri[:2] == '//':
-            netloc, uri = splitnetloc(uri, 2)
-            offset = netloc.find(&quot;@&quot;)
-            if offset &gt; 0:
-                username = netloc[0:offset]
-                netloc = netloc[offset+1:]
-        if '#' in uri:
-            uri, fragment = uri.split('#', 1)
-        if '?' in uri:
-            uri, query = uri.split('?', 1)
-    else:
-        scheme = uri.lower()
-    return scheme, username, netloc, uri, query, fragment
-
-
-def is_uri_remote(uri):
-    try:
-        split_uri = uri_split(uri)
-        netloc = split_uri[2]
-
-        if netloc == &quot;&quot;:
-            return False
-        return True
-    except Exception, e:
-        logging.exception(&quot;Error parsing URI in is_remote: %s&quot; % e)
-        return True
-
-def get_uri_hostname(uri):
-    try:
-        split_uri = uri_split(uri)
-        netloc = split_uri[2]
-
-        if netloc != &quot;&quot;:
-            return netloc
-    except Exception, e:
-        logging.warning(&quot;Cannot parse URI %s: %s&quot; % (uri, str(e)))
-    return &quot;localhost&quot;
-
-def get_uri_transport(uri):
-    try:
-        split_uri = uri_split(uri)
-        scheme = split_uri[0]
-        username = split_uri[1]
-
-        if scheme:
-            offset = scheme.index(&quot;+&quot;)
-            if offset &gt; 0:
-                return [scheme[offset+1:], username]
-    except:
-        pass
-    return [None, None]
-
-def get_uri_driver(uri):
-    try:
-        split_uri = uri_split(uri)
-        scheme = split_uri[0]
-
-        if scheme:
-            offset = scheme.find(&quot;+&quot;)
-            if offset &gt; 0:
-                return scheme[:offset]
-            return scheme
-    except Exception:
-        pass
-    return &quot;xen&quot;
-
-def is_storage_capable(conn):
-    &quot;&quot;&quot;check if virConnectPtr passed has storage API support&quot;&quot;&quot;
-    if not conn:
-        return False
-    if not isinstance(conn, libvirt.virConnect):
-        raise ValueError(_(&quot;'conn' must be a virConnect instance.&quot;))
-    try:
-        if not dir(conn).count(&quot;listStoragePools&quot;):
-            return False
-        conn.listStoragePools()
-    except libvirt.libvirtError, e:
-        if e.get_error_code() == libvirt.VIR_ERR_RPC or \
-           e.get_error_code() == libvirt.VIR_ERR_NO_SUPPORT:
-            return False
-    return True
-
-def get_xml_path(xml, path):
-    &quot;&quot;&quot;return the xpath from the passed xml&quot;&quot;&quot;
-    doc = None
-    ctx = None
-    result = None
-    try:
-        doc = libxml2.parseDoc(xml)
-        ctx = doc.xpathNewContext()
-        ret = ctx.xpathEval(path)
-        val = None
-        if ret != None:
-            if type(ret) == list:
-                if len(ret) == 1:
-                    val = ret[0].content
-            else:
-                val = ret
-        result = val
-    finally:
-        if doc:
-            doc.freeDoc()
-        if ctx:
-            ctx.xpathFreeContext()
-    return result
-
-def lookup_pool_by_path(conn, path):
-    &quot;&quot;&quot;
-    Return the first pool with matching matching target path.
-    return the first we find, active or inactive. This iterates over
-    all pools and dumps their xml, so it is NOT quick.
-    @return virStoragePool object if found, None otherwise
-    &quot;&quot;&quot;
-    if not is_storage_capable(conn):
-        return None
-
-    pool_list = conn.listStoragePools() + conn.listDefinedStoragePools()
-    for name in pool_list:
-        pool = conn.storagePoolLookupByName(name)
-        xml_path = get_xml_path(pool.XMLDesc(0), &quot;/pool/target/path&quot;)
-        if os.path.abspath(xml_path) == path:
-            return pool
-    return None
-
-def privileged_user():
-    &quot;&quot;&quot;
-    Return true if the user is privileged enough.  On Linux, this
-    equates to being root.  On Solaris, it's more complicated, so we
-    just assume we're OK.
-    &quot;&quot;&quot;
-    return os.uname()[0] == 'SunOS' or os.geteuid() == 0
-
-def _test():
-    import doctest
-    doctest.testmod()
- 
-if __name__ == &quot;__main__&quot;:
-    _test()
+#
+# These functions accidentally ended up in the API under virtinst.util
+#
+default_route = util.default_route
+default_bridge = util.default_bridge
+default_network = util.default_network
+default_connection = util.default_connection
+get_cpu_flags = util.get_cpu_flags
+is_pae_capable = util.is_pae_capable
+is_blktap_capable = util.is_blktap_capable
+get_default_arch = util.get_default_arch
+randomMAC = util.randomMAC
+randomUUID = util.randomUUID
+uuidToString = util.uuidToString
+uuidFromString = util.uuidFromString
+get_host_network_devices = util.get_host_network_devices
+get_max_vcpus = util.get_max_vcpus
+get_phy_cpus = util.get_phy_cpus
+xml_escape = util.xml_escape
+compareMAC = util.compareMAC
+default_keymap = util.default_keymap
+pygrub_path = util.pygrub_path
+uri_split = util.uri_split
+is_uri_remote = util.is_uri_remote
+get_uri_hostname = util.get_uri_hostname
+get_uri_transport = util.get_uri_transport
+get_uri_driver = util.get_uri_driver
+is_storage_capable = util.is_storage_capable
+get_xml_path = util.get_xml_path
+lookup_pool_by_path = util.lookup_pool_by_path
diff --git a/virtinst/cli.py b/virtinst/cli.py
--- a/virtinst/cli.py
+++ b/virtinst/cli.py
@@ -26,9 +26,9 @@ from optparse import OptionValueError, O
 from optparse import OptionValueError, OptionParser
 
 import libvirt
-import util
+import _util
 from virtinst import CapabilitiesParser, VirtualNetworkInterface, \
-                     VirtualGraphics, VirtualAudio
+                     VirtualGraphics, VirtualAudio, User
 from virtinst import _virtinst as _
 
 MIN_RAM = 64
@@ -117,9 +117,8 @@ def nice_exit():
     sys.exit(0)
 
 def getConnection(connect):
-    if connect and connect.lower()[0:3] == &quot;xen&quot;:
-        if not util.privileged_user():
-            fail(_(&quot;Must be root to create Xen guests&quot;))
+    if not User.current().has_priv(User.PRIV_CREATE_DOMAIN, connect):
+        fail(_(&quot;Must be root to create Xen guests&quot;))
     if connect is None:
         fail(_(&quot;Could not find usable default libvirt connection.&quot;))
 
@@ -298,8 +297,8 @@ def digest_networks(conn, macs, bridges,
     # With just one mac, create a default network if one is not
     # specified.
     if len(macs) == 1 and len(networks) == 0:
-        if util.privileged_user():
-            net = util.default_network(conn)
+        if User.current().has_priv(User.PRIV_CREATE_NETWORK, conn.getURI()):
+            net = _util.default_network(conn)
             networks.append(net[0] + &quot;:&quot; + net[1])
         else:
             networks.append(&quot;user&quot;)
@@ -316,8 +315,8 @@ def digest_networks(conn, macs, bridges,
     # Create extra networks up to the number of nics requested 
     if len(macs) &lt; nics:
         for dummy in range(len(macs),nics):
-            if util.privileged_user():
-                net = util.default_network(conn)
+            if User.current().has_priv(User.PRIV_CREATE_NETWORK, conn.getURI()):
+                net = _util.default_network(conn)
                 networks.append(net[0] + &quot;:&quot; + net[1])
             else:
                 networks.append(&quot;user&quot;)
diff --git a/virtinst/util.py b/virtinst/util.py
--- a/virtinst/util.py
+++ b/virtinst/util.py
@@ -18,6 +18,14 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 # MA 02110-1301 USA.
+
+#
+# WARNING: the contents of this file, somewhat unfortunately, are legacy
+# API. No incompatible changes are allowed to this file, and no new
+# code should be added here (utility functions live in _util.py).
+# Clients of virtinst shouldn't use these functions: if you think you
+# need to, tell us why.
+#
 
 import platform
 import random
@@ -30,6 +38,7 @@ import libvirt
 import libvirt
 from virtinst import _virtinst as _
 from virtinst import CapabilitiesParser
+from virtinst import User
 
 
 KEYBOARD_DIR = &quot;/etc/sysconfig/keyboard&quot;
@@ -54,7 +63,6 @@ def default_route():
             continue
     return None
 
-# Legacy for compat only.
 def default_bridge():
     rt = default_route()
     if rt is None:
@@ -91,7 +99,7 @@ def default_connection():
          os.path.exists(&quot;/usr/bin/qemu-kvm&quot;) or \
          os.path.exists(&quot;/usr/bin/kvm&quot;) or \
          os.path.exists(&quot;/usr/bin/xenner&quot;):
-        if privileged_user():
+        if User.current().has_priv(User.PRIV_QEMU_SYSTEM):
             return &quot;qemu:///system&quot;
         else:
             return &quot;qemu:///session&quot;
@@ -258,15 +266,6 @@ def xml_escape(str):
     str = str.replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
     return str
  
-def blkdev_size(path):
-    &quot;&quot;&quot;Return the size of the block device.  We can't use os.stat() as
-    that returns zero on many platforms.&quot;&quot;&quot;
-    fd = os.open(path, os.O_RDONLY)
-    # os.SEEK_END is not present on all systems
-    size = os.lseek(fd, 0, 2)
-    os.close(fd)
-    return size
-
 def compareMAC(p, q):
     &quot;&quot;&quot;Compare two MAC addresses&quot;&quot;&quot;
     pa = p.split(&quot;:&quot;)
@@ -505,14 +504,6 @@ def lookup_pool_by_path(conn, path):
             return pool
     return None
 
-def privileged_user():
-    &quot;&quot;&quot;
-    Return true if the user is privileged enough.  On Linux, this
-    equates to being root.  On Solaris, it's more complicated, so we
-    just assume we're OK.
-    &quot;&quot;&quot;
-    return os.uname()[0] == 'SunOS' or os.geteuid() == 0
-
 def _test():
     import doctest
     doctest.testmod()

_______________________________________________
et-mgmt-tools mailing list
et-mgmt-tools@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/et-mgmt-tools">https://www.redhat.com/mailman/listinfo/et-mgmt-tools</a>
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="04523" href="msg04523.html">Re:  [PATCH] Fossilize public virtinst.util API</a></strong>
<ul><li><em>From:</em> Cole Robinson</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg04521.html">[PATCH] Fossilize public virtinst.util API</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg04523.html">Re:  [PATCH] Fossilize public virtinst.util API</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg04521.html">[PATCH] Fossilize public virtinst.util API</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg04523.html">Re:  [PATCH] Fossilize public virtinst.util API</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#04522"><strong>Date</strong></a></li>
<li><a href="index.html#04522"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-users/>[Fedora&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fll/>[Fedora&nbsp;Legacy&nbsp;List]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-maintainers/>[Fedora&nbsp;Maintainers]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=http://www.ske-art.com/z/biglist.html>[Big&nbsp;List&nbsp;of&nbsp;Linux&nbsp;Books]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
