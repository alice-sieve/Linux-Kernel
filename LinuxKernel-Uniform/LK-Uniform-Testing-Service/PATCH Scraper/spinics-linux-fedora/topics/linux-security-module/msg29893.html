<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [RFC PATCH] security,capability: pass object information to security_capable -->
<!--X-From-R13: Qnfrl Epunhsyre &#60;pnfrlNfpunhsyre&#45;pn.pbz> -->
<!--X-Date: Fri, 12 Jul 2019 10:59:07 &#45;0700 -->
<!--X-Message-Id: 680c35a8&#45;1ee5&#45;725d&#45;b33c&#45;7bdced39763c@schaufler&#45;ca.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190712173404.14417&#45;1&#45;nhfran2@tycho.nsa.gov -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Security Module, Re: [RFC PATCH] security,capability: pass object information to security_capable">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Security Module -- Re: [RFC PATCH] security,capability: pass object information to security_capable</title>
<link rel="alternate" type="application/rss+xml" title="Linux Security Module" href="//feeds.feedburner.com/LinuxSecurityModule">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [RFC PATCH] security,capability: pass object information to security_capable</h1>
[<a href="msg29892.html">Date Prev</a>][<a href="msg29894.html">Date Next</a>][<a href="msg29914.html">Thread Prev</a>][<a href="msg29895.html">Thread Next</a>][<a href="maillist.html#29893">Date Index</a>][<a href="index.html#29893">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [RFC PATCH] security,capability: pass object information to security_capable</li>
<li><em>From</em>: Casey Schaufler &lt;casey@xxxxxxxxxxxxxxxx&gt;</li>
<li><em>Date</em>: Fri, 12 Jul 2019 10:58:56 -0700</li>
<li><em>Cc</em>: selinux@xxxxxxxxxxxxxxx, linux-security-module@xxxxxxxxxxxxxxx,        luto@xxxxxxxxxxxxxx, jmorris@xxxxxxxxx, sds@xxxxxxxxxxxxx,        keescook@xxxxxxxxxxxx, serge@xxxxxxxxxx, john.johansen@xxxxxxxxxxxxx,        mortonm@xxxxxxxxxxxx, casey@xxxxxxxxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg29891.html">20190712173404.14417-1-nhfran2@tycho.nsa.gov</a>&gt;</li>
<li><em>Openpgp</em>: preference=signencrypt</li>
<li><em>References</em>: &lt;<a href="msg29891.html">20190712173404.14417-1-nhfran2@tycho.nsa.gov</a>&gt;</li>
<li><em>User-agent</em>: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:60.0) Gecko/20100101 Thunderbird/60.8.0</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On 7/12/2019 10:34 AM, Nicholas Franck wrote:
&gt; At present security_capable does not pass any object information
&gt; and therefore can neither audit the particular object nor take it
&gt; into account. Augment the security_capable interface to support
&gt; passing supplementary data. Use this facility initially to convey
&gt; the inode for capability checks relevant to inodes. This only
&gt; addresses capable_wrt_inode_uidgid calls; other capability checks
&gt; relevant to inodes will be addressed in subsequent changes. In the
&gt; future, this will be further extended to pass object information for
&gt; other capability checks such as the target task for CAP_KILL.

This seems wrong to me. The capability system has nothing to do
with objects. Passing object information through security_capable()
may be convenient, but isn't relevant to the purpose of the interface.
It appears that there are very few places where the object information
is actually useful.

&gt; In SELinux this new information is leveraged here to include the inode
&gt; in the audit message. In the future, it could also be used to perform
&gt; a per inode capability checks.

I suggest that you want a mechanism for adding the inode information
to the audit record instead.

What would a &quot;per inode&quot; capability check be? Capability checks are
process checks, not object checks.

&gt; It would be possible to fold the existing opts argument into this new
&gt; supplementary data structure. This was omitted from this change to
&gt; minimize changes.
&gt;
&gt; Signed-off-by: Nicholas Franck &lt;nhfran2@xxxxxxxxxxxxx&gt;
&gt; ---
&gt;  include/linux/capability.h             |  7 ++++++
&gt;  include/linux/lsm_audit.h              |  5 +++-
&gt;  include/linux/lsm_hooks.h              |  3 ++-
&gt;  include/linux/security.h               | 23 +++++++++++++-----
&gt;  kernel/capability.c                    | 33 ++++++++++++++++++--------
&gt;  kernel/seccomp.c                       |  2 +-
&gt;  security/apparmor/capability.c         |  8 ++++---
&gt;  security/apparmor/include/capability.h |  4 +++-
&gt;  security/apparmor/ipc.c                |  2 +-
&gt;  security/apparmor/lsm.c                |  5 ++--
&gt;  security/apparmor/resource.c           |  2 +-
&gt;  security/commoncap.c                   | 11 +++++----
&gt;  security/lsm_audit.c                   | 21 ++++++++++++++--
&gt;  security/safesetid/lsm.c               |  3 ++-
&gt;  security/security.c                    |  5 ++--
&gt;  security/selinux/hooks.c               | 20 +++++++++-------
&gt;  security/smack/smack_access.c          |  2 +-
&gt;  17 files changed, 110 insertions(+), 46 deletions(-)
&gt;
&gt; diff --git a/include/linux/capability.h b/include/linux/capability.h
&gt; index ecce0f43c73a..f72de64c179d 100644
&gt; --- a/include/linux/capability.h
&gt; +++ b/include/linux/capability.h
&gt; @@ -211,6 +211,8 @@ extern bool capable(int cap);
&gt;  extern bool ns_capable(struct user_namespace *ns, int cap);
&gt;  extern bool ns_capable_noaudit(struct user_namespace *ns, int cap);
&gt;  extern bool ns_capable_setid(struct user_namespace *ns, int cap);
&gt; +extern bool ns_capable_inode(struct user_namespace *ns, int cap,
&gt; +			     const struct inode *inode);
&gt;  #else
&gt;  static inline bool has_capability(struct task_struct *t, int cap)
&gt;  {
&gt; @@ -246,6 +248,11 @@ static inline bool ns_capable_setid(struct user_namespace *ns, int cap)
&gt;  {
&gt;  	return true;
&gt;  }
&gt; +static bool ns_capable_inode(struct user_namespace *ns, int cap,
&gt; +			     const struct inode *inode)
&gt; +{
&gt; +	return true;
&gt; +}
&gt;  #endif /* CONFIG_MULTIUSER */
&gt;  extern bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode);
&gt;  extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);
&gt; diff --git a/include/linux/lsm_audit.h b/include/linux/lsm_audit.h
&gt; index 915330abf6e5..15d2a62639f0 100644
&gt; --- a/include/linux/lsm_audit.h
&gt; +++ b/include/linux/lsm_audit.h
&gt; @@ -79,7 +79,10 @@ struct common_audit_data {
&gt;  		struct dentry *dentry;
&gt;  		struct inode *inode;
&gt;  		struct lsm_network_audit *net;
&gt; -		int cap;
&gt; +		struct  {
&gt; +			int cap;

&gt; +			struct cap_aux_data *cad;
&gt; +		} cap_struct;
&gt;  		int ipc_id;
&gt;  		struct task_struct *tsk;
&gt;  #ifdef CONFIG_KEYS
&gt; diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
&gt; index 47f58cfb6a19..b2a37d613030 100644
&gt; --- a/include/linux/lsm_hooks.h
&gt; +++ b/include/linux/lsm_hooks.h
&gt; @@ -1469,7 +1469,8 @@ union security_list_options {
&gt;  	int (*capable)(const struct cred *cred,
&gt;  			struct user_namespace *ns,
&gt;  			int cap,
&gt; -			unsigned int opts);
&gt; +			unsigned int opts,
&gt; +			struct cap_aux_data *cad);
&gt;  	int (*quotactl)(int cmds, int type, int id, struct super_block *sb);
&gt;  	int (*quota_on)(struct dentry *dentry);
&gt;  	int (*syslog)(int type);
&gt; diff --git a/include/linux/security.h b/include/linux/security.h
&gt; index 659071c2e57c..8fce5e69dc52 100644
&gt; --- a/include/linux/security.h
&gt; +++ b/include/linux/security.h
&gt; @@ -77,9 +77,18 @@ enum lsm_event {
&gt;  	LSM_POLICY_CHANGE,
&gt;  };
&gt;  
&gt; +
&gt; +struct cap_aux_data {
&gt; +	char type;
&gt; +#define CAP_AUX_DATA_INODE	1
&gt; +	union	{
&gt; +		const struct inode *inode;
&gt; +	} u;
&gt; +};
&gt; +
&gt;  /* These functions are in security/commoncap.c */
&gt;  extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
&gt; -		       int cap, unsigned int opts);
&gt; +		       int cap, unsigned int opts, struct cap_aux_data *cad);
&gt;  extern int cap_settime(const struct timespec64 *ts, const struct timezone *tz);
&gt;  extern int cap_ptrace_access_check(struct task_struct *child, unsigned int mode);
&gt;  extern int cap_ptrace_traceme(struct task_struct *parent);
&gt; @@ -215,9 +224,10 @@ int security_capset(struct cred *new, const struct cred *old,
&gt;  		    const kernel_cap_t *inheritable,
&gt;  		    const kernel_cap_t *permitted);
&gt;  int security_capable(const struct cred *cred,
&gt; -		       struct user_namespace *ns,
&gt; -		       int cap,
&gt; -		       unsigned int opts);
&gt; +		     struct user_namespace *ns,
&gt; +		     int cap,
&gt; +		     unsigned int opts,
&gt; +		     struct cap_aux_data *cad);
&gt;  int security_quotactl(int cmds, int type, int id, struct super_block *sb);
&gt;  int security_quota_on(struct dentry *dentry);
&gt;  int security_syslog(int type);
&gt; @@ -478,9 +488,10 @@ static inline int security_capset(struct cred *new,
&gt;  static inline int security_capable(const struct cred *cred,
&gt;  				   struct user_namespace *ns,
&gt;  				   int cap,
&gt; -				   unsigned int opts)
&gt; +				   unsigned int opts,
&gt; +				   struct cap_aux_data *cad)
&gt;  {
&gt; -	return cap_capable(cred, ns, cap, opts);
&gt; +	return cap_capable(cred, ns, cap, opts, NULL);
&gt;  }
&gt;  
&gt;  static inline int security_quotactl(int cmds, int type, int id,
&gt; diff --git a/kernel/capability.c b/kernel/capability.c
&gt; index 1444f3954d75..c3723443904a 100644
&gt; --- a/kernel/capability.c
&gt; +++ b/kernel/capability.c
&gt; @@ -297,7 +297,7 @@ bool has_ns_capability(struct task_struct *t,
&gt;  	int ret;
&gt;  
&gt;  	rcu_read_lock();
&gt; -	ret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);
&gt; +	ret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE, NULL);
&gt;  	rcu_read_unlock();
&gt;  
&gt;  	return (ret == 0);
&gt; @@ -338,7 +338,7 @@ bool has_ns_capability_noaudit(struct task_struct *t,
&gt;  	int ret;
&gt;  
&gt;  	rcu_read_lock();
&gt; -	ret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);
&gt; +	ret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT, NULL);
&gt;  	rcu_read_unlock();
&gt;  
&gt;  	return (ret == 0);
&gt; @@ -363,7 +363,8 @@ bool has_capability_noaudit(struct task_struct *t, int cap)
&gt;  
&gt;  static bool ns_capable_common(struct user_namespace *ns,
&gt;  			      int cap,
&gt; -			      unsigned int opts)
&gt; +			      unsigned int opts,
&gt; +			      struct cap_aux_data *cad)
&gt;  {
&gt;  	int capable;
&gt;  
&gt; @@ -372,7 +373,7 @@ static bool ns_capable_common(struct user_namespace *ns,
&gt;  		BUG();
&gt;  	}
&gt;  
&gt; -	capable = security_capable(current_cred(), ns, cap, opts);
&gt; +	capable = security_capable(current_cred(), ns, cap, opts, cad);
&gt;  	if (capable == 0) {
&gt;  		current-&gt;flags |= PF_SUPERPRIV;
&gt;  		return true;
&gt; @@ -393,7 +394,7 @@ static bool ns_capable_common(struct user_namespace *ns,
&gt;   */
&gt;  bool ns_capable(struct user_namespace *ns, int cap)
&gt;  {
&gt; -	return ns_capable_common(ns, cap, CAP_OPT_NONE);
&gt; +	return ns_capable_common(ns, cap, CAP_OPT_NONE, NULL);
&gt;  }
&gt;  EXPORT_SYMBOL(ns_capable);
&gt;  
&gt; @@ -411,7 +412,7 @@ EXPORT_SYMBOL(ns_capable);
&gt;   */
&gt;  bool ns_capable_noaudit(struct user_namespace *ns, int cap)
&gt;  {
&gt; -	return ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);
&gt; +	return ns_capable_common(ns, cap, CAP_OPT_NOAUDIT, NULL);
&gt;  }
&gt;  EXPORT_SYMBOL(ns_capable_noaudit);
&gt;  
&gt; @@ -430,7 +431,7 @@ EXPORT_SYMBOL(ns_capable_noaudit);
&gt;   */
&gt;  bool ns_capable_setid(struct user_namespace *ns, int cap)
&gt;  {
&gt; -	return ns_capable_common(ns, cap, CAP_OPT_INSETID);
&gt; +	return ns_capable_common(ns, cap, CAP_OPT_INSETID, NULL);
&gt;  }
&gt;  EXPORT_SYMBOL(ns_capable_setid);
&gt;  
&gt; @@ -470,7 +471,7 @@ bool file_ns_capable(const struct file *file, struct user_namespace *ns,
&gt;  	if (WARN_ON_ONCE(!cap_valid(cap)))
&gt;  		return false;
&gt;  
&gt; -	if (security_capable(file-&gt;f_cred, ns, cap, CAP_OPT_NONE) == 0)
&gt; +	if (security_capable(file-&gt;f_cred, ns, cap, CAP_OPT_NONE, NULL) == 0)
&gt;  		return true;
&gt;  
&gt;  	return false;
&gt; @@ -503,7 +504,8 @@ bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)
&gt;  {
&gt;  	struct user_namespace *ns = current_user_ns();
&gt;  
&gt; -	return ns_capable(ns, cap) &amp;&amp; privileged_wrt_inode_uidgid(ns, inode);
&gt; +	return ns_capable_inode(ns, cap, inode) &amp;&amp;
&gt; +		privileged_wrt_inode_uidgid(ns, inode);
&gt;  }
&gt;  EXPORT_SYMBOL(capable_wrt_inode_uidgid);
&gt;  
&gt; @@ -524,7 +526,18 @@ bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)
&gt;  	cred = rcu_dereference(tsk-&gt;ptracer_cred);
&gt;  	if (cred)
&gt;  		ret = security_capable(cred, ns, CAP_SYS_PTRACE,
&gt; -				       CAP_OPT_NOAUDIT);
&gt; +				       CAP_OPT_NOAUDIT, NULL);
&gt;  	rcu_read_unlock();
&gt;  	return (ret == 0);
&gt;  }
&gt; +
&gt; +bool ns_capable_inode(struct user_namespace *ns, int cap,
&gt; +			const struct inode *inode)
&gt; +{
&gt; +	struct cap_aux_data cad;
&gt; +
&gt; +	cad.type = CAP_AUX_DATA_INODE;
&gt; +	cad.u.inode = inode;
&gt; +	return ns_capable_common(ns, cap, CAP_OPT_NONE, &amp;cad);
&gt; +}
&gt; +EXPORT_SYMBOL(ns_capable_inode);
&gt; diff --git a/kernel/seccomp.c b/kernel/seccomp.c
&gt; index 811b4a86cdf6..d59dd7079ece 100644
&gt; --- a/kernel/seccomp.c
&gt; +++ b/kernel/seccomp.c
&gt; @@ -446,7 +446,7 @@ static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)
&gt;  	 */
&gt;  	if (!task_no_new_privs(current) &amp;&amp;
&gt;  	    security_capable(current_cred(), current_user_ns(),
&gt; -				     CAP_SYS_ADMIN, CAP_OPT_NOAUDIT) != 0)
&gt; +			     CAP_SYS_ADMIN, CAP_OPT_NOAUDIT, NULL) != 0)
&gt;  		return ERR_PTR(-EACCES);
&gt;  
&gt;  	/* Allocate a new seccomp_filter */
&gt; diff --git a/security/apparmor/capability.c b/security/apparmor/capability.c
&gt; index 752f73980e30..c45192a16733 100644
&gt; --- a/security/apparmor/capability.c
&gt; +++ b/security/apparmor/capability.c
&gt; @@ -50,7 +50,7 @@ static void audit_cb(struct audit_buffer *ab, void *va)
&gt;  	struct common_audit_data *sa = va;
&gt;  
&gt;  	audit_log_format(ab, &quot; capname=&quot;);
&gt; -	audit_log_untrustedstring(ab, capability_names[sa-&gt;u.cap]);
&gt; +	audit_log_untrustedstring(ab, capability_names[sa-&gt;u.cap_struct.cap]);
&gt;  }
&gt;  
&gt;  /**
&gt; @@ -148,13 +148,15 @@ static int profile_capable(struct aa_profile *profile, int cap,
&gt;   *
&gt;   * Returns: 0 on success, or else an error code.
&gt;   */
&gt; -int aa_capable(struct aa_label *label, int cap, unsigned int opts)
&gt; +int aa_capable(struct aa_label *label, int cap, unsigned int opts,
&gt; +	       struct cap_aux_data *cad)
&gt;  {
&gt;  	struct aa_profile *profile;
&gt;  	int error = 0;
&gt;  	DEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);
&gt;  
&gt; -	sa.u.cap = cap;
&gt; +	sa.u.cap_struct.cap = cap;
&gt; +	sa.u.cap_struct.cad = cad;
&gt;  	error = fn_for_each_confined(label, profile,
&gt;  			profile_capable(profile, cap, opts, &amp;sa));
&gt;  
&gt; diff --git a/security/apparmor/include/capability.h b/security/apparmor/include/capability.h
&gt; index 1b3663b6ab12..d888f09d76d1 100644
&gt; --- a/security/apparmor/include/capability.h
&gt; +++ b/security/apparmor/include/capability.h
&gt; @@ -20,6 +20,7 @@
&gt;  #include &quot;apparmorfs.h&quot;
&gt;  
&gt;  struct aa_label;
&gt; +struct cap_aux_data;
&gt;  
&gt;  /* aa_caps - confinement data for capabilities
&gt;   * @allowed: capabilities mask
&gt; @@ -40,7 +41,8 @@ struct aa_caps {
&gt;  
&gt;  extern struct aa_sfs_entry aa_sfs_entry_caps[];
&gt;  
&gt; -int aa_capable(struct aa_label *label, int cap, unsigned int opts);
&gt; +int aa_capable(struct aa_label *label, int cap, unsigned int opts,
&gt; +	       struct cap_aux_data *cad);
&gt;  
&gt;  static inline void aa_free_cap_rules(struct aa_caps *caps)
&gt;  {
&gt; diff --git a/security/apparmor/ipc.c b/security/apparmor/ipc.c
&gt; index aacd1e95cb59..deb5267ca695 100644
&gt; --- a/security/apparmor/ipc.c
&gt; +++ b/security/apparmor/ipc.c
&gt; @@ -108,7 +108,7 @@ static int profile_tracer_perm(struct aa_profile *tracer,
&gt;  	aad(sa)-&gt;peer = tracee;
&gt;  	aad(sa)-&gt;request = 0;
&gt;  	aad(sa)-&gt;error = aa_capable(&amp;tracer-&gt;label, CAP_SYS_PTRACE,
&gt; -				    CAP_OPT_NONE);
&gt; +				    CAP_OPT_NONE, NULL);
&gt;  
&gt;  	return aa_audit(AUDIT_APPARMOR_AUTO, tracer, sa, audit_ptrace_cb);
&gt;  }
&gt; diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
&gt; index 87500bde5a92..82790accb679 100644
&gt; --- a/security/apparmor/lsm.c
&gt; +++ b/security/apparmor/lsm.c
&gt; @@ -172,14 +172,15 @@ static int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,
&gt;  }
&gt;  
&gt;  static int apparmor_capable(const struct cred *cred, struct user_namespace *ns,
&gt; -			    int cap, unsigned int opts)
&gt; +			    int cap, unsigned int opts,
&gt; +			    struct cap_aux_data *cad)
&gt;  {
&gt;  	struct aa_label *label;
&gt;  	int error = 0;
&gt;  
&gt;  	label = aa_get_newest_cred_label(cred);
&gt;  	if (!unconfined(label))
&gt; -		error = aa_capable(label, cap, opts);
&gt; +		error = aa_capable(label, cap, opts, cad);
&gt;  	aa_put_label(label);
&gt;  
&gt;  	return error;
&gt; diff --git a/security/apparmor/resource.c b/security/apparmor/resource.c
&gt; index 552ed09cb47e..9b3d4b4437f2 100644
&gt; --- a/security/apparmor/resource.c
&gt; +++ b/security/apparmor/resource.c
&gt; @@ -124,7 +124,7 @@ int aa_task_setrlimit(struct aa_label *label, struct task_struct *task,
&gt;  	 */
&gt;  
&gt;  	if (label != peer &amp;&amp;
&gt; -	    aa_capable(label, CAP_SYS_RESOURCE, CAP_OPT_NOAUDIT) != 0)
&gt; +	    aa_capable(label, CAP_SYS_RESOURCE, CAP_OPT_NOAUDIT, NULL) != 0)
&gt;  		error = fn_for_each(label, profile,
&gt;  				audit_resource(profile, resource,
&gt;  					       new_rlim-&gt;rlim_max, peer,
&gt; diff --git a/security/commoncap.c b/security/commoncap.c
&gt; index c477fb673701..1860ea50f473 100644
&gt; --- a/security/commoncap.c
&gt; +++ b/security/commoncap.c
&gt; @@ -68,7 +68,7 @@ static void warn_setuid_and_fcaps_mixed(const char *fname)
&gt;   * kernel's capable() and has_capability() returns 1 for this case.
&gt;   */
&gt;  int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,
&gt; -		int cap, unsigned int opts)
&gt; +		int cap, unsigned int opts, struct cap_aux_data *cad)
&gt;  {
&gt;  	struct user_namespace *ns = targ_ns;
&gt;  
&gt; @@ -226,7 +226,7 @@ static inline int cap_inh_is_capped(void)
&gt;  	 * capability
&gt;  	 */
&gt;  	if (cap_capable(current_cred(), current_cred()-&gt;user_ns,
&gt; -			CAP_SETPCAP, CAP_OPT_NONE) == 0)
&gt; +			CAP_SETPCAP, CAP_OPT_NONE, NULL) == 0)
&gt;  		return 0;
&gt;  	return 1;
&gt;  }
&gt; @@ -1211,7 +1211,8 @@ int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,
&gt;  		    || (cap_capable(current_cred(),
&gt;  				    current_cred()-&gt;user_ns,
&gt;  				    CAP_SETPCAP,
&gt; -				    CAP_OPT_NONE) != 0)			/*[4]*/
&gt; +				    CAP_OPT_NONE,
&gt; +				    NULL) != 0)				/*[4]*/
&gt;  			/*
&gt;  			 * [1] no changing of bits that are locked
&gt;  			 * [2] no unlocking of locks
&gt; @@ -1307,7 +1308,7 @@ int cap_vm_enough_memory(struct mm_struct *mm, long pages)
&gt;  	int cap_sys_admin = 0;
&gt;  
&gt;  	if (cap_capable(current_cred(), &amp;init_user_ns,
&gt; -				CAP_SYS_ADMIN, CAP_OPT_NOAUDIT) == 0)
&gt; +				CAP_SYS_ADMIN, CAP_OPT_NOAUDIT, NULL) == 0)
&gt;  		cap_sys_admin = 1;
&gt;  
&gt;  	return cap_sys_admin;
&gt; @@ -1328,7 +1329,7 @@ int cap_mmap_addr(unsigned long addr)
&gt;  
&gt;  	if (addr &lt; dac_mmap_min_addr) {
&gt;  		ret = cap_capable(current_cred(), &amp;init_user_ns, CAP_SYS_RAWIO,
&gt; -				  CAP_OPT_NONE);
&gt; +				  CAP_OPT_NONE, NULL);
&gt;  		/* set PF_SUPERPRIV if it turns out we allow the low mmap */
&gt;  		if (ret == 0)
&gt;  			current-&gt;flags |= PF_SUPERPRIV;
&gt; diff --git a/security/lsm_audit.c b/security/lsm_audit.c
&gt; index 33028c098ef3..4871b2508a4a 100644
&gt; --- a/security/lsm_audit.c
&gt; +++ b/security/lsm_audit.c
&gt; @@ -229,9 +229,26 @@ static void dump_common_audit_data(struct audit_buffer *ab,
&gt;  	case LSM_AUDIT_DATA_IPC:
&gt;  		audit_log_format(ab, &quot; key=%d &quot;, a-&gt;u.ipc_id);
&gt;  		break;
&gt; -	case LSM_AUDIT_DATA_CAP:
&gt; -		audit_log_format(ab, &quot; capability=%d &quot;, a-&gt;u.cap);
&gt; +	case LSM_AUDIT_DATA_CAP: {
&gt; +		const struct inode *inode;
&gt; +
&gt; +		if (a-&gt;u.cap_struct.cad) {
&gt; +			switch (a-&gt;u.cap_struct.cad-&gt;type) {
&gt; +			case CAP_AUX_DATA_INODE: {
&gt; +				inode = a-&gt;u.cap_struct.cad-&gt;u.inode;
&gt; +
&gt; +				audit_log_format(ab, &quot; dev=&quot;);
&gt; +				audit_log_untrustedstring(ab,
&gt; +					inode-&gt;i_sb-&gt;s_id);
&gt; +				audit_log_format(ab, &quot; ino=%lu&quot;,
&gt; +					inode-&gt;i_ino);
&gt; +				break;
&gt; +			}
&gt; +			}
&gt; +		}
&gt; +		audit_log_format(ab, &quot; capability=%d &quot;, a-&gt;u.cap_struct.cap);
&gt;  		break;
&gt; +	}
&gt;  	case LSM_AUDIT_DATA_PATH: {
&gt;  		struct inode *inode;
&gt;  
&gt; diff --git a/security/safesetid/lsm.c b/security/safesetid/lsm.c
&gt; index cecd38e2ac80..c74ed83e9501 100644
&gt; --- a/security/safesetid/lsm.c
&gt; +++ b/security/safesetid/lsm.c
&gt; @@ -80,7 +80,8 @@ static bool check_setuid_policy_hashtable_key_value(kuid_t parent,
&gt;  static int safesetid_security_capable(const struct cred *cred,
&gt;  				      struct user_namespace *ns,
&gt;  				      int cap,
&gt; -				      unsigned int opts)
&gt; +				      unsigned int opts,
&gt; +				      struct cap_aux_data *cad)
&gt;  {
&gt;  	if (cap == CAP_SETUID &amp;&amp;
&gt;  	    check_setuid_policy_hashtable_key(cred-&gt;uid)) {
&gt; diff --git a/security/security.c b/security/security.c
&gt; index 613a5c00e602..06274a7b9c4e 100644
&gt; --- a/security/security.c
&gt; +++ b/security/security.c
&gt; @@ -691,9 +691,10 @@ int security_capset(struct cred *new, const struct cred *old,
&gt;  int security_capable(const struct cred *cred,
&gt;  		     struct user_namespace *ns,
&gt;  		     int cap,
&gt; -		     unsigned int opts)
&gt; +		     unsigned int opts,
&gt; +		     struct cap_aux_data *cad)
&gt;  {
&gt; -	return call_int_hook(capable, 0, cred, ns, cap, opts);
&gt; +	return call_int_hook(capable, 0, cred, ns, cap, opts, cad);
&gt;  }
&gt;  
&gt;  int security_quotactl(int cmds, int type, int id, struct super_block *sb)
&gt; diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
&gt; index f77b314d0575..d6c699ed06be 100644
&gt; --- a/security/selinux/hooks.c
&gt; +++ b/security/selinux/hooks.c
&gt; @@ -1618,7 +1618,10 @@ static inline u32 signal_to_av(int sig)
&gt;  
&gt;  /* Check whether a task is allowed to use a capability. */
&gt;  static int cred_has_capability(const struct cred *cred,
&gt; -			       int cap, unsigned int opts, bool initns)
&gt; +				int cap,
&gt; +				unsigned int opts,
&gt; +				bool initns,
&gt; +				struct cap_aux_data *cad)
&gt;  {
&gt;  	struct common_audit_data ad;
&gt;  	struct av_decision avd;
&gt; @@ -1628,7 +1631,8 @@ static int cred_has_capability(const struct cred *cred,
&gt;  	int rc;
&gt;  
&gt;  	ad.type = LSM_AUDIT_DATA_CAP;
&gt; -	ad.u.cap = cap;
&gt; +	ad.u.cap_struct.cad = cad;
&gt; +	ad.u.cap_struct.cap = cap;
&gt;  
&gt;  	switch (CAP_TO_INDEX(cap)) {
&gt;  	case 0:
&gt; @@ -2165,9 +2169,9 @@ static int selinux_capset(struct cred *new, const struct cred *old,
&gt;   */
&gt;  
&gt;  static int selinux_capable(const struct cred *cred, struct user_namespace *ns,
&gt; -			   int cap, unsigned int opts)
&gt; +			   int cap, unsigned int opts, struct cap_aux_data *cad)
&gt;  {
&gt; -	return cred_has_capability(cred, cap, opts, ns == &amp;init_user_ns);
&gt; +	return cred_has_capability(cred, cap, opts, ns == &amp;init_user_ns, cad);
&gt;  }
&gt;  
&gt;  static int selinux_quotactl(int cmds, int type, int id, struct super_block *sb)
&gt; @@ -2241,7 +2245,7 @@ static int selinux_vm_enough_memory(struct mm_struct *mm, long pages)
&gt;  	int rc, cap_sys_admin = 0;
&gt;  
&gt;  	rc = cred_has_capability(current_cred(), CAP_SYS_ADMIN,
&gt; -				 CAP_OPT_NOAUDIT, true);
&gt; +				 CAP_OPT_NOAUDIT, true, NULL);
&gt;  	if (rc == 0)
&gt;  		cap_sys_admin = 1;
&gt;  
&gt; @@ -3101,9 +3105,9 @@ static bool has_cap_mac_admin(bool audit)
&gt;  	const struct cred *cred = current_cred();
&gt;  	unsigned int opts = audit ? CAP_OPT_NONE : CAP_OPT_NOAUDIT;
&gt;  
&gt; -	if (cap_capable(cred, &amp;init_user_ns, CAP_MAC_ADMIN, opts))
&gt; +	if (cap_capable(cred, &amp;init_user_ns, CAP_MAC_ADMIN, opts, NULL))
&gt;  		return false;
&gt; -	if (cred_has_capability(cred, CAP_MAC_ADMIN, opts, true))
&gt; +	if (cred_has_capability(cred, CAP_MAC_ADMIN, opts, true, NULL))
&gt;  		return false;
&gt;  	return true;
&gt;  }
&gt; @@ -3563,7 +3567,7 @@ static int selinux_file_ioctl(struct file *file, unsigned int cmd,
&gt;  	case KDSKBENT:
&gt;  	case KDSKBSENT:
&gt;  		error = cred_has_capability(cred, CAP_SYS_TTY_CONFIG,
&gt; -					    CAP_OPT_NONE, true);
&gt; +					    CAP_OPT_NONE, true, NULL);
&gt;  		break;
&gt;  
&gt;  	/* default case assumes that the command will go
&gt; diff --git a/security/smack/smack_access.c b/security/smack/smack_access.c
&gt; index fe2ce3a65822..e961bfe8f00a 100644
&gt; --- a/security/smack/smack_access.c
&gt; +++ b/security/smack/smack_access.c
&gt; @@ -640,7 +640,7 @@ bool smack_privileged_cred(int cap, const struct cred *cred)
&gt;  	struct smack_known_list_elem *sklep;
&gt;  	int rc;
&gt;  
&gt; -	rc = cap_capable(cred, &amp;init_user_ns, cap, CAP_OPT_NONE);
&gt; +	rc = cap_capable(cred, &amp;init_user_ns, cap, CAP_OPT_NONE, NULL);
&gt;  	if (rc)
&gt;  		return false;
&gt;  




</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="29895" href="msg29895.html">Re: [RFC PATCH] security, capability: pass object information to security_capable</a></strong>
<ul><li><em>From:</em> Stephen Smalley</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="29891" href="msg29891.html">[RFC PATCH] security,capability: pass object information to security_capable</a></strong>
<ul><li><em>From:</em> Nicholas Franck</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg29892.html">Re: [RFC PATCH] security,capability: pass object information to security_capable</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg29894.html">Re: [RFC PATCH] security, capability: pass object information to security_capable</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg29914.html">Re: [RFC PATCH] security, capability: pass object information to security_capable</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg29895.html">Re: [RFC PATCH] security, capability: pass object information to security_capable</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#29893"><strong>Date</strong></a></li>
<li><a href="index.html#29893"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-users/>[Fedora&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
