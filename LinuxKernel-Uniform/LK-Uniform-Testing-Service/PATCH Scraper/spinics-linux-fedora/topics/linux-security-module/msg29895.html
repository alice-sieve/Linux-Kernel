<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [RFC PATCH] security, capability: pass object information to security_capable -->
<!--X-From-R13: Egrcura Eznyyrl &#60;fqfNglpub.afn.tbi> -->
<!--X-Date: Fri, 12 Jul 2019 11:25:31 &#45;0700 -->
<!--X-Message-Id: e8de4a1c&#45;7e18&#45;fc20&#45;e372&#45;67bbaa93fd42@tycho.nsa.gov -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190712173404.14417&#45;1&#45;nhfran2@tycho.nsa.gov -->
<!--X-Reference: 680c35a8&#45;1ee5&#45;725d&#45;b33c&#45;7bdced39763c@schaufler&#45;ca.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Security Module, Re: [RFC PATCH] security, capability: pass object information to security_capable">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Security Module -- Re: [RFC PATCH] security, capability: pass object information to security_capable</title>
<link rel="alternate" type="application/rss+xml" title="Linux Security Module" href="//feeds.feedburner.com/LinuxSecurityModule">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [RFC PATCH] security, capability: pass object information to security_capable</h1>
[<a href="msg29894.html">Date Prev</a>][<a href="msg29896.html">Date Next</a>][<a href="msg29893.html">Thread Prev</a>][<a href="msg29896.html">Thread Next</a>][<a href="maillist.html#29895">Date Index</a>][<a href="index.html#29895">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [RFC PATCH] security, capability: pass object information to security_capable</li>
<li><em>From</em>: Stephen Smalley &lt;sds@xxxxxxxxxxxxx&gt;</li>
<li><em>Date</em>: Fri, 12 Jul 2019 14:25:17 -0400</li>
<li><em>Cc</em>: selinux@xxxxxxxxxxxxxxx, linux-security-module@xxxxxxxxxxxxxxx,        luto@xxxxxxxxxxxxxx, jmorris@xxxxxxxxx, keescook@xxxxxxxxxxxx,        serge@xxxxxxxxxx, john.johansen@xxxxxxxxxxxxx, mortonm@xxxxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg29893.html">680c35a8-1ee5-725d-b33c-7bdced39763c@schaufler-ca.com</a>&gt;</li>
<li><em>References</em>: &lt;<a href="msg29891.html">20190712173404.14417-1-nhfran2@tycho.nsa.gov</a>&gt; &lt;<a href="msg29893.html">680c35a8-1ee5-725d-b33c-7bdced39763c@schaufler-ca.com</a>&gt;</li>
<li><em>User-agent</em>: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Thunderbird/60.7.0</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">
On 7/12/19 1:58 PM, Casey Schaufler wrote:
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
On 7/12/2019 10:34 AM, Nicholas Franck wrote:
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
At present security_capable does not pass any object information
and therefore can neither audit the particular object nor take it
into account. Augment the security_capable interface to support
passing supplementary data. Use this facility initially to convey
the inode for capability checks relevant to inodes. This only
addresses capable_wrt_inode_uidgid calls; other capability checks
relevant to inodes will be addressed in subsequent changes. In the
future, this will be further extended to pass object information for
other capability checks such as the target task for CAP_KILL.
</pre></blockquote><pre style="margin: 0em;">

This seems wrong to me. The capability system has nothing to do
with objects. Passing object information through security_capable()
may be convenient, but isn't relevant to the purpose of the interface.
It appears that there are very few places where the object information
is actually useful.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>A fair number of capabilities are checked upon some attempted object 
</tt><tt>access (often right after comparing UIDs or other per-object state), and 
</tt><tt>the particular object can be very helpful in both audit and in access 
</tt><tt>control.  More below.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
In SELinux this new information is leveraged here to include the inode
in the audit message. In the future, it could also be used to perform
a per inode capability checks.
</pre></blockquote><pre style="margin: 0em;">

I suggest that you want a mechanism for adding the inode information
to the audit record instead.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>That is part of what we want, but not the entire picture.  But with 
</tt><tt>respect to audit, the problem today is that one sees SELinux 
</tt><tt>dac_read_search, dac_override, etc denials with no indication as to the 
</tt><tt>particular file, which is unfortunate both from a security auditing 
</tt><tt>perspective and from a policy development perspective.  The only option 
</tt><tt>today to gain that information is by enabling system call audit and 
</tt><tt>setting at least one audit filter so that the audit framework will 
</tt><tt>collect that information and include it in the audit records that are 
</tt><tt>emitted upon syscall exit after any such AVC denial.  Unfortunately, 
</tt><tt>that is all disabled by default on most systems due to its associated 
</tt><tt>performance overhead, and one doesn't even have the option of enabling 
</tt><tt>it on some systems, e.g. Android devices.  And even when one can enable 
</tt><tt>syscall audit, one must correlate the syscall audit record to the 
</tt><tt>associated AVC record to identify the object rather than having the 
</tt><tt>information directly included in the same record.
</tt><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
What would a &quot;per inode&quot; capability check be? Capability checks are
process checks, not object checks.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>Ideally it would be possible to scope dac_override and other 
</tt><tt>capabilities to specific objects rather than having to allow it for all 
</tt><tt>or none.  Just because a process needs to override DAC on one file or 
</tt><tt>one set of files is not a reason to allow it to do so on every file it 
</tt><tt>can access at all.  If we want to apply least privilege, then this is a 
</tt><tt>desirable facility.  I understand that doesn't mesh with Smack's mental 
</tt><tt>model but it would probably be useful to both SELinux and AppArmor, 
</tt><tt>among others.
</tt><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
It would be possible to fold the existing opts argument into this new
supplementary data structure. This was omitted from this change to
minimize changes.

Signed-off-by: Nicholas Franck &lt;nhfran2@xxxxxxxxxxxxx&gt;
---
  include/linux/capability.h             |  7 ++++++
  include/linux/lsm_audit.h              |  5 +++-
  include/linux/lsm_hooks.h              |  3 ++-
  include/linux/security.h               | 23 +++++++++++++-----
  kernel/capability.c                    | 33 ++++++++++++++++++--------
  kernel/seccomp.c                       |  2 +-
  security/apparmor/capability.c         |  8 ++++---
  security/apparmor/include/capability.h |  4 +++-
  security/apparmor/ipc.c                |  2 +-
  security/apparmor/lsm.c                |  5 ++--
  security/apparmor/resource.c           |  2 +-
  security/commoncap.c                   | 11 +++++----
  security/lsm_audit.c                   | 21 ++++++++++++++--
  security/safesetid/lsm.c               |  3 ++-
  security/security.c                    |  5 ++--
  security/selinux/hooks.c               | 20 +++++++++-------
  security/smack/smack_access.c          |  2 +-
  17 files changed, 110 insertions(+), 46 deletions(-)

diff --git a/include/linux/capability.h b/include/linux/capability.h
index ecce0f43c73a..f72de64c179d 100644
--- a/include/linux/capability.h
+++ b/include/linux/capability.h
@@ -211,6 +211,8 @@ extern bool capable(int cap);
  extern bool ns_capable(struct user_namespace *ns, int cap);
  extern bool ns_capable_noaudit(struct user_namespace *ns, int cap);
  extern bool ns_capable_setid(struct user_namespace *ns, int cap);
+extern bool ns_capable_inode(struct user_namespace *ns, int cap,
+			     const struct inode *inode);
  #else
  static inline bool has_capability(struct task_struct *t, int cap)
  {
@@ -246,6 +248,11 @@ static inline bool ns_capable_setid(struct user_namespace *ns, int cap)
  {
  	return true;
  }
+static bool ns_capable_inode(struct user_namespace *ns, int cap,
+			     const struct inode *inode)
+{
+	return true;
+}
  #endif /* CONFIG_MULTIUSER */
  extern bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode);
  extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);
diff --git a/include/linux/lsm_audit.h b/include/linux/lsm_audit.h
index 915330abf6e5..15d2a62639f0 100644
--- a/include/linux/lsm_audit.h
+++ b/include/linux/lsm_audit.h
@@ -79,7 +79,10 @@ struct common_audit_data {
  		struct dentry *dentry;
  		struct inode *inode;
  		struct lsm_network_audit *net;
-		int cap;
+		struct  {
+			int cap;
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
+			struct cap_aux_data *cad;
+		} cap_struct;
  		int ipc_id;
  		struct task_struct *tsk;
  #ifdef CONFIG_KEYS
diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index 47f58cfb6a19..b2a37d613030 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -1469,7 +1469,8 @@ union security_list_options {
  	int (*capable)(const struct cred *cred,
  			struct user_namespace *ns,
  			int cap,
-			unsigned int opts);
+			unsigned int opts,
+			struct cap_aux_data *cad);
  	int (*quotactl)(int cmds, int type, int id, struct super_block *sb);
  	int (*quota_on)(struct dentry *dentry);
  	int (*syslog)(int type);
diff --git a/include/linux/security.h b/include/linux/security.h
index 659071c2e57c..8fce5e69dc52 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -77,9 +77,18 @@ enum lsm_event {
  	LSM_POLICY_CHANGE,
  };
</pre><tt>  
</tt><tt>+
</tt><pre style="margin: 0em;">
+struct cap_aux_data {
+	char type;
+#define CAP_AUX_DATA_INODE	1
+	union	{
+		const struct inode *inode;
+	} u;
+};
+
  /* These functions are in security/commoncap.c */
  extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
-		       int cap, unsigned int opts);
+		       int cap, unsigned int opts, struct cap_aux_data *cad);
  extern int cap_settime(const struct timespec64 *ts, const struct timezone *tz);
  extern int cap_ptrace_access_check(struct task_struct *child, unsigned int mode);
  extern int cap_ptrace_traceme(struct task_struct *parent);
@@ -215,9 +224,10 @@ int security_capset(struct cred *new, const struct cred *old,
  		    const kernel_cap_t *inheritable,
  		    const kernel_cap_t *permitted);
  int security_capable(const struct cred *cred,
-		       struct user_namespace *ns,
-		       int cap,
-		       unsigned int opts);
+		     struct user_namespace *ns,
+		     int cap,
+		     unsigned int opts,
+		     struct cap_aux_data *cad);
  int security_quotactl(int cmds, int type, int id, struct super_block *sb);
  int security_quota_on(struct dentry *dentry);
  int security_syslog(int type);
@@ -478,9 +488,10 @@ static inline int security_capset(struct cred *new,
  static inline int security_capable(const struct cred *cred,
  				   struct user_namespace *ns,
  				   int cap,
-				   unsigned int opts)
+				   unsigned int opts,
+				   struct cap_aux_data *cad)
  {
-	return cap_capable(cred, ns, cap, opts);
+	return cap_capable(cred, ns, cap, opts, NULL);
  }
</pre><tt>  
</tt><tt>  static inline int security_quotactl(int cmds, int type, int id,
</tt><pre style="margin: 0em;">
diff --git a/kernel/capability.c b/kernel/capability.c
index 1444f3954d75..c3723443904a 100644
--- a/kernel/capability.c
+++ b/kernel/capability.c
@@ -297,7 +297,7 @@ bool has_ns_capability(struct task_struct *t,
  	int ret;
</pre><tt>  
</tt><tt>  	rcu_read_lock();
</tt><pre style="margin: 0em;">
-	ret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);
+	ret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE, NULL);
  	rcu_read_unlock();
</pre><tt>  
</tt><tt>  	return (ret == 0);
</tt><pre style="margin: 0em;">
@@ -338,7 +338,7 @@ bool has_ns_capability_noaudit(struct task_struct *t,
  	int ret;
</pre><tt>  
</tt><tt>  	rcu_read_lock();
</tt><pre style="margin: 0em;">
-	ret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);
+	ret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT, NULL);
  	rcu_read_unlock();
</pre><tt>  
</tt><tt>  	return (ret == 0);
</tt><pre style="margin: 0em;">
@@ -363,7 +363,8 @@ bool has_capability_noaudit(struct task_struct *t, int cap)
</pre><tt>  
</tt><tt>  static bool ns_capable_common(struct user_namespace *ns,
</tt><pre style="margin: 0em;">
  			      int cap,
-			      unsigned int opts)
+			      unsigned int opts,
+			      struct cap_aux_data *cad)
  {
  	int capable;
</pre><tt>  
</tt><tt>@@ -372,7 +373,7 @@ static bool ns_capable_common(struct user_namespace *ns,
</tt><pre style="margin: 0em;">
  		BUG();
  	}
</pre><tt>  
</tt><tt>-	capable = security_capable(current_cred(), ns, cap, opts);
</tt><pre style="margin: 0em;">
+	capable = security_capable(current_cred(), ns, cap, opts, cad);
  	if (capable == 0) {
  		current-&gt;flags |= PF_SUPERPRIV;
  		return true;
@@ -393,7 +394,7 @@ static bool ns_capable_common(struct user_namespace *ns,
   */
  bool ns_capable(struct user_namespace *ns, int cap)
  {
-	return ns_capable_common(ns, cap, CAP_OPT_NONE);
+	return ns_capable_common(ns, cap, CAP_OPT_NONE, NULL);
  }
  EXPORT_SYMBOL(ns_capable);
</pre><tt>  
</tt><tt>@@ -411,7 +412,7 @@ EXPORT_SYMBOL(ns_capable);
</tt><pre style="margin: 0em;">
   */
  bool ns_capable_noaudit(struct user_namespace *ns, int cap)
  {
-	return ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);
+	return ns_capable_common(ns, cap, CAP_OPT_NOAUDIT, NULL);
  }
  EXPORT_SYMBOL(ns_capable_noaudit);
</pre><tt>  
</tt><tt>@@ -430,7 +431,7 @@ EXPORT_SYMBOL(ns_capable_noaudit);
</tt><pre style="margin: 0em;">
   */
  bool ns_capable_setid(struct user_namespace *ns, int cap)
  {
-	return ns_capable_common(ns, cap, CAP_OPT_INSETID);
+	return ns_capable_common(ns, cap, CAP_OPT_INSETID, NULL);
  }
  EXPORT_SYMBOL(ns_capable_setid);
</pre><tt>  
</tt><tt>@@ -470,7 +471,7 @@ bool file_ns_capable(const struct file *file, struct user_namespace *ns,
</tt><pre style="margin: 0em;">
  	if (WARN_ON_ONCE(!cap_valid(cap)))
  		return false;
</pre><tt>  
</tt><tt>-	if (security_capable(file-&gt;f_cred, ns, cap, CAP_OPT_NONE) == 0)
</tt><pre style="margin: 0em;">
+	if (security_capable(file-&gt;f_cred, ns, cap, CAP_OPT_NONE, NULL) == 0)
  		return true;
</pre><tt>  
</tt><tt>  	return false;
</tt><pre style="margin: 0em;">
@@ -503,7 +504,8 @@ bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)
  {
  	struct user_namespace *ns = current_user_ns();
</pre><tt>  
</tt><tt>-	return ns_capable(ns, cap) &amp;&amp; privileged_wrt_inode_uidgid(ns, inode);
</tt><pre style="margin: 0em;">
+	return ns_capable_inode(ns, cap, inode) &amp;&amp;
+		privileged_wrt_inode_uidgid(ns, inode);
  }
  EXPORT_SYMBOL(capable_wrt_inode_uidgid);
</pre><tt>  
</tt><tt>@@ -524,7 +526,18 @@ bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)
</tt><pre style="margin: 0em;">
  	cred = rcu_dereference(tsk-&gt;ptracer_cred);
  	if (cred)
  		ret = security_capable(cred, ns, CAP_SYS_PTRACE,
-				       CAP_OPT_NOAUDIT);
+				       CAP_OPT_NOAUDIT, NULL);
  	rcu_read_unlock();
  	return (ret == 0);
  }
+
+bool ns_capable_inode(struct user_namespace *ns, int cap,
+			const struct inode *inode)
+{
+	struct cap_aux_data cad;
+
+	cad.type = CAP_AUX_DATA_INODE;
+	cad.u.inode = inode;
+	return ns_capable_common(ns, cap, CAP_OPT_NONE, &amp;cad);
+}
+EXPORT_SYMBOL(ns_capable_inode);
diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index 811b4a86cdf6..d59dd7079ece 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -446,7 +446,7 @@ static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)
  	 */
  	if (!task_no_new_privs(current) &amp;&amp;
  	    security_capable(current_cred(), current_user_ns(),
-				     CAP_SYS_ADMIN, CAP_OPT_NOAUDIT) != 0)
+			     CAP_SYS_ADMIN, CAP_OPT_NOAUDIT, NULL) != 0)
  		return ERR_PTR(-EACCES);
</pre><tt>  
</tt><tt>  	/* Allocate a new seccomp_filter */
</tt><pre style="margin: 0em;">
diff --git a/security/apparmor/capability.c b/security/apparmor/capability.c
index 752f73980e30..c45192a16733 100644
--- a/security/apparmor/capability.c
+++ b/security/apparmor/capability.c
@@ -50,7 +50,7 @@ static void audit_cb(struct audit_buffer *ab, void *va)
  	struct common_audit_data *sa = va;
</pre><tt>  
</tt><tt>  	audit_log_format(ab, &quot; capname=&quot;);
</tt><pre style="margin: 0em;">
-	audit_log_untrustedstring(ab, capability_names[sa-&gt;u.cap]);
+	audit_log_untrustedstring(ab, capability_names[sa-&gt;u.cap_struct.cap]);
  }
</pre><tt>  
</tt><tt>  /**
</tt><pre style="margin: 0em;">
@@ -148,13 +148,15 @@ static int profile_capable(struct aa_profile *profile, int cap,
   *
   * Returns: 0 on success, or else an error code.
   */
-int aa_capable(struct aa_label *label, int cap, unsigned int opts)
+int aa_capable(struct aa_label *label, int cap, unsigned int opts,
+	       struct cap_aux_data *cad)
  {
  	struct aa_profile *profile;
  	int error = 0;
  	DEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);
</pre><tt>  
</tt><tt>-	sa.u.cap = cap;
</tt><pre style="margin: 0em;">
+	sa.u.cap_struct.cap = cap;
+	sa.u.cap_struct.cad = cad;
  	error = fn_for_each_confined(label, profile,
  			profile_capable(profile, cap, opts, &amp;sa));
</pre><tt>  
</tt><tt>diff --git a/security/apparmor/include/capability.h b/security/apparmor/include/capability.h
</tt><pre style="margin: 0em;">
index 1b3663b6ab12..d888f09d76d1 100644
--- a/security/apparmor/include/capability.h
+++ b/security/apparmor/include/capability.h
@@ -20,6 +20,7 @@
  #include &quot;apparmorfs.h&quot;
</pre><tt>  
</tt><tt>  struct aa_label;
</tt><pre style="margin: 0em;">
+struct cap_aux_data;
</pre><tt>  
</tt><tt>  /* aa_caps - confinement data for capabilities
</tt><pre style="margin: 0em;">
   * @allowed: capabilities mask
@@ -40,7 +41,8 @@ struct aa_caps {
</pre><tt>  
</tt><tt>  extern struct aa_sfs_entry aa_sfs_entry_caps[];
</tt><tt>  
</tt><tt>-int aa_capable(struct aa_label *label, int cap, unsigned int opts);
</tt><pre style="margin: 0em;">
+int aa_capable(struct aa_label *label, int cap, unsigned int opts,
+	       struct cap_aux_data *cad);
</pre><tt>  
</tt><tt>  static inline void aa_free_cap_rules(struct aa_caps *caps)
</tt><pre style="margin: 0em;">
  {
diff --git a/security/apparmor/ipc.c b/security/apparmor/ipc.c
index aacd1e95cb59..deb5267ca695 100644
--- a/security/apparmor/ipc.c
+++ b/security/apparmor/ipc.c
@@ -108,7 +108,7 @@ static int profile_tracer_perm(struct aa_profile *tracer,
  	aad(sa)-&gt;peer = tracee;
  	aad(sa)-&gt;request = 0;
  	aad(sa)-&gt;error = aa_capable(&amp;tracer-&gt;label, CAP_SYS_PTRACE,
-				    CAP_OPT_NONE);
+				    CAP_OPT_NONE, NULL);
</pre><tt>  
</tt><tt>  	return aa_audit(AUDIT_APPARMOR_AUTO, tracer, sa, audit_ptrace_cb);
</tt><pre style="margin: 0em;">
  }
diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
index 87500bde5a92..82790accb679 100644
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -172,14 +172,15 @@ static int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,
  }
</pre><tt>  
</tt><tt>  static int apparmor_capable(const struct cred *cred, struct user_namespace *ns,
</tt><pre style="margin: 0em;">
-			    int cap, unsigned int opts)
+			    int cap, unsigned int opts,
+			    struct cap_aux_data *cad)
  {
  	struct aa_label *label;
  	int error = 0;
</pre><tt>  
</tt><tt>  	label = aa_get_newest_cred_label(cred);
</tt><pre style="margin: 0em;">
  	if (!unconfined(label))
-		error = aa_capable(label, cap, opts);
+		error = aa_capable(label, cap, opts, cad);
  	aa_put_label(label);
</pre><tt>  
</tt><tt>  	return error;
</tt><pre style="margin: 0em;">
diff --git a/security/apparmor/resource.c b/security/apparmor/resource.c
index 552ed09cb47e..9b3d4b4437f2 100644
--- a/security/apparmor/resource.c
+++ b/security/apparmor/resource.c
@@ -124,7 +124,7 @@ int aa_task_setrlimit(struct aa_label *label, struct task_struct *task,
  	 */
</pre><tt>  
</tt><tt>  	if (label != peer &amp;&amp;
</tt><pre style="margin: 0em;">
-	    aa_capable(label, CAP_SYS_RESOURCE, CAP_OPT_NOAUDIT) != 0)
+	    aa_capable(label, CAP_SYS_RESOURCE, CAP_OPT_NOAUDIT, NULL) != 0)
  		error = fn_for_each(label, profile,
  				audit_resource(profile, resource,
  					       new_rlim-&gt;rlim_max, peer,
diff --git a/security/commoncap.c b/security/commoncap.c
index c477fb673701..1860ea50f473 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -68,7 +68,7 @@ static void warn_setuid_and_fcaps_mixed(const char *fname)
   * kernel's capable() and has_capability() returns 1 for this case.
   */
  int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,
-		int cap, unsigned int opts)
+		int cap, unsigned int opts, struct cap_aux_data *cad)
  {
  	struct user_namespace *ns = targ_ns;
</pre><tt>  
</tt><tt>@@ -226,7 +226,7 @@ static inline int cap_inh_is_capped(void)
</tt><pre style="margin: 0em;">
  	 * capability
  	 */
  	if (cap_capable(current_cred(), current_cred()-&gt;user_ns,
-			CAP_SETPCAP, CAP_OPT_NONE) == 0)
+			CAP_SETPCAP, CAP_OPT_NONE, NULL) == 0)
  		return 0;
  	return 1;
  }
@@ -1211,7 +1211,8 @@ int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,
  		    || (cap_capable(current_cred(),
  				    current_cred()-&gt;user_ns,
  				    CAP_SETPCAP,
-				    CAP_OPT_NONE) != 0)			/*[4]*/
+				    CAP_OPT_NONE,
+				    NULL) != 0)				/*[4]*/
  			/*
  			 * [1] no changing of bits that are locked
  			 * [2] no unlocking of locks
@@ -1307,7 +1308,7 @@ int cap_vm_enough_memory(struct mm_struct *mm, long pages)
  	int cap_sys_admin = 0;
</pre><tt>  
</tt><tt>  	if (cap_capable(current_cred(), &amp;init_user_ns,
</tt><pre style="margin: 0em;">
-				CAP_SYS_ADMIN, CAP_OPT_NOAUDIT) == 0)
+				CAP_SYS_ADMIN, CAP_OPT_NOAUDIT, NULL) == 0)
  		cap_sys_admin = 1;
</pre><tt>  
</tt><tt>  	return cap_sys_admin;
</tt><pre style="margin: 0em;">
@@ -1328,7 +1329,7 @@ int cap_mmap_addr(unsigned long addr)
</pre><tt>  
</tt><tt>  	if (addr &lt; dac_mmap_min_addr) {
</tt><pre style="margin: 0em;">
  		ret = cap_capable(current_cred(), &amp;init_user_ns, CAP_SYS_RAWIO,
-				  CAP_OPT_NONE);
+				  CAP_OPT_NONE, NULL);
  		/* set PF_SUPERPRIV if it turns out we allow the low mmap */
  		if (ret == 0)
  			current-&gt;flags |= PF_SUPERPRIV;
diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 33028c098ef3..4871b2508a4a 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -229,9 +229,26 @@ static void dump_common_audit_data(struct audit_buffer *ab,
  	case LSM_AUDIT_DATA_IPC:
  		audit_log_format(ab, &quot; key=%d &quot;, a-&gt;u.ipc_id);
  		break;
-	case LSM_AUDIT_DATA_CAP:
-		audit_log_format(ab, &quot; capability=%d &quot;, a-&gt;u.cap);
+	case LSM_AUDIT_DATA_CAP: {
+		const struct inode *inode;
+
+		if (a-&gt;u.cap_struct.cad) {
+			switch (a-&gt;u.cap_struct.cad-&gt;type) {
+			case CAP_AUX_DATA_INODE: {
+				inode = a-&gt;u.cap_struct.cad-&gt;u.inode;
+
+				audit_log_format(ab, &quot; dev=&quot;);
+				audit_log_untrustedstring(ab,
+					inode-&gt;i_sb-&gt;s_id);
+				audit_log_format(ab, &quot; ino=%lu&quot;,
+					inode-&gt;i_ino);
+				break;
+			}
+			}
+		}
+		audit_log_format(ab, &quot; capability=%d &quot;, a-&gt;u.cap_struct.cap);
  		break;
+	}
  	case LSM_AUDIT_DATA_PATH: {
  		struct inode *inode;
</pre><tt>  
</tt><tt>diff --git a/security/safesetid/lsm.c b/security/safesetid/lsm.c
</tt><pre style="margin: 0em;">
index cecd38e2ac80..c74ed83e9501 100644
--- a/security/safesetid/lsm.c
+++ b/security/safesetid/lsm.c
@@ -80,7 +80,8 @@ static bool check_setuid_policy_hashtable_key_value(kuid_t parent,
  static int safesetid_security_capable(const struct cred *cred,
  				      struct user_namespace *ns,
  				      int cap,
-				      unsigned int opts)
+				      unsigned int opts,
+				      struct cap_aux_data *cad)
  {
  	if (cap == CAP_SETUID &amp;&amp;
  	    check_setuid_policy_hashtable_key(cred-&gt;uid)) {
diff --git a/security/security.c b/security/security.c
index 613a5c00e602..06274a7b9c4e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -691,9 +691,10 @@ int security_capset(struct cred *new, const struct cred *old,
  int security_capable(const struct cred *cred,
  		     struct user_namespace *ns,
  		     int cap,
-		     unsigned int opts)
+		     unsigned int opts,
+		     struct cap_aux_data *cad)
  {
-	return call_int_hook(capable, 0, cred, ns, cap, opts);
+	return call_int_hook(capable, 0, cred, ns, cap, opts, cad);
  }
</pre><tt>  
</tt><tt>  int security_quotactl(int cmds, int type, int id, struct super_block *sb)
</tt><pre style="margin: 0em;">
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index f77b314d0575..d6c699ed06be 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -1618,7 +1618,10 @@ static inline u32 signal_to_av(int sig)
</pre><tt>  
</tt><tt>  /* Check whether a task is allowed to use a capability. */
</tt><pre style="margin: 0em;">
  static int cred_has_capability(const struct cred *cred,
-			       int cap, unsigned int opts, bool initns)
+				int cap,
+				unsigned int opts,
+				bool initns,
+				struct cap_aux_data *cad)
  {
  	struct common_audit_data ad;
  	struct av_decision avd;
@@ -1628,7 +1631,8 @@ static int cred_has_capability(const struct cred *cred,
  	int rc;
</pre><tt>  
</tt><tt>  	ad.type = LSM_AUDIT_DATA_CAP;
</tt><pre style="margin: 0em;">
-	ad.u.cap = cap;
+	ad.u.cap_struct.cad = cad;
+	ad.u.cap_struct.cap = cap;
</pre><tt>  
</tt><tt>  	switch (CAP_TO_INDEX(cap)) {
</tt><pre style="margin: 0em;">
  	case 0:
@@ -2165,9 +2169,9 @@ static int selinux_capset(struct cred *new, const struct cred *old,
   */
</pre><tt>  
</tt><tt>  static int selinux_capable(const struct cred *cred, struct user_namespace *ns,
</tt><pre style="margin: 0em;">
-			   int cap, unsigned int opts)
+			   int cap, unsigned int opts, struct cap_aux_data *cad)
  {
-	return cred_has_capability(cred, cap, opts, ns == &amp;init_user_ns);
+	return cred_has_capability(cred, cap, opts, ns == &amp;init_user_ns, cad);
  }
</pre><tt>  
</tt><tt>  static int selinux_quotactl(int cmds, int type, int id, struct super_block *sb)
</tt><pre style="margin: 0em;">
@@ -2241,7 +2245,7 @@ static int selinux_vm_enough_memory(struct mm_struct *mm, long pages)
  	int rc, cap_sys_admin = 0;
</pre><tt>  
</tt><tt>  	rc = cred_has_capability(current_cred(), CAP_SYS_ADMIN,
</tt><pre style="margin: 0em;">
-				 CAP_OPT_NOAUDIT, true);
+				 CAP_OPT_NOAUDIT, true, NULL);
  	if (rc == 0)
  		cap_sys_admin = 1;
</pre><tt>  
</tt><tt>@@ -3101,9 +3105,9 @@ static bool has_cap_mac_admin(bool audit)
</tt><pre style="margin: 0em;">
  	const struct cred *cred = current_cred();
  	unsigned int opts = audit ? CAP_OPT_NONE : CAP_OPT_NOAUDIT;
</pre><tt>  
</tt><tt>-	if (cap_capable(cred, &amp;init_user_ns, CAP_MAC_ADMIN, opts))
</tt><pre style="margin: 0em;">
+	if (cap_capable(cred, &amp;init_user_ns, CAP_MAC_ADMIN, opts, NULL))
  		return false;
-	if (cred_has_capability(cred, CAP_MAC_ADMIN, opts, true))
+	if (cred_has_capability(cred, CAP_MAC_ADMIN, opts, true, NULL))
  		return false;
  	return true;
  }
@@ -3563,7 +3567,7 @@ static int selinux_file_ioctl(struct file *file, unsigned int cmd,
  	case KDSKBENT:
  	case KDSKBSENT:
  		error = cred_has_capability(cred, CAP_SYS_TTY_CONFIG,
-					    CAP_OPT_NONE, true);
+					    CAP_OPT_NONE, true, NULL);
  		break;
</pre><tt>  
</tt><tt>  	/* default case assumes that the command will go
</tt><pre style="margin: 0em;">
diff --git a/security/smack/smack_access.c b/security/smack/smack_access.c
index fe2ce3a65822..e961bfe8f00a 100644
--- a/security/smack/smack_access.c
+++ b/security/smack/smack_access.c
@@ -640,7 +640,7 @@ bool smack_privileged_cred(int cap, const struct cred *cred)
  	struct smack_known_list_elem *sklep;
  	int rc;
</pre><tt>  
</tt><tt>-	rc = cap_capable(cred, &amp;init_user_ns, cap, CAP_OPT_NONE);
</tt><pre style="margin: 0em;">
+	rc = cap_capable(cred, &amp;init_user_ns, cap, CAP_OPT_NONE, NULL);
  	if (rc)
  		return false;
</pre><tt>  
</tt></blockquote><pre style="margin: 0em;">

</pre></blockquote><pre style="margin: 0em;">



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="29896" href="msg29896.html">Re: [RFC PATCH] security, capability: pass object information to security_capable</a></strong>
<ul><li><em>From:</em> Casey Schaufler</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="29891" href="msg29891.html">[RFC PATCH] security,capability: pass object information to security_capable</a></strong>
<ul><li><em>From:</em> Nicholas Franck</li></ul></li>
<li><strong><a name="29893" href="msg29893.html">Re: [RFC PATCH] security,capability: pass object information to security_capable</a></strong>
<ul><li><em>From:</em> Casey Schaufler</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg29894.html">Re: [RFC PATCH] security, capability: pass object information to security_capable</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg29896.html">Re: [RFC PATCH] security, capability: pass object information to security_capable</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg29893.html">Re: [RFC PATCH] security,capability: pass object information to security_capable</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg29896.html">Re: [RFC PATCH] security, capability: pass object information to security_capable</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#29895"><strong>Date</strong></a></li>
<li><a href="index.html#29895"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-users/>[Fedora&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
