<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH] dev: add PCI information in recently kernel. -->
<!--X-From-R13: [nfnlbfuv [vmhzn &#60;zflf.zvmhznNtznvy.pbz> -->
<!--X-Date: Mon, 24 Sep 2018 06:05:14 &#45;0700 -->
<!--X-Message-Id: 20180924130431.4062&#45;1&#45;msys.mizuma@gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="[PATCH] dev: add PCI information in recently kernel. &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  [PATCH] dev: add PCI information in recently kernel.</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH] dev: add PCI information in recently kernel.</h1>
[<a href="msg07584.html">Date Prev</a>][<a href="msg07586.html">Date Next</a>][<a href="msg07584.html">Thread Prev</a>][<a href="msg07586.html">Thread Next</a>][<a href="maillist.html#07585">Date Index</a>][<a href="index.html#07585">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH] dev: add PCI information in recently kernel.</li>
<li><em>From</em>: Masayoshi Mizuma &lt;msys.mizuma@xxxxxxxxx&gt;</li>
<li><em>Date</em>: Mon, 24 Sep 2018 09:04:31 -0400</li>
<li><em>Cc</em>: Masayoshi Mizuma &lt;m.mizuma@xxxxxxxxxxxxxx&gt;</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>From: Masayoshi Mizuma &lt;m.mizuma@xxxxxxxxxxxxxx&gt;

dev -p supports to show the PCI information, however, it works
in old kernel only. This patch gets it available in recently kernel.
And also it will show the PCI BUS information. The BUS information
may be useful for investigation of PCI hotplug issue to track the
PCI bridge.

Signed-off-by: Masayoshi Mizuma &lt;m.mizuma@xxxxxxxxxxxxxx&gt;
---
 defs.h |  11 ++
 dev.c  | 333 +++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 338 insertions(+), 6 deletions(-)

diff --git a/defs.h b/defs.h
index d6492c5..e7d9bb2 100644
--- a/defs.h
+++ b/defs.h
@@ -1624,11 +1624,20 @@ struct offset_table {                    /* stash of commonly-used offsets */
 	long pci_dev_global_list;
 	long pci_dev_next;
 	long pci_dev_bus;
+	long pci_dev_dev;
 	long pci_dev_devfn;
 	long pci_dev_class;
 	long pci_dev_device;
+	long pci_dev_hdr_type;
+	long pci_dev_pcie_flags_reg;
 	long pci_dev_vendor;
 	long pci_bus_number;
+	long pci_bus_node;
+	long pci_bus_devices;
+	long pci_bus_dev;
+	long pci_bus_children;
+	long pci_bus_parent;
+	long pci_bus_self;
         long resource_entry_t_from;
         long resource_entry_t_num;
         long resource_entry_t_name; 
@@ -1832,6 +1841,7 @@ struct offset_table {                    /* stash of commonly-used offsets */
 	long class_private_devices;
 	long device_knode_class;
 	long device_node;
+	long device_kobj;
 	long gendisk_dev;
 	long gendisk_kobj;
 	long gendisk_part0;
@@ -1841,6 +1851,7 @@ struct offset_table {                    /* stash of commonly-used offsets */
 	long klist_node_n_klist;
 	long klist_node_n_node;
 	long kobject_entry;
+	long kobject_name;
 	long kset_list;
 	long request_list_count;
 	long request_queue_in_flight;
diff --git a/dev.c b/dev.c
index 3db898a..7ce2422 100644
--- a/dev.c
+++ b/dev.c
@@ -24,6 +24,7 @@ static void dump_blkdevs_v3(ulong);
 static ulong search_cdev_map_probes(char *, int, int, ulong *);
 static ulong search_bdev_map_probes(char *, int, int, ulong *);
 static void do_pci(void); 
+static void do_pci2(void);
 static void do_io(void);
 static void do_resource_list(ulong, char *, int);
 
@@ -51,11 +52,23 @@ dev_init(void)
         MEMBER_OFFSET_INIT(pci_dev_global_list, &quot;pci_dev&quot;, &quot;global_list&quot;);
         MEMBER_OFFSET_INIT(pci_dev_next, &quot;pci_dev&quot;, &quot;next&quot;);
         MEMBER_OFFSET_INIT(pci_dev_bus, &quot;pci_dev&quot;, &quot;bus&quot;);
+	MEMBER_OFFSET_INIT(pci_dev_dev, &quot;pci_dev&quot;, &quot;dev&quot;);
         MEMBER_OFFSET_INIT(pci_dev_devfn, &quot;pci_dev&quot;, &quot;devfn&quot;);
         MEMBER_OFFSET_INIT(pci_dev_class, &quot;pci_dev&quot;, &quot;class&quot;);
         MEMBER_OFFSET_INIT(pci_dev_device, &quot;pci_dev&quot;, &quot;device&quot;);
+	MEMBER_OFFSET_INIT(pci_dev_hdr_type, &quot;pci_dev&quot;, &quot;hdr_type&quot;);
+	MEMBER_OFFSET_INIT(pci_dev_pcie_flags_reg, &quot;pci_dev&quot;, &quot;pcie_flags_reg&quot;);
         MEMBER_OFFSET_INIT(pci_dev_vendor, &quot;pci_dev&quot;, &quot;vendor&quot;);
 	MEMBER_OFFSET_INIT(pci_bus_number, &quot;pci_bus&quot;, &quot;number&quot;);
+	MEMBER_OFFSET_INIT(pci_bus_node, &quot;pci_bus&quot;, &quot;node&quot;);
+	MEMBER_OFFSET_INIT(pci_bus_devices, &quot;pci_bus&quot;, &quot;devices&quot;);
+	MEMBER_OFFSET_INIT(pci_bus_dev, &quot;pci_bus&quot;, &quot;dev&quot;);
+	MEMBER_OFFSET_INIT(pci_bus_children, &quot;pci_bus&quot;, &quot;children&quot;);
+	MEMBER_OFFSET_INIT(pci_bus_parent, &quot;pci_bus&quot;, &quot;parent&quot;);
+	MEMBER_OFFSET_INIT(pci_bus_self, &quot;pci_bus&quot;, &quot;self&quot;);
+
+	MEMBER_OFFSET_INIT(device_kobj, &quot;device&quot;, &quot;kobj&quot;);
+	MEMBER_OFFSET_INIT(kobject_name, &quot;kobject&quot;, &quot;name&quot;);
 
         STRUCT_SIZE_INIT(resource, &quot;resource&quot;);
 	if ((VALID_STRUCT(resource) &amp;&amp; symbol_exists(&quot;do_resource_list&quot;)) ||
@@ -114,10 +127,14 @@ cmd_dev(void)
 			return;
 
 		case 'p':
-			if (machine_type(&quot;S390X&quot;) ||
-			    (THIS_KERNEL_VERSION &gt;= LINUX(2,6,26)))
+			if (machine_type(&quot;S390X&quot;))
+				option_not_supported(c);
+			if (symbol_exists(&quot;pci_devices&quot;))
+				do_pci();
+			else if (symbol_exists(&quot;pci_root_buses&quot;))
+				do_pci2();
+			else
 				option_not_supported(c);
-			do_pci();
 			return;
 
                 default:
@@ -2217,6 +2234,313 @@ do_resource_list(ulong first_entry, char *resource_buf, int size)
 
 #endif /* USE_2_2_17_PCI_H */
 
+#define PCI_EXP_FLAGS_TYPE      0x00f0  /* Device/Port type */
+#define  PCI_EXP_TYPE_ENDPOINT  0x0     /* Express Endpoint */
+#define  PCI_EXP_TYPE_LEG_END   0x1     /* Legacy Endpoint */
+#define  PCI_EXP_TYPE_ROOT_PORT 0x4     /* Root Port */
+#define  PCI_EXP_TYPE_UPSTREAM  0x5     /* Upstream Port */
+#define  PCI_EXP_TYPE_DOWNSTREAM 0x6    /* Downstream Port */
+#define  PCI_EXP_TYPE_PCI_BRIDGE 0x7    /* PCIe to PCI/PCI-X Bridge */
+#define  PCI_EXP_TYPE_PCIE_BRIDGE 0x8   /* PCI/PCI-X to PCIe Bridge */
+#define  PCI_EXP_TYPE_RC_END    0x9     /* Root Complex Integrated Endpoint */
+#define  PCI_EXP_TYPE_RC_EC     0xa     /* Root Complex Event Collector */
+
+static void
+fill_dev_name(ulong pci_dev, char *name)
+{
+	ulong kobj, value;
+
+	memset(name, 0, sizeof(*name) * BUFSIZE);
+
+	kobj = pci_dev + OFFSET(pci_dev_dev) + OFFSET(device_kobj);
+
+	readmem(kobj + OFFSET(kobject_name),
+		KVADDR, &amp;value, sizeof(void *), &quot;kobject name&quot;,
+		FAULT_ON_ERROR);
+
+	read_string(value, name, BUFSIZE-1);
+}
+
+static void
+fill_bus_name(ulong pci_bus, char *name)
+{
+	ulong kobj, value;
+
+	memset(name, 0, sizeof(*name) * BUFSIZE);
+
+	kobj = pci_bus + OFFSET(pci_bus_dev) + OFFSET(device_kobj);
+
+	readmem(kobj + OFFSET(kobject_name),
+		KVADDR, &amp;value, sizeof(void *), &quot;kobject name&quot;,
+		FAULT_ON_ERROR);
+
+	read_string(value, name, BUFSIZE-1);
+}
+
+static void
+fill_dev_id(ulong pci_dev, char *id)
+{
+	unsigned short device, vendor;
+
+	memset(id, 0, sizeof(*id) * BUFSIZE);
+
+	readmem(pci_dev + OFFSET(pci_dev_device),
+		KVADDR, &amp;device, sizeof(short), &quot;pci dev device&quot;,
+		FAULT_ON_ERROR);
+	readmem(pci_dev + OFFSET(pci_dev_vendor), KVADDR,
+		&amp;vendor, sizeof(short), &quot;pci dev vendor&quot;, FAULT_ON_ERROR);
+
+	sprintf(id, &quot;%x:%x&quot;, vendor, device);
+}
+
+static void
+fill_dev_class(ulong pci_dev, char *c)
+{
+	unsigned int class;
+
+	memset(c, 0, sizeof(*c) * BUFSIZE);
+	readmem(pci_dev + OFFSET(pci_dev_class), KVADDR,
+		&amp;class, sizeof(int), &quot;pci class&quot;, FAULT_ON_ERROR);
+
+	class &gt;&gt;= 8;
+
+	sprintf(c, &quot;%04x&quot;, class);
+}
+
+static int
+pci_pcie_type(ulong cap)
+{
+	return (cap &amp; PCI_EXP_FLAGS_TYPE) &gt;&gt; 4;
+}
+
+static int
+pci_is_bridge(unsigned char hdr_type)
+{
+	return hdr_type == PCI_HEADER_TYPE_BRIDGE ||
+		hdr_type == PCI_HEADER_TYPE_CARDBUS;
+}
+
+static void
+fill_pcie_type(ulong pcidev, char *t)
+{
+	int type, bufidx = 0;
+	unsigned short pciecap;
+	unsigned char hdr_type;
+
+	memset(t, 0, sizeof(*t) * BUFSIZE);
+
+	readmem(pcidev + OFFSET(pci_dev_hdr_type), KVADDR, &amp;hdr_type,
+		sizeof(char), &quot;pci dev hdr_type&quot;, FAULT_ON_ERROR);
+
+	if (!VALID_MEMBER(pci_dev_pcie_flags_reg))
+		goto bridge_chk;
+
+	readmem(pcidev + OFFSET(pci_dev_pcie_flags_reg), KVADDR, &amp;pciecap,
+		sizeof(unsigned short), &quot;pci dev pcie_flags_reg&quot;, FAULT_ON_ERROR);
+
+	type = pci_pcie_type(pciecap);
+
+	if (type == PCI_EXP_TYPE_ENDPOINT)
+		bufidx = sprintf(t, &quot;ENDPOINT&quot;);
+	else if (type == PCI_EXP_TYPE_LEG_END)
+		bufidx = sprintf(t, &quot;LEG_END&quot;);
+	else if (type == PCI_EXP_TYPE_ROOT_PORT)
+		bufidx = sprintf(t, &quot;ROOT_PORT&quot;);
+	else if (type == PCI_EXP_TYPE_UPSTREAM)
+		bufidx = sprintf(t, &quot;UPSTREAM&quot;);
+	else if (type == PCI_EXP_TYPE_DOWNSTREAM)
+		bufidx = sprintf(t, &quot;DOWNSTREAM&quot;);
+	else if (type == PCI_EXP_TYPE_PCI_BRIDGE)
+		bufidx = sprintf(t, &quot;PCI_BRIDGE&quot;);
+	else if (type == PCI_EXP_TYPE_PCIE_BRIDGE)
+		bufidx = sprintf(t, &quot;PCIE_BRIDGE&quot;);
+	else if (type == PCI_EXP_TYPE_RC_END)
+		bufidx = sprintf(t, &quot;RC_END&quot;);
+	else if (type == PCI_EXP_TYPE_RC_EC)
+		bufidx = sprintf(t, &quot;RC_EC&quot;);
+
+bridge_chk:
+	if (pci_is_bridge(hdr_type))
+		sprintf(t + bufidx, &quot; [BRIDGE]&quot;);
+}
+
+static void
+walk_devices(ulong pci_bus)
+{
+	struct list_data list_data, *ld;
+	int devcnt, i;
+	ulong *devlist, self;
+	char name[BUFSIZE], class[BUFSIZE], id[BUFSIZE], type[BUFSIZE];
+	char pcidev_hdr[BUFSIZE];
+	char buf1[BUFSIZE];
+	char buf2[BUFSIZE];
+	char buf3[BUFSIZE];
+	char buf4[BUFSIZE];
+	char buf5[BUFSIZE];
+
+	ld = &amp;list_data;
+
+	BZERO(ld, sizeof(struct list_data));
+
+	readmem(pci_bus + OFFSET(pci_bus_devices), KVADDR,
+		&amp;ld-&gt;start, sizeof(void *), &quot;pci bus devices&quot;,
+		FAULT_ON_ERROR);
+
+	if (VALID_MEMBER(pci_dev_pcie_flags_reg))
+		snprintf(pcidev_hdr, sizeof(pcidev_hdr), &quot;%s %s %s %s %s\n&quot;,
+			mkstring(buf1, VADDR_PRLEN, CENTER, &quot;PCI DEV&quot;),
+			mkstring(buf2, strlen(&quot;0000:00:00.0&quot;), CENTER, &quot;DO:BU:SL.FN&quot;),
+			mkstring(buf3, strlen(&quot;0000&quot;) + 2, CENTER, &quot;CLASS&quot;),
+			mkstring(buf4, strlen(&quot;0000:0000&quot;), CENTER, &quot;PCI_ID&quot;),
+			mkstring(buf5, 10, CENTER, &quot;TYPE&quot;));
+	else
+		snprintf(pcidev_hdr, sizeof(pcidev_hdr), &quot;%s %s %s %s\n&quot;,
+			mkstring(buf1, VADDR_PRLEN, CENTER, &quot;PCI DEV&quot;),
+			mkstring(buf2, strlen(&quot;0000:00:00.0&quot;), CENTER, &quot;DO:BU:SL.FN&quot;),
+			mkstring(buf3, strlen(&quot;0000&quot;) + 2, CENTER, &quot;CLASS&quot;),
+			mkstring(buf4, strlen(&quot;0000:0000&quot;), CENTER, &quot;PCI_ID&quot;));
+
+	fprintf(fp, &quot;  %s&quot;, pcidev_hdr);
+
+	readmem(pci_bus + OFFSET(pci_bus_self), KVADDR, &amp;self,
+		sizeof(void *), &quot;pci bus self&quot;, FAULT_ON_ERROR);
+	if (self) {
+		fill_dev_name(self, name);
+		fill_dev_class(self, class);
+		fill_dev_id(self, id);
+		fill_pcie_type(self, type);
+		fprintf(fp, &quot;  %s %s %s %s %s\n&quot;,
+			mkstring(buf1, VADDR_PRLEN, LJUST|LONG_HEX,
+			MKSTR(self)),
+			mkstring(buf2, strlen(&quot;0000:00:00.0&quot;), CENTER, name),
+			mkstring(buf3, strlen(&quot;0000&quot;) + 2, CENTER, class),
+			mkstring(buf4, strlen(&quot;0000:0000&quot;), CENTER, id),
+			mkstring(buf5, 10, CENTER, type));
+	}
+
+	if (ld-&gt;start == (pci_bus + OFFSET(pci_bus_devices)))
+		return;
+
+	ld-&gt;end = pci_bus + OFFSET(pci_bus_devices);
+	hq_open();
+	devcnt = do_list(ld);
+	devlist = (ulong *)GETBUF(devcnt * sizeof(ulong));
+	devcnt = retrieve_list(devlist, devcnt);
+	hq_close();
+
+	for (i = 0; i &lt; devcnt; i++) {
+		fill_dev_name(devlist[i], name);
+		fill_dev_class(devlist[i], class);
+		fill_dev_id(devlist[i], id);
+		fill_pcie_type(devlist[i], type);
+		fprintf(fp, &quot;  %s %s %s %s %s\n&quot;,
+			mkstring(buf1, VADDR_PRLEN, LJUST|LONG_HEX,
+			MKSTR(devlist[i])),
+			mkstring(buf2, strlen(&quot;0000:00:00.0&quot;), CENTER, name),
+			mkstring(buf3, strlen(&quot;0000&quot;) + 2, CENTER, class),
+			mkstring(buf4, strlen(&quot;0000:0000&quot;), CENTER, id),
+			mkstring(buf5, 10, CENTER, type));
+	}
+	FREEBUF(devlist);
+}
+
+static void
+walk_buses(ulong pci_bus)
+{
+	struct list_data list_data, *ld;
+	int buscnt, i;
+	ulong *buslist, parent;
+	char pcibus_hdr[BUFSIZE];
+	char buf1[BUFSIZE];
+	char buf2[BUFSIZE];
+
+	ld = &amp;list_data;
+
+	BZERO(ld, sizeof(struct list_data));
+
+	readmem(pci_bus + OFFSET(pci_bus_children), KVADDR,
+		&amp;ld-&gt;start, sizeof(void *), &quot;pci bus children&quot;,
+		FAULT_ON_ERROR);
+
+	if (ld-&gt;start == (pci_bus + OFFSET(pci_bus_children)))
+		return;
+
+	ld-&gt;end = pci_bus + OFFSET(pci_bus_children);
+	hq_open();
+	buscnt = do_list(ld);
+	buslist = (ulong *)GETBUF(buscnt * sizeof(ulong));
+	buscnt = retrieve_list(buslist, buscnt);
+	hq_close();
+
+	snprintf(pcibus_hdr, sizeof(pcibus_hdr), &quot;%s %s\n&quot;,
+		mkstring(buf1, VADDR_PRLEN, CENTER, &quot;PCI BUS&quot;),
+		mkstring(buf2, VADDR_PRLEN, CENTER, &quot;PARENT BUS&quot;));
+
+	for (i = 0; i &lt; buscnt; i++) {
+		readmem(buslist[i] + OFFSET(pci_bus_parent), KVADDR, &amp;parent,
+			sizeof(void *), &quot;pci bus parent&quot;, FAULT_ON_ERROR);
+
+		fprintf(fp, &quot;  %s&quot;, pcibus_hdr);
+
+		fprintf(fp, &quot;  %s %s\n&quot;,
+			mkstring(buf1, VADDR_PRLEN, LJUST|LONG_HEX,
+			MKSTR(buslist[i])),
+			mkstring(buf2, VADDR_PRLEN, LJUST|LONG_HEX,
+			MKSTR(parent)));
+		walk_devices(buslist[i]);
+		fprintf(fp, &quot;\n&quot;);
+		walk_buses(buslist[i]);
+	}
+	FREEBUF(buslist);
+}
+
+static void
+do_pci2(void)
+{
+	struct list_data list_data, *ld;
+	int rootbuscnt, i;
+	ulong *rootbuslist;
+	unsigned long pci_root_bus_addr = symbol_value(&quot;pci_root_buses&quot;);
+	char name[BUFSIZE];
+	char pcirootbus_hdr[BUFSIZE];
+	char buf1[BUFSIZE];
+	char buf2[BUFSIZE];
+
+	ld = &amp;list_data;
+	BZERO(ld, sizeof(struct list_data));
+
+	get_symbol_data(&quot;pci_root_buses&quot;, sizeof(void *), &amp;ld-&gt;start);
+
+	if (ld-&gt;start == pci_root_bus_addr)
+		error(FATAL, &quot;no PCI devices found on this system.\n&quot;);
+
+	ld-&gt;end = pci_root_bus_addr;
+
+	hq_open();
+	rootbuscnt = do_list(ld);
+	rootbuslist = (ulong *)GETBUF(rootbuscnt * sizeof(ulong));
+	rootbuscnt = retrieve_list(rootbuslist, rootbuscnt);
+	hq_close();
+
+	snprintf(pcirootbus_hdr, sizeof(pcirootbus_hdr), &quot;%s %s\n&quot;,
+			mkstring(buf1, VADDR_PRLEN, CENTER, &quot;ROOT BUS&quot;),
+			mkstring(buf2, strlen(&quot;0000:00&quot;), CENTER, &quot;BUSNAME&quot;));
+
+	for (i = 0; i &lt; rootbuscnt; i++) {
+		fprintf(fp, &quot;%s&quot;, pcirootbus_hdr);
+		fill_bus_name(rootbuslist[i], name);
+		fprintf(fp, &quot;%s %s\n&quot;,
+			mkstring(buf1, VADDR_PRLEN, LJUST|LONG_HEX,
+			MKSTR(rootbuslist[i])),
+			mkstring(buf2, strlen(&quot;0000:00&quot;), CENTER, name));
+		 walk_devices(rootbuslist[i]);
+		 walk_buses(rootbuslist[i]);
+
+		fprintf(fp, &quot;\n&quot;);
+	}
+	FREEBUF(rootbuslist);
+}
+
 static void
 do_pci(void)
 {
@@ -2230,9 +2554,6 @@ do_pci(void)
 	char 		  buf2[BUFSIZE];
 	char 		  buf3[BUFSIZE];
 
-	if (!symbol_exists(&quot;pci_devices&quot;))
-		error(FATAL, &quot;no PCI devices found on this system.\n&quot;);
-
 	BZERO(&amp;pcilist_data, sizeof(struct list_data));
 
 	if (VALID_MEMBER(pci_dev_global_list)) {
-- 
2.19.0

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="07586" href="msg07586.html">Re:  [PATCH] dev: add PCI information in recently kernel.</a></strong>
<ul><li><em>From:</em> Dave Anderson</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07584.html">[ANNOUNCE] crash version 7.2.4 is available</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07586.html">Re:  [PATCH] dev: add PCI information in recently kernel.</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07584.html">[ANNOUNCE] crash version 7.2.4 is available</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07586.html">Re:  [PATCH] dev: add PCI information in recently kernel.</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07585"><strong>Date</strong></a></li>
<li><a href="index.html#07585"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
