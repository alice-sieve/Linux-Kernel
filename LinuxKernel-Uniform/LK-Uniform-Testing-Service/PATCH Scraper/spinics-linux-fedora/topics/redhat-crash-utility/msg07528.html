<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH 5/6] Implement R. P. Brent's algorithm for	loop detection for 'list' command. -->
<!--X-From-R13: Rnir Ilfbpunafxv &#60;qjlfbpunNerqung.pbz> -->
<!--X-Date: Tue, 10 Jul 2018 15:24:50 &#45;0700 -->
<!--X-Message-Id: 1531261479&#45;23412&#45;6&#45;git&#45;send&#45;email&#45;dwysocha@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 1531261479&#45;23412&#45;1&#45;git&#45;send&#45;email&#45;dwysocha@redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="[PATCH 5/6] Implement R. P. Brent's algorithm for	loop detection for 'list' command. &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  [PATCH 5/6] Implement R. P. Brent's algorithm for	loop detection for 'list' command.</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH 5/6] Implement R. P. Brent's algorithm for	loop detection for 'list' command.</h1>
[<a href="msg07531.html">Date Prev</a>][<a href="msg07530.html">Date Next</a>][<a href="msg07531.html">Thread Prev</a>][<a href="msg07530.html">Thread Next</a>][<a href="maillist.html#07528">Date Index</a>][<a href="index.html#07528">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH 5/6] Implement R. P. Brent's algorithm for	loop detection for 'list' command.</li>
<li><em>From</em>: Dave Wysochanski &lt;dwysocha@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Tue, 10 Jul 2018 18:24:38 -0400</li>
<li><em>In-reply-to</em>: &lt;<a href="msg07525.html">1531261479-23412-1-git-send-email-dwysocha@redhat.com</a>&gt;</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>The existing &quot;list&quot; command uses a hash table to detect duplicate items as it
traverses the list.  The hash table approach has worked well for many years.
However, with increasing memory sizes and list sizes, the overhead of the
hash table can be substantial, often leading to commands running for a very
long time.  For large lists, we have found that the existing hash based approach
may slow the system to a crawl and possibly never complete.  You can turn off
the hash with &quot;hash off&quot; but then there is no loop detection.  In this case,
loop detection must be done manually after dumping the list to disk or some
other method.  This patch is an implementation of the cycle detection algorithm
from R. P. Brent as an alternative algorithm for the &quot;list&quot; command.  The
algorithm both avoids the overhead of the hash table and yet is able to detect
a loop.  In addition, further loop characteristics are printed, such as the
distance to the start of the loop as well as the loop length.

The algorithm from R. P. Brent uses only a tiny amount of memory (two pointers)
and adds extremely minimal overhead if no loop is detected.  If a loop is detected
it adds additional overhead of advancing through the list to find the start of
the loop.  While this overhead may be non-trivial for large lists, the cost of
each list advance should be a fixed cost and compares favorably to an ever
increasing cost of a list advance with a hash table.  Thus in all instances,
the algorithm is superior to a hash table approach for list traversal.  The
algorithm is divided into two phases, detection of a loop, and detection of
the loop start (first duplicate).

The first phase of the algorithm adds almost no overhead to an existing list
traversal.  To detect a loop a second pointer is added which follows the first
list traversal pointer periodically according to an increasing power of two
length.  Eventually, if there is a loop, this increasing power of two will be
larger than the loop size, and the list traversal pointer will eventually be
equal to the second pointer that is periodically moved.  If the list traversal
pointer never reaches this second pointer, there is no loop.

If a loop is detected, the second phase of the algorithm is entered, and this
adds overhead.  First a couple points of explanation and a diagram of a list
with a loop example:

 non_loop_len = 5

+---&gt;---&gt;---&gt;---^---&gt;
                |   | loop_len = 4
                |   |
                &lt;---v

In the above diagram, we have two segments: a) a non_loop segment (or
&quot;non-perodic&quot; segment), and b) a loop segment (or &quot;periodic&quot; segment).
As a side note, in the literature, these lengths are often given
two specific greek letters with the length of the loop segment referred
to as lambda, while the non-loop segment length is referred to as mu.
In any case, the important thing to understand is there are two distinct
segments now, with two different lengths.

Once we have exited from Brent's first phase, the loop length is known.
Why is that?  For the first phase to have exited, the traversal pointer had
to have met the following pointer.  And for that to happen, the traversal
pointer had to have been stationary for the length of the loop, and the
power of two was greater than the loop length.

When the loop is detected, the following message is printed:
list loop detected, loop length: 4

The second phase of the loop is entered, with the purpose of identifying
the non-loop length as well as the point at which the loop and the non-loop
intersect (this is the first duplicate).  To obtain these objectives, we
note the following relation of steps required to reach the intersection:

itersection = non_loop_len + N*loop_len
for any integer N where N &gt;= 0

The second phase does the following:
1. Reset the first and second pointer to the start
2. Advance the second pointer loop_len steps
3. Advance both pointers until they meet, saving the step count

The second pointer will have gone both non_loop_len + loop_len steps to
arrive at the intersection, and the first pointer will have gone
non_loop_len steps to arrive at the intersection.  When the second phase
exits (both pointers are equal) we have the non_loop length.

When the loop exits, the following message is printed:
list loop length from start to loop: 5
duplicate list entry: ffff8abdf3bb5d00

An example of the full output of this new algorithm when a list loop is
detected is as follows:
crash&gt; list -H 0xffff8ac03c81fc28
ffff8abdf38b7d00
ffff8abdf38b7ac0
ffff8abdf38b7f40
ffff8abe0edb4b00
ffff8abdf3bb5d00
ffff8abdf3bb5b80
ffff8abdf3bb5640
ffff8abe0e92b100
ffff8abe0e92ad40
ffff8abdf3bb5d00
ffff8abdf3bb5b80
ffff8abdf3bb5640
list: loop detected, loop length: 5
list: length from start to loop: 4
list: duplicate list entry: ffff8abdf3bb5d00
crash&gt;

This compares with existing crash output as follows:
crash&gt; list -H 0xffff8ac03c81fc28
ffff8abdf38b7d00
ffff8abdf38b7ac0
ffff8abdf38b7f40
ffff8abe0edb4b00
ffff8abdf3bb5d00
ffff8abdf3bb5b80
ffff8abdf3bb5640
ffff8abe0e92b100
ffff8abe0e92ad40
ffff8abdf3bb5d00

list: duplicate list entry: ffff8abdf3bb5d00
crash&gt;

Signed-off-by: Dave Wysochanski &lt;dwysocha@xxxxxxxxxx&gt;
---
 tools.c | 68 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 64 insertions(+), 4 deletions(-)

diff --git a/tools.c b/tools.c
index 0d4b8e5..ba525a8 100644
--- a/tools.c
+++ b/tools.c
@@ -3949,6 +3949,21 @@ static int do_list_no_hash_readmem(struct list_data *ld, ulong *next_ptr,
 	return 0;
 }
 
+ulong brent_x; /* tortoise */
+ulong brent_y; /* hare */
+ulong brent_r; /* power */
+ulong brent_lambda; /* loop length */
+ulong brent_mu; /* distance to start of loop */
+ulong brent_loop_detect;
+ulong brent_loop_exit;
+/*
+ * 'ptr': representative of x or y; modified on return
+ */
+static int brent_f(ulong *ptr, struct list_data *ld, ulong readflag)
+{
+       return do_list_no_hash_readmem(ld, ptr, readflag);
+}
+
 /*
  * Similar to do_list() but without the hash_table or LIST_ALLOCATE.
  * Useful for the 'list' command and other callers needing faster list
@@ -3996,22 +4011,29 @@ do_list_no_hash(struct list_data *ld)
 			e[i] = fill_member_offsets(ld-&gt;structname[i]);
 	}
 
+	brent_loop_detect = brent_loop_exit = 0;
+	brent_lambda = 0;
+	brent_r = 2;
+	brent_x = brent_y = next;
+	ret = brent_f(&amp;brent_y, ld, readflag);
+	if (ret == -1)
+		return -1;
 	while (1) {
-		if (ld-&gt;flags &amp; VERBOSE) {
+		if (!brent_loop_detect &amp;&amp; ld-&gt;flags &amp; VERBOSE) {
 			fprintf(fp, &quot;%lx\n&quot;, next - ld-&gt;list_head_offset);
 			if (ld-&gt;structname) {
 				do_list_output_struct(ld, next, offset, radix, e);
 			}
 		}
 
-                if (next &amp;&amp; 0) { /* FIXME - duplicate detection */
+                if (next &amp;&amp; brent_loop_exit) {
 			if (ld-&gt;flags &amp;
 			    (RETURN_ON_DUPLICATE|RETURN_ON_LIST_ERROR)) {
 				error(INFO, &quot;\nduplicate list entry: %lx\n&quot;,
-					next);
+					brent_x);
 				return -1;
 			}
-                        error(FATAL, &quot;\nduplicate list entry: %lx\n&quot;, next);
+			error(FATAL, &quot;\nduplicate list entry: %lx\n&quot;, brent_x);
 		}
 
 		if ((searchfor == next) ||
@@ -4030,6 +4052,43 @@ do_list_no_hash(struct list_data *ld)
 		if (ret == -1)
 			return -1;
 
+		if (!brent_loop_detect) {
+			if (brent_x == brent_y) {
+				brent_loop_detect = 1;
+				error(INFO, &quot;loop detected, loop length: %lx\n&quot;, brent_lambda);
+				/* reset x and y to start; advance y loop length */
+				brent_mu = 0;
+				brent_x = brent_y = ld-&gt;start;
+				while (brent_lambda--) {
+					ret = brent_f(&amp;brent_y, ld, readflag);
+					if (ret == -1)
+						return -1;
+				}
+			} else {
+				if (brent_r == brent_lambda) {
+					brent_x = brent_y;
+					brent_r *= 2;
+					brent_lambda = 0;
+				}
+				brent_y = next;
+				brent_lambda++;
+			}
+		} else {
+			if (!brent_loop_exit &amp;&amp; brent_x == brent_y) {
+				brent_loop_exit = 1;
+				error(INFO, &quot;length from start to loop: %lx&quot;,
+					brent_mu);
+			} else {
+				ret = brent_f(&amp;brent_x, ld, readflag);
+				if (ret == -1)
+					return -1;
+				ret = brent_f(&amp;brent_y, ld, readflag);
+				if (ret == -1)
+					return -1;
+				brent_mu++;
+			}
+		}
+
 		if (next == 0) {
 			if (ld-&gt;flags &amp; LIST_HEAD_FORMAT) {
 				error(INFO, &quot;\ninvalid list entry: 0\n&quot;);
@@ -4037,6 +4096,7 @@ do_list_no_hash(struct list_data *ld)
 			}
 			if (CRASHDEBUG(1))
 				console(&quot;do_list end: next:%lx\n&quot;, next);
+
 			break;
 		}
 
-- 
1.8.3.1

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="07525" href="msg07525.html">[PATCH 0/5] Add Brent algorithm as an option for	the 'list' command</a></strong>
<ul><li><em>From:</em> Dave Wysochanski</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07531.html">[PATCH 3/6] do_list_no_hash: factor out structure	output into static function</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07530.html">[PATCH 6/6] Add a '-B' flag to the list command to	call the brent algorithm.</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07531.html">[PATCH 3/6] do_list_no_hash: factor out structure	output into static function</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07530.html">[PATCH 6/6] Add a '-B' flag to the list command to	call the brent algorithm.</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07528"><strong>Date</strong></a></li>
<li><a href="index.html#07528"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
