<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode -->
<!--X-From-R13: Rnir Oaqrefba &#60;naqrefbaNerqung.pbz> -->
<!--X-Date: Fri, 21 Jun 2019 08:46:03 &#45;0700 -->
<!--X-Message-Id: 105587844.30749385.1561131929269.JavaMail.zimbra@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190620235733.2489&#45;1&#45;atomlin@redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</h1>
[<a href="msg07790.html">Date Prev</a>][<a href="msg07792.html">Date Next</a>][<a href="msg07787.html">Thread Prev</a>][<a href="msg07792.html">Thread Next</a>][<a href="maillist.html#07791">Date Index</a>][<a href="index.html#07791">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</li>
<li><em>From</em>: Dave Anderson &lt;anderson@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Fri, 21 Jun 2019 11:45:29 -0400 (EDT)</li>
<li><em>In-reply-to</em>: &lt;<a href="msg07787.html">20190620235733.2489-1-atomlin@redhat.com</a>&gt;</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>

----- Original Message -----
&gt;<i> Changes since v1:</i>
&gt;<i> </i>
&gt;<i>  - Update 'dis' help page</i>
&gt;<i>  - Resolve patch fuzz</i>
&gt;<i> </i>
&gt;<i> </i>
&gt;<i> The purpose of this patch is to add support for a count value in reverse</i>
&gt;<i> or forward mode, during disassembly:</i>
&gt;<i> </i>
&gt;<i> 	'dis [-r|-f] [symbol|address] [count]'</i>
&gt;<i> </i>
&gt;<i> For example:</i>
&gt;<i> </i>
&gt;<i>   crash&gt; dis -f list_del+0x16 4</i>
&gt;<i>   0xffffffff812b3346 &lt;list_del+22&gt;:       jne    0xffffffff812b3381  &lt;list_del+81&gt;</i>
&gt;<i>   0xffffffff812b3348 &lt;list_del+24&gt;:       mov    (%rbx),%rax</i>
&gt;<i>   0xffffffff812b334b &lt;list_del+27&gt;:       mov    0x8(%rax),%r8</i>
&gt;<i>   0xffffffff812b334f &lt;list_del+31&gt;:       cmp    %r8,%rbx</i>
&gt;<i> </i>
&gt;<i>   crash&gt; dis -r list_del+0x16 4</i>
&gt;<i>   0xffffffff812b333c &lt;list_del+12&gt;:       mov    0x8(%rdi),%rax</i>
&gt;<i>   0xffffffff812b3340 &lt;list_del+16&gt;:       mov    (%rax),%r8</i>
&gt;<i>   0xffffffff812b3343 &lt;list_del+19&gt;:       cmp    %r8,%rdi</i>
&gt;<i>   0xffffffff812b3346 &lt;list_del+22&gt;:       jne    0xffffffff812b3381  &lt;list_del+81&gt;</i>



Hmmm, I don't understand why, but I still see the fuzz on x86_64, but more importantly,
your patch fails to compile on the ppc64 architecture.

Note that during the initial build, the gdb-7.6.tar.gz file is un-tarred,
and then 3 patches are applied to it prior to the first &quot;make&quot;:

  gdb-7.6.patch
  gdb-7.6-ppc64le-support.patch
  gdb-7.6-proc_service.h.patch

The gdb-7.6-ppc64le-support.patch is a 86-file patch that changes
several files that are also modified by the generic gdb-7.6.patch, 
one of them being printcmd.c.  It *only* gets applied on ppc64le hosts
or if you run &quot;make target=ppc64&quot;.  

If I check out a fresh git tree, apply your patch, and do a &quot;make&quot;
on a ppc64le host, the build fails.  The initial build log shows that 
the gdb-7.6.patch does not apply cleanly:

  if [ -f gdb-7.6.patch ] &amp;&amp; [ -s gdb-7.6.patch ]; then \
          patch -p0 &lt; gdb-7.6.patch; cp gdb-7.6.patch gdb-7.6; fi
  ... [ cut ] ...
  patching file gdb-7.6/gdb/printcmd.c
  Hunk #2 succeeded at 800 with fuzz 2.
  Hunk #5 succeeded at 2187 with fuzz 1 (offset 995 lines).

And then when the gdb-7.6-ppc64le-support.patch gets applied after that, 
it's not a clean application as it normally is:

  if [ &quot;ppc64le&quot; = &quot;ppc64le&quot; ] &amp;&amp; [ -f gdb-7.6-ppc64le-support.patch ]; then \
          patch -d gdb-7.6 -p1 -F0 &lt; gdb-7.6-ppc64le-support.patch ; \
  fi
  ... [ cut ] ...
  patching file gdb/printcmd.c
  Hunk #1 succeeded at 673 (offset 5 lines).
  Hunk #2 succeeded at 1435 (offset 269 lines).

And ultimately it fails to compile printcmd.c:

-g -O2 -m64 -fPIC -mminimal-toc  -I. -I. -I./common -I./config -DLOCALEDIR=&quot;\&quot;/usr/local/share/locale\&quot;&quot; -DCRASH_MERGE -DHAVE_CONFIG_H -I./../include/opcode -I./../opcodes/.. -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../libdecnumber -I./../libdecnumber  -I./gnulib/import -Ibuild-gnulib/import   -DTUI=1  -Wall -Wdeclaration-after-statement -Wpointer-arith -Wformat-nonliteral -Wno-pointer-sign -Wno-unused -Wunused-value -Wunused-function -Wno-switch -Wno-char-subscripts -Wmissing-prototypes -Wdeclaration-after-statement -Wempty-body  `echo &quot; -Wall -Wdeclaration-after-statement -Wpointer-arith -Wformat-nonliteral -Wno-pointer-sign -Wno-unused -Wunused-value -Wunused-function -Wno-switch -Wno-char-subscripts -Wmissing-prototypes -Wdeclaration-after-statement -Wempty-body &quot; | sed &quot;s/ -Wformat-nonliteral / -Wno-format-nonliteral /g&quot;` \
        -c -o printcmd.o -MT printcmd.o -MMD -MP -MF .deps/printcmd.Tpo ./printcmd.c
./printcmd.c: In function &#x2018;display_info&#x2019;:
./printcmd.c:2192:7: error: &#x2018;need_to_update_next_address&#x2019; undeclared (first use in this function); did you mean &#x2018;set_next_address&#x2019;?
   if (need_to_update_next_address)
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
       set_next_address
./printcmd.c:2192:7: note: each undeclared identifier is reported only once for each function it appears in
./printcmd.c:2193:20: error: &#x2018;addr_rewound&#x2019; undeclared (first use in this function)
     next_address = addr_rewound;
                    ^~~~~~~~~~~~
make[4]: *** [Makefile:1566: printcmd.o] Error 1
make[3]: *** [Makefile:8265: all-gdb] Error 2
make[2]: *** [Makefile:835: all] Error 2

crash build failed

make[1]: *** [Makefile:234: gdb_merge] Error 1
make: *** [Makefile:225: all] Error 2


To be honest, it's not clear how that can be addressed, because any patches
to printcmd.c must be applicable to the non-ppc64le and the ppc64le versions
of the file. 

So let's take a step back, and consider the risk/reward of this quite intrusive
patchset to such a crucial gdb file.  

First, &quot;dis -f &lt;address&gt; &lt;count&gt;&quot; is pretty much meaningless.  In order
to accomplish that, just don't use the &quot;-f&quot; argument! 

And BTW, even if you wanted to support it, it could be here done in 
cmd_dis() with a couple lines: 

                if (args[++optind]) {
                        if (reverse || forward) {
                                error(INFO,
                                    &quot;count argument ignored with -%s option\n&quot;,
                                        reverse ? &quot;r&quot; : &quot;f&quot;);
                        } else {
                                req-&gt;count = stol(args[optind],
                                        FAULT_ON_ERROR, NULL);
                                req-&gt;flags &amp;= ~GNU_FUNCTION_ONLY;
                                count_entered++;
                        }
                }

i.e., by just setting &quot;forward&quot; back to FALSE if a count argument is appended.

Secondly, for &quot;dis -r &lt;address&gt; count&quot;, you could simply run &quot;dis -r &lt;address&gt; | tail -4&quot;.
For that matter, is it really all that onerous to see the fully disassembled function
up to the target address?

And again, even if you wanted to support it, it also seems like it could be accomplished
within the cmd_dis() function, given that the full output is pre-gathered into a tmpfile
prior to being displayed.  

I appreciate the time and effort you've put into it, but making such a huge change to
the printcmd.c file for such a small reward scares the hell out of me.

Dave




&gt;<i> To support this feature, I have essentially incorported GDB commit</i>
&gt;<i> bb556f1facb (&quot;Add negative repeat count to 'x' command&quot;), with some</i>
&gt;<i> additional changes to maintain default behaviour i.e. always display the</i>
&gt;<i> target instruction with the examine command.</i>
&gt;<i> </i>
&gt;<i> Signed-off-by: Aaron Tomlin &lt;atomlin@xxxxxxxxxx&gt;</i>
&gt;<i> ---</i>
&gt;<i>  gdb-7.6.patch | 331 ++++++++++++++++++++++++++++++++++++++++++++++++++</i>
&gt;<i>  help.c        |   4 +-</i>
&gt;<i>  kernel.c      |  33 ++---</i>
&gt;<i>  3 files changed, 351 insertions(+), 17 deletions(-)</i>
&gt;<i> </i>
&gt;<i> diff --git a/gdb-7.6.patch b/gdb-7.6.patch</i>
&gt;<i> index cd75dcf..96cdef4 100644</i>
&gt;<i> --- a/gdb-7.6.patch</i>
&gt;<i> +++ b/gdb-7.6.patch</i>
&gt;<i> @@ -2447,3 +2447,334 @@ diff -up gdb-7.6/opcodes/configure.orig</i>
&gt;<i> gdb-7.6/opcodes/configure</i>
&gt;<i>   #else</i>
&gt;<i>   # error &quot;!__i386__ &amp;&amp; !__x86_64__&quot;</i>
&gt;<i>   #endif</i>
&gt;<i> +--- gdb-7.6/gdb/printcmd.c.orig</i>
&gt;<i> ++++ gdb-7.6/gdb/printcmd.c</i>
&gt;<i> +@@ -201,8 +201,13 @@ decode_format (char **string_ptr, int oformat, int</i>
&gt;<i> osize)</i>
&gt;<i> +   val.count = 1;</i>
&gt;<i> +   val.raw = 0;</i>
&gt;<i> +</i>
&gt;<i> ++  if (*p == '-')</i>
&gt;<i> ++    {</i>
&gt;<i> ++      val.count = -1;</i>
&gt;<i> ++      p++;</i>
&gt;<i> ++    }</i>
&gt;<i> +   if (*p &gt;= '0' &amp;&amp; *p &lt;= '9')</i>
&gt;<i> +-    val.count = atoi (p);</i>
&gt;<i> ++    val.count *= atoi (p);</i>
&gt;<i> +   while (*p &gt;= '0' &amp;&amp; *p &lt;= '9')</i>
&gt;<i> +     p++;</i>
&gt;<i> +</i>
&gt;<i> +@@ -795,6 +800,232 @@ print_address_demangle (const struct</i>
&gt;<i> value_print_options *opts,</i>
&gt;<i> + }</i>
&gt;<i> +</i>
&gt;<i> +</i>
&gt;<i> ++/* Find the address of the instruction that is INST_COUNT instructions</i>
&gt;<i> before</i>
&gt;<i> ++   the instruction at ADDR.</i>
&gt;<i> ++   Since some architectures have variable-length instructions, we can't</i>
&gt;<i> just</i>
&gt;<i> ++   simply subtract INST_COUNT * INSN_LEN from ADDR.  Instead, we use line</i>
&gt;<i> ++   number information to locate the nearest known instruction boundary,</i>
&gt;<i> ++   and disassemble forward from there.  If we go out of the symbol range</i>
&gt;<i> ++   during disassembling, we return the lowest address we've got so far and</i>
&gt;<i> ++   set the number of instructions read to INST_READ.  */</i>
&gt;<i> ++</i>
&gt;<i> ++static CORE_ADDR</i>
&gt;<i> ++find_instruction_backward (struct gdbarch *gdbarch, CORE_ADDR addr,</i>
&gt;<i> ++                           int inst_count, int *inst_read)</i>
&gt;<i> ++{</i>
&gt;<i> ++  /* The vector PCS is used to store instruction addresses within</i>
&gt;<i> ++     a pc range.  */</i>
&gt;<i> ++  CORE_ADDR loop_start, loop_end, p, func_addr;</i>
&gt;<i> ++  VEC (CORE_ADDR) *pcs = NULL;</i>
&gt;<i> ++  struct symtab_and_line sal;</i>
&gt;<i> ++  struct cleanup *cleanup = make_cleanup (VEC_cleanup (CORE_ADDR), &amp;pcs);</i>
&gt;<i> ++  int actual_count = 0;</i>
&gt;<i> ++</i>
&gt;<i> ++  *inst_read = 0;</i>
&gt;<i> ++  inst_count--;</i>
&gt;<i> ++  loop_start = loop_end = addr;</i>
&gt;<i> ++</i>
&gt;<i> ++  find_pc_partial_function (addr, NULL, &amp;func_addr, NULL);</i>
&gt;<i> ++  for (p = func_addr; p != addr;)</i>
&gt;<i> ++    {</i>
&gt;<i> ++      p += gdb_insn_length (gdbarch, p);</i>
&gt;<i> ++      actual_count++;</i>
&gt;<i> ++    }</i>
&gt;<i> ++  if (inst_count &gt; actual_count)</i>
&gt;<i> ++     inst_count = actual_count;</i>
&gt;<i> ++</i>
&gt;<i> ++  /* In each iteration of the outer loop, we get a pc range that ends</i>
&gt;<i> before</i>
&gt;<i> ++     LOOP_START, then we count and store every instruction address of the</i>
&gt;<i> range</i>
&gt;<i> ++     iterated in the loop.</i>
&gt;<i> ++     If the number of instructions counted reaches INST_COUNT, return the</i>
&gt;<i> ++     stored address that is located INST_COUNT instructions back from ADDR.</i>
&gt;<i> ++     If INST_COUNT is not reached, we subtract the number of counted</i>
&gt;<i> ++     instructions from INST_COUNT, and go to the next iteration.  */</i>
&gt;<i> ++  do</i>
&gt;<i> ++    {</i>
&gt;<i> ++      VEC_truncate (CORE_ADDR, pcs, 0);</i>
&gt;<i> ++      sal = find_pc_sect_line (loop_start, NULL, 1);</i>
&gt;<i> ++      if (sal.line &lt;= 0)</i>
&gt;<i> ++        {</i>
&gt;<i> ++          /* We reach here when line info is not available.  In this case,</i>
&gt;<i> ++             we print a message and just exit the loop.  The return value</i>
&gt;<i> ++             is calculated after the loop.  */</i>
&gt;<i> ++          printf_filtered (_(&quot;No line number information available &quot;</i>
&gt;<i> ++                             &quot;for address &quot;));</i>
&gt;<i> ++          wrap_here (&quot;  &quot;);</i>
&gt;<i> ++          print_address (gdbarch, loop_start - 1, gdb_stdout);</i>
&gt;<i> ++          printf_filtered (&quot;\n&quot;);</i>
&gt;<i> ++          break;</i>
&gt;<i> ++        }</i>
&gt;<i> ++</i>
&gt;<i> ++      loop_end = loop_start;</i>
&gt;<i> ++      loop_start = sal.pc;</i>
&gt;<i> ++</i>
&gt;<i> ++      /* This loop pushes instruction addresses in the range from</i>
&gt;<i> ++         LOOP_START to LOOP_END.  */</i>
&gt;<i> ++      for (p = loop_start; p &lt; loop_end;)</i>
&gt;<i> ++        {</i>
&gt;<i> ++          VEC_safe_push (CORE_ADDR, pcs, p);</i>
&gt;<i> ++          p += gdb_insn_length (gdbarch, p);</i>
&gt;<i> ++        }</i>
&gt;<i> ++</i>
&gt;<i> ++      inst_count -= VEC_length (CORE_ADDR, pcs);</i>
&gt;<i> ++      *inst_read += VEC_length (CORE_ADDR, pcs);</i>
&gt;<i> ++    }</i>
&gt;<i> ++  while (inst_count &gt; 0);</i>
&gt;<i> ++</i>
&gt;<i> ++  /* After the loop, the vector PCS has instruction addresses of the last</i>
&gt;<i> ++     source line we processed, and INST_COUNT has a negative value.</i>
&gt;<i> ++     We return the address at the index of -INST_COUNT in the vector for</i>
&gt;<i> ++     the reason below.</i>
&gt;<i> ++     Let's assume the following instruction addresses and run 'x/-4i</i>
&gt;<i> 0x400e'.</i>
&gt;<i> ++       Line X of File</i>
&gt;<i> ++          0x4000</i>
&gt;<i> ++          0x4001</i>
&gt;<i> ++          0x4005</i>
&gt;<i> ++       Line Y of File</i>
&gt;<i> ++          0x4009</i>
&gt;<i> ++          0x400c</i>
&gt;<i> ++       =&gt; 0x400e</i>
&gt;<i> ++          0x4011</i>
&gt;<i> ++     find_instruction_backward is called with INST_COUNT = 4 and expected</i>
&gt;<i> to</i>
&gt;<i> ++     return 0x4001.  When we reach here, INST_COUNT is set to -1 because</i>
&gt;<i> ++     it was subtracted by 2 (from Line Y) and 3 (from Line X).  The value</i>
&gt;<i> ++     4001 is located at the index 1 of the last iterated line (= Line X),</i>
&gt;<i> ++     which is simply calculated by -INST_COUNT.</i>
&gt;<i> ++     The case when the length of PCS is 0 means that we reached an area for</i>
&gt;<i> ++     which line info is not available.  In such case, we return LOOP_START,</i>
&gt;<i> ++     which was the lowest instruction address that had line info.  */</i>
&gt;<i> ++  p = VEC_length (CORE_ADDR, pcs) &gt; 0</i>
&gt;<i> ++    ? VEC_index (CORE_ADDR, pcs, -inst_count)</i>
&gt;<i> ++    : loop_start;</i>
&gt;<i> ++</i>
&gt;<i> ++  /* INST_READ includes all instruction addresses in a pc range.  Need to</i>
&gt;<i> ++     exclude the beginning part up to the address we're returning.  That</i>
&gt;<i> ++     is, exclude {0x4000} in the example above.  */</i>
&gt;<i> ++  if (inst_count &lt; 0)</i>
&gt;<i> ++    *inst_read += inst_count;</i>
&gt;<i> ++</i>
&gt;<i> ++  do_cleanups (cleanup);</i>
&gt;<i> ++  return p;</i>
&gt;<i> ++}</i>
&gt;<i> ++</i>
&gt;<i> ++/* Backward read LEN bytes of target memory from address MEMADDR + LEN,</i>
&gt;<i> ++   placing the results in GDB's memory from MYADDR + LEN.  Returns</i>
&gt;<i> ++   a count of the bytes actually read.  */</i>
&gt;<i> ++</i>
&gt;<i> ++static int</i>
&gt;<i> ++read_memory_backward (struct gdbarch *gdbarch,</i>
&gt;<i> ++                      CORE_ADDR memaddr, gdb_byte *myaddr, int len)</i>
&gt;<i> ++{</i>
&gt;<i> ++  int errcode;</i>
&gt;<i> ++  int nread;      /* Number of bytes actually read.  */</i>
&gt;<i> ++</i>
&gt;<i> ++  /* First try a complete read.  */</i>
&gt;<i> ++  errcode = target_read_memory (memaddr, myaddr, len);</i>
&gt;<i> ++  if (errcode == 0)</i>
&gt;<i> ++    {</i>
&gt;<i> ++      /* Got it all.  */</i>
&gt;<i> ++      nread = len;</i>
&gt;<i> ++    }</i>
&gt;<i> ++  else</i>
&gt;<i> ++    {</i>
&gt;<i> ++      /* Loop, reading one byte at a time until we get as much as we can.</i>
&gt;<i> */</i>
&gt;<i> ++      memaddr += len;</i>
&gt;<i> ++      myaddr += len;</i>
&gt;<i> ++      for (nread = 0; nread &lt; len; ++nread)</i>
&gt;<i> ++        {</i>
&gt;<i> ++          errcode = target_read_memory (--memaddr, --myaddr, 1);</i>
&gt;<i> ++          if (errcode != 0)</i>
&gt;<i> ++            {</i>
&gt;<i> ++              /* The read was unsuccessful, so exit the loop.  */</i>
&gt;<i> ++              printf_filtered (_(&quot;Cannot access memory at address %s\n&quot;),</i>
&gt;<i> ++                               paddress (gdbarch, memaddr));</i>
&gt;<i> ++              break;</i>
&gt;<i> ++            }</i>
&gt;<i> ++        }</i>
&gt;<i> ++    }</i>
&gt;<i> ++  return nread;</i>
&gt;<i> ++}</i>
&gt;<i> ++</i>
&gt;<i> ++/* Returns true if X (which is LEN bytes wide) is the number zero.  */</i>
&gt;<i> ++</i>
&gt;<i> ++static int</i>
&gt;<i> ++integer_is_zero (const gdb_byte *x, int len)</i>
&gt;<i> ++{</i>
&gt;<i> ++  int i = 0;</i>
&gt;<i> ++</i>
&gt;<i> ++  while (i &lt; len &amp;&amp; x[i] == 0)</i>
&gt;<i> ++    ++i;</i>
&gt;<i> ++  return (i == len);</i>
&gt;<i> ++}</i>
&gt;<i> ++</i>
&gt;<i> ++/* Find the start address of a string in which ADDR is included.</i>
&gt;<i> ++   Basically we search for '\0' and return the next address,</i>
&gt;<i> ++   but if OPTIONS-&gt;PRINT_MAX is smaller than the length of a string,</i>
&gt;<i> ++   we stop searching and return the address to print characters as many as</i>
&gt;<i> ++   PRINT_MAX from the string.  */</i>
&gt;<i> ++</i>
&gt;<i> ++static CORE_ADDR</i>
&gt;<i> ++find_string_backward (struct gdbarch *gdbarch,</i>
&gt;<i> ++                      CORE_ADDR addr, int count, int char_size,</i>
&gt;<i> ++                      const struct value_print_options *options,</i>
&gt;<i> ++                      int *strings_counted)</i>
&gt;<i> ++{</i>
&gt;<i> ++  const int chunk_size = 0x20;</i>
&gt;<i> ++  gdb_byte *buffer = NULL;</i>
&gt;<i> ++  struct cleanup *cleanup = NULL;</i>
&gt;<i> ++  int read_error = 0;</i>
&gt;<i> ++  int chars_read = 0;</i>
&gt;<i> ++  int chars_to_read = chunk_size;</i>
&gt;<i> ++  int chars_counted = 0;</i>
&gt;<i> ++  int count_original = count;</i>
&gt;<i> ++  CORE_ADDR string_start_addr = addr;</i>
&gt;<i> ++</i>
&gt;<i> ++  gdb_assert (char_size == 1 || char_size == 2 || char_size == 4);</i>
&gt;<i> ++  buffer = (gdb_byte *) xmalloc (chars_to_read * char_size);</i>
&gt;<i> ++  cleanup = make_cleanup (xfree, buffer);</i>
&gt;<i> ++  while (count &gt; 0 &amp;&amp; read_error == 0)</i>
&gt;<i> ++    {</i>
&gt;<i> ++      int i;</i>
&gt;<i> ++</i>
&gt;<i> ++      addr -= chars_to_read * char_size;</i>
&gt;<i> ++      chars_read = read_memory_backward (gdbarch, addr, buffer,</i>
&gt;<i> ++                                         chars_to_read * char_size);</i>
&gt;<i> ++      chars_read /= char_size;</i>
&gt;<i> ++      read_error = (chars_read == chars_to_read) ? 0 : 1;</i>
&gt;<i> ++      /* Searching for '\0' from the end of buffer in backward direction.</i>
&gt;<i> */</i>
&gt;<i> ++      for (i = 0; i &lt; chars_read &amp;&amp; count &gt; 0 ; ++i, ++chars_counted)</i>
&gt;<i> ++        {</i>
&gt;<i> ++          int offset = (chars_to_read - i - 1) * char_size;</i>
&gt;<i> ++</i>
&gt;<i> ++          if (integer_is_zero (buffer + offset, char_size)</i>
&gt;<i> ++              || chars_counted == options-&gt;print_max)</i>
&gt;<i> ++            {</i>
&gt;<i> ++              /* Found '\0' or reached print_max.  As OFFSET is the offset</i>
&gt;<i> to</i>
&gt;<i> ++                 '\0', we add CHAR_SIZE to return the start address of</i>
&gt;<i> ++                 a string.  */</i>
&gt;<i> ++              --count;</i>
&gt;<i> ++              string_start_addr = addr + offset + char_size;</i>
&gt;<i> ++              chars_counted = 0;</i>
&gt;<i> ++            }</i>
&gt;<i> ++        }</i>
&gt;<i> ++    }</i>
&gt;<i> ++</i>
&gt;<i> ++  /* Update STRINGS_COUNTED with the actual number of loaded strings.  */</i>
&gt;<i> ++  *strings_counted = count_original - count;</i>
&gt;<i> ++</i>
&gt;<i> ++  if (read_error != 0)</i>
&gt;<i> ++    {</i>
&gt;<i> ++      /* In error case, STRING_START_ADDR is pointing to the string that</i>
&gt;<i> ++         was last successfully loaded.  Rewind the partially loaded string.</i>
&gt;<i> */</i>
&gt;<i> ++      string_start_addr -= chars_counted * char_size;</i>
&gt;<i> ++    }</i>
&gt;<i> ++</i>
&gt;<i> ++  do_cleanups (cleanup);</i>
&gt;<i> ++  return string_start_addr;</i>
&gt;<i> ++}</i>
&gt;<i> ++</i>
&gt;<i> + /* Examine data at address ADDR in format FMT.</i>
&gt;<i> +    Fetch it from memory and print on gdb_stdout.  */</i>
&gt;<i> +</i>
&gt;<i> +@@ -808,12 +1039,16 @@ do_examine (struct format_data fmt, struct gdbarch</i>
&gt;<i> *gdbarch, CORE_ADDR addr)</i>
&gt;<i> +   int i;</i>
&gt;<i> +   int maxelts;</i>
&gt;<i> +   struct value_print_options opts;</i>
&gt;<i> ++  int need_to_update_next_address = 0;</i>
&gt;<i> ++  CORE_ADDR addr_rewound = 0;</i>
&gt;<i> ++  int is_backward;</i>
&gt;<i> +</i>
&gt;<i> +   format = fmt.format;</i>
&gt;<i> +   size = fmt.size;</i>
&gt;<i> +   count = fmt.count;</i>
&gt;<i> +   next_gdbarch = gdbarch;</i>
&gt;<i> +   next_address = addr;</i>
&gt;<i> ++  is_backward = count &lt; 0;</i>
&gt;<i> +</i>
&gt;<i> +   /* Instruction format implies fetch single bytes</i>
&gt;<i> +      regardless of the specified size.</i>
&gt;<i> +@@ -878,9 +1113,43 @@ do_examine (struct format_data fmt, struct gdbarch</i>
&gt;<i> *gdbarch, CORE_ADDR addr)</i>
&gt;<i> +</i>
&gt;<i> +   get_formatted_print_options (&amp;opts, format);</i>
&gt;<i> +</i>
&gt;<i> ++  if (is_backward)</i>
&gt;<i> ++    {</i>
&gt;<i> ++      /* This is the negative repeat count case.</i>
&gt;<i> ++         We rewind the address based on the given repeat count and format,</i>
&gt;<i> ++         then examine memory from there in forward direction.  */</i>
&gt;<i> ++</i>
&gt;<i> ++      count = -count;</i>
&gt;<i> ++      if (format == 'i')</i>
&gt;<i> ++        {</i>
&gt;<i> ++          next_address = find_instruction_backward (gdbarch, addr, count,</i>
&gt;<i> ++                                                    &amp;count);</i>
&gt;<i> ++        }</i>
&gt;<i> ++      else if (format == 's')</i>
&gt;<i> ++        {</i>
&gt;<i> ++          next_address = find_string_backward (gdbarch, addr, count,</i>
&gt;<i> ++                                               TYPE_LENGTH (val_type),</i>
&gt;<i> ++                                               &amp;opts, &amp;count);</i>
&gt;<i> ++        }</i>
&gt;<i> ++      else</i>
&gt;<i> ++        {</i>
&gt;<i> ++          next_address = addr - count * TYPE_LENGTH (val_type);</i>
&gt;<i> ++        }</i>
&gt;<i> ++</i>
&gt;<i> ++      /* The following call to print_formatted updates next_address in</i>
&gt;<i> every</i>
&gt;<i> ++         iteration.  In backward case, we store the start address here</i>
&gt;<i> ++         and update next_address with it before exiting the function.  */</i>
&gt;<i> ++      addr_rewound = (format == 's'</i>
&gt;<i> ++                      ? next_address - TYPE_LENGTH (val_type)</i>
&gt;<i> ++                      : next_address);</i>
&gt;<i> ++      need_to_update_next_address = 1;</i>
&gt;<i> ++    }</i>
&gt;<i> ++</i>
&gt;<i> +   /* Print as many objects as specified in COUNT, at most maxelts per line,</i>
&gt;<i> +      with the address of the next one at the start of each line.  */</i>
&gt;<i> +</i>
&gt;<i> ++  if (is_backward)</i>
&gt;<i> ++    count++;</i>
&gt;<i> +   while (count &gt; 0)</i>
&gt;<i> +     {</i>
&gt;<i> +       QUIT;</i>
&gt;<i> +@@ -923,6 +1192,9 @@ do_examine (struct format_data fmt, struct gdbarch</i>
&gt;<i> *gdbarch, CORE_ADDR addr)</i>
&gt;<i> +       printf_filtered (&quot;\n&quot;);</i>
&gt;<i> +       gdb_flush (gdb_stdout);</i>
&gt;<i> +     }</i>
&gt;<i> ++</i>
&gt;<i> ++  if (need_to_update_next_address)</i>
&gt;<i> ++    next_address = addr_rewound;</i>
&gt;<i> + }</i>
&gt;<i> +</i>
&gt;<i> + static void</i>
&gt;<i> +@@ -2535,7 +2807,8 @@ Format letters are o(octal), x(hex), d(decimal),</i>
&gt;<i> u(unsigned decimal),\n\</i>
&gt;<i> +   t(binary), f(float), a(address), i(instruction), c(char) and</i>
&gt;<i> s(string).\n\</i>
&gt;<i> + Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).\n\</i>
&gt;<i> + The specified number of objects of the specified size are printed\n\</i>
&gt;<i> +-according to the format.\n\n\</i>
&gt;<i> ++according to the format.  If a negative number is specified, memory is\n\</i>
&gt;<i> ++examined backward from the address.\n\n\</i>
&gt;<i> + Defaults for format and size letters are those previously used.\n\</i>
&gt;<i> + Default count is 1.  Default address is following last thing printed\n\</i>
&gt;<i> + with this command or \&quot;print\&quot;.&quot;));</i>
&gt;<i> diff --git a/help.c b/help.c</i>
&gt;<i> index 581e616..4d028e1 100644</i>
&gt;<i> --- a/help.c</i>
&gt;<i> +++ b/help.c</i>
&gt;<i> @@ -7278,8 +7278,8 @@ char *help_dis[] = {</i>
&gt;<i>  &quot;         count  the number of instructions to be disassembled (default is</i>
&gt;<i>  1).&quot;,</i>
&gt;<i>  &quot;                If no count argument is entered, and the starting address&quot;,</i>
&gt;<i>  &quot;                is entered as a text symbol, then the whole routine will</i>
&gt;<i>  be&quot;,</i>
&gt;<i> -&quot;                disassembled.  The count argument is ignored when used</i>
&gt;<i> with&quot;,</i>
&gt;<i> -&quot;                the -r option.&quot;,</i>
&gt;<i> +&quot;                disassembled.  The count argument is supported when used</i>
&gt;<i> with&quot;,</i>
&gt;<i> +&quot;                the -r and -f option.&quot;,</i>
&gt;<i>  &quot;\nEXAMPLES&quot;,</i>
&gt;<i>  &quot;  Disassemble the sys_signal() routine without, and then with, line</i>
&gt;<i>  numbers:\n&quot;,</i>
&gt;<i>  &quot;    %s&gt; dis sys_signal&quot;,</i>
&gt;<i> diff --git a/kernel.c b/kernel.c</i>
&gt;<i> index f01dc2e..e1f0b7e 100644</i>
&gt;<i> --- a/kernel.c</i>
&gt;<i> +++ b/kernel.c</i>
&gt;<i> @@ -1931,16 +1931,10 @@ cmd_dis(void)</i>
&gt;<i>                  }</i>
&gt;<i>  </i>
&gt;<i>                  if (args[++optind]) {</i>
&gt;<i> -			if (reverse || forward) {</i>
&gt;<i> -				error(INFO,</i>
&gt;<i> -			            &quot;count argument ignored with -%s option\n&quot;,</i>
&gt;<i> -				    	reverse ? &quot;r&quot; : &quot;f&quot;);</i>
&gt;<i> -			} else {</i>
&gt;<i> -                        	req-&gt;count = stol(args[optind],</i>
&gt;<i> +			req-&gt;count = stol(args[optind],</i>
&gt;<i>  					FAULT_ON_ERROR, NULL);</i>
&gt;<i> -				req-&gt;flags &amp;= ~GNU_FUNCTION_ONLY;</i>
&gt;<i> -				count_entered++;</i>
&gt;<i> -			}</i>
&gt;<i> +			req-&gt;flags &amp;= ~GNU_FUNCTION_ONLY;</i>
&gt;<i> +			count_entered++;</i>
&gt;<i>  		}</i>
&gt;<i>  </i>
&gt;<i>  		if (sources) {</i>
&gt;<i> @@ -1992,6 +1986,10 @@ cmd_dis(void)</i>
&gt;<i>  			}</i>
&gt;<i>  		}</i>
&gt;<i>  </i>
&gt;<i> +		if (reverse || forward)</i>
&gt;<i> +			if (count_entered &amp;&amp; req-&gt;count == 1)</i>
&gt;<i> +				reverse = forward = 0;</i>
&gt;<i> +</i>
&gt;<i>  		if (reverse || forward) {</i>
&gt;<i>  			target = req-&gt;addr;</i>
&gt;<i>  			if ((sp = value_search(target, NULL)) == NULL)</i>
&gt;<i> @@ -2006,14 +2004,19 @@ cmd_dis(void)</i>
&gt;<i>  		do_machdep_filter = machdep-&gt;dis_filter(req-&gt;addr, NULL, radix);</i>
&gt;<i>  		open_tmpfile();</i>
&gt;<i>  </i>
&gt;<i> -		if (reverse)</i>
&gt;<i> -			sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,</i>
&gt;<i> -				(target - req-&gt;addr) ? target - req-&gt;addr : 1,</i>
&gt;<i> -				req-&gt;addr);</i>
&gt;<i> -		else</i>
&gt;<i> +		if (reverse || forward) {</i>
&gt;<i> +			if (count_entered &amp;&amp; req-&gt;count)</i>
&gt;<i> +				sprintf(buf5, &quot;x/%s%ldi 0x%lx&quot;, reverse ? &quot;-&quot; : &quot;&quot;,</i>
&gt;<i> +					req-&gt;count, target);</i>
&gt;<i> +			else</i>
&gt;<i> +				sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,</i>
&gt;<i> +					forward ?  req-&gt;addr2 - req-&gt;addr :</i>
&gt;<i> +					(target - req-&gt;addr) ? target - req-&gt;addr : 1,</i>
&gt;<i> +					forward ? target : req-&gt;addr);</i>
&gt;<i> +		} else</i>
&gt;<i>  			sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,</i>
&gt;<i>  				count_entered &amp;&amp; req-&gt;count ? req-&gt;count :</i>
&gt;<i> -				forward || req-&gt;flags &amp; GNU_FUNCTION_ONLY ?</i>
&gt;<i> +				req-&gt;flags &amp; GNU_FUNCTION_ONLY ?</i>
&gt;<i>  				req-&gt;addr2 - req-&gt;addr : 1,</i>
&gt;<i>  				req-&gt;addr);</i>
&gt;<i>  		gdb_pass_through(buf5, NULL, GNU_RETURN_ON_ERROR);</i>
&gt;<i> --</i>
&gt;<i> 2.20.1</i>
&gt;<i> </i>
&gt;<i> --</i>
&gt;<i> Crash-utility mailing list</i>
&gt;<i> Crash-utility@xxxxxxxxxx</i>
&gt;<i> <a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a></i>
&gt;<i> </i>

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="07818" href="msg07818.html">Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</a></strong>
<ul><li><em>From:</em> Dave Anderson</li></ul></li>
<li><strong><a name="07792" href="msg07792.html">Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</a></strong>
<ul><li><em>From:</em> Aaron Tomlin</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="07787" href="msg07787.html">[PATCH v2] crash: dis: introduce count in reverse	and forward mode</a></strong>
<ul><li><em>From:</em> Aaron Tomlin</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07790.html">Re:  [PATCH] timers: add option to show expired	timers only</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07792.html">Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07787.html">[PATCH v2] crash: dis: introduce count in reverse	and forward mode</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07792.html">Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07791"><strong>Date</strong></a></li>
<li><a href="index.html#07791"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
