<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH v2] crash: dis: introduce count in reverse	and forward mode -->
<!--X-From-R13: Oneba Fbzyva &#60;ngbzyvaNerqung.pbz> -->
<!--X-Date: Thu, 20 Jun 2019 16:57:50 &#45;0700 -->
<!--X-Message-Id: 20190620235733.2489&#45;1&#45;atomlin@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="[PATCH v2] crash: dis: introduce count in reverse	and forward mode &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  [PATCH v2] crash: dis: introduce count in reverse	and forward mode</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH v2] crash: dis: introduce count in reverse	and forward mode</h1>
[<a href="msg07786.html">Date Prev</a>][<a href="msg07788.html">Date Next</a>][<a href="msg07782.html">Thread Prev</a>][<a href="msg07791.html">Thread Next</a>][<a href="maillist.html#07787">Date Index</a>][<a href="index.html#07787">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH v2] crash: dis: introduce count in reverse	and forward mode</li>
<li><em>From</em>: Aaron Tomlin &lt;atomlin@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Fri, 21 Jun 2019 00:57:33 +0100</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Changes since v1:

 - Update 'dis' help page
 - Resolve patch fuzz


The purpose of this patch is to add support for a count value in reverse
or forward mode, during disassembly:

	'dis [-r|-f] [symbol|address] [count]'

For example:

  crash&gt; dis -f list_del+0x16 4
  0xffffffff812b3346 &lt;list_del+22&gt;:       jne    0xffffffff812b3381 &lt;list_del+81&gt;
  0xffffffff812b3348 &lt;list_del+24&gt;:       mov    (%rbx),%rax
  0xffffffff812b334b &lt;list_del+27&gt;:       mov    0x8(%rax),%r8
  0xffffffff812b334f &lt;list_del+31&gt;:       cmp    %r8,%rbx

  crash&gt; dis -r list_del+0x16 4
  0xffffffff812b333c &lt;list_del+12&gt;:       mov    0x8(%rdi),%rax
  0xffffffff812b3340 &lt;list_del+16&gt;:       mov    (%rax),%r8
  0xffffffff812b3343 &lt;list_del+19&gt;:       cmp    %r8,%rdi
  0xffffffff812b3346 &lt;list_del+22&gt;:       jne    0xffffffff812b3381 &lt;list_del+81&gt;

To support this feature, I have essentially incorported GDB commit
bb556f1facb (&quot;Add negative repeat count to 'x' command&quot;), with some
additional changes to maintain default behaviour i.e. always display the
target instruction with the examine command.

Signed-off-by: Aaron Tomlin &lt;atomlin@xxxxxxxxxx&gt;
---
 gdb-7.6.patch | 331 ++++++++++++++++++++++++++++++++++++++++++++++++++
 help.c        |   4 +-
 kernel.c      |  33 ++---
 3 files changed, 351 insertions(+), 17 deletions(-)

diff --git a/gdb-7.6.patch b/gdb-7.6.patch
index cd75dcf..96cdef4 100644
--- a/gdb-7.6.patch
+++ b/gdb-7.6.patch
@@ -2447,3 +2447,334 @@ diff -up gdb-7.6/opcodes/configure.orig gdb-7.6/opcodes/configure
  #else
  # error &quot;!__i386__ &amp;&amp; !__x86_64__&quot;
  #endif
+--- gdb-7.6/gdb/printcmd.c.orig
++++ gdb-7.6/gdb/printcmd.c
+@@ -201,8 +201,13 @@ decode_format (char **string_ptr, int oformat, int osize)
+   val.count = 1;
+   val.raw = 0;
+ 
++  if (*p == '-')
++    {
++      val.count = -1;
++      p++;
++    }
+   if (*p &gt;= '0' &amp;&amp; *p &lt;= '9')
+-    val.count = atoi (p);
++    val.count *= atoi (p);
+   while (*p &gt;= '0' &amp;&amp; *p &lt;= '9')
+     p++;
+ 
+@@ -795,6 +800,232 @@ print_address_demangle (const struct value_print_options *opts,
+ }
+ 
+ 
++/* Find the address of the instruction that is INST_COUNT instructions before
++   the instruction at ADDR.
++   Since some architectures have variable-length instructions, we can't just
++   simply subtract INST_COUNT * INSN_LEN from ADDR.  Instead, we use line
++   number information to locate the nearest known instruction boundary,
++   and disassemble forward from there.  If we go out of the symbol range
++   during disassembling, we return the lowest address we've got so far and
++   set the number of instructions read to INST_READ.  */
++
++static CORE_ADDR
++find_instruction_backward (struct gdbarch *gdbarch, CORE_ADDR addr,
++                           int inst_count, int *inst_read)
++{
++  /* The vector PCS is used to store instruction addresses within
++     a pc range.  */
++  CORE_ADDR loop_start, loop_end, p, func_addr;
++  VEC (CORE_ADDR) *pcs = NULL;
++  struct symtab_and_line sal;
++  struct cleanup *cleanup = make_cleanup (VEC_cleanup (CORE_ADDR), &amp;pcs);
++  int actual_count = 0;
++
++  *inst_read = 0;
++  inst_count--;
++  loop_start = loop_end = addr;
++
++  find_pc_partial_function (addr, NULL, &amp;func_addr, NULL);
++  for (p = func_addr; p != addr;)
++    {
++      p += gdb_insn_length (gdbarch, p);
++      actual_count++;
++    }
++  if (inst_count &gt; actual_count)
++     inst_count = actual_count;
++
++  /* In each iteration of the outer loop, we get a pc range that ends before
++     LOOP_START, then we count and store every instruction address of the range
++     iterated in the loop.
++     If the number of instructions counted reaches INST_COUNT, return the
++     stored address that is located INST_COUNT instructions back from ADDR.
++     If INST_COUNT is not reached, we subtract the number of counted
++     instructions from INST_COUNT, and go to the next iteration.  */
++  do
++    {
++      VEC_truncate (CORE_ADDR, pcs, 0);
++      sal = find_pc_sect_line (loop_start, NULL, 1);
++      if (sal.line &lt;= 0)
++        {
++          /* We reach here when line info is not available.  In this case,
++             we print a message and just exit the loop.  The return value
++             is calculated after the loop.  */
++          printf_filtered (_(&quot;No line number information available &quot;
++                             &quot;for address &quot;));
++          wrap_here (&quot;  &quot;);
++          print_address (gdbarch, loop_start - 1, gdb_stdout);
++          printf_filtered (&quot;\n&quot;);
++          break;
++        }
++
++      loop_end = loop_start;
++      loop_start = sal.pc;
++
++      /* This loop pushes instruction addresses in the range from
++         LOOP_START to LOOP_END.  */
++      for (p = loop_start; p &lt; loop_end;)
++        {
++          VEC_safe_push (CORE_ADDR, pcs, p);
++          p += gdb_insn_length (gdbarch, p);
++        }
++
++      inst_count -= VEC_length (CORE_ADDR, pcs);
++      *inst_read += VEC_length (CORE_ADDR, pcs);
++    }
++  while (inst_count &gt; 0);
++
++  /* After the loop, the vector PCS has instruction addresses of the last
++     source line we processed, and INST_COUNT has a negative value.
++     We return the address at the index of -INST_COUNT in the vector for
++     the reason below.
++     Let's assume the following instruction addresses and run 'x/-4i 0x400e'.
++       Line X of File
++          0x4000
++          0x4001
++          0x4005
++       Line Y of File
++          0x4009
++          0x400c
++       =&gt; 0x400e
++          0x4011
++     find_instruction_backward is called with INST_COUNT = 4 and expected to
++     return 0x4001.  When we reach here, INST_COUNT is set to -1 because
++     it was subtracted by 2 (from Line Y) and 3 (from Line X).  The value
++     4001 is located at the index 1 of the last iterated line (= Line X),
++     which is simply calculated by -INST_COUNT.
++     The case when the length of PCS is 0 means that we reached an area for
++     which line info is not available.  In such case, we return LOOP_START,
++     which was the lowest instruction address that had line info.  */
++  p = VEC_length (CORE_ADDR, pcs) &gt; 0
++    ? VEC_index (CORE_ADDR, pcs, -inst_count)
++    : loop_start;
++
++  /* INST_READ includes all instruction addresses in a pc range.  Need to
++     exclude the beginning part up to the address we're returning.  That
++     is, exclude {0x4000} in the example above.  */
++  if (inst_count &lt; 0)
++    *inst_read += inst_count;
++
++  do_cleanups (cleanup);
++  return p;
++}
++
++/* Backward read LEN bytes of target memory from address MEMADDR + LEN,
++   placing the results in GDB's memory from MYADDR + LEN.  Returns
++   a count of the bytes actually read.  */
++
++static int
++read_memory_backward (struct gdbarch *gdbarch,
++                      CORE_ADDR memaddr, gdb_byte *myaddr, int len)
++{
++  int errcode;
++  int nread;      /* Number of bytes actually read.  */
++
++  /* First try a complete read.  */
++  errcode = target_read_memory (memaddr, myaddr, len);
++  if (errcode == 0)
++    {
++      /* Got it all.  */
++      nread = len;
++    }
++  else
++    {
++      /* Loop, reading one byte at a time until we get as much as we can.  */
++      memaddr += len;
++      myaddr += len;
++      for (nread = 0; nread &lt; len; ++nread)
++        {
++          errcode = target_read_memory (--memaddr, --myaddr, 1);
++          if (errcode != 0)
++            {
++              /* The read was unsuccessful, so exit the loop.  */
++              printf_filtered (_(&quot;Cannot access memory at address %s\n&quot;),
++                               paddress (gdbarch, memaddr));
++              break;
++            }
++        }
++    }
++  return nread;
++}
++
++/* Returns true if X (which is LEN bytes wide) is the number zero.  */
++
++static int
++integer_is_zero (const gdb_byte *x, int len)
++{
++  int i = 0;
++
++  while (i &lt; len &amp;&amp; x[i] == 0)
++    ++i;
++  return (i == len);
++}
++
++/* Find the start address of a string in which ADDR is included.
++   Basically we search for '\0' and return the next address,
++   but if OPTIONS-&gt;PRINT_MAX is smaller than the length of a string,
++   we stop searching and return the address to print characters as many as
++   PRINT_MAX from the string.  */
++
++static CORE_ADDR
++find_string_backward (struct gdbarch *gdbarch,
++                      CORE_ADDR addr, int count, int char_size,
++                      const struct value_print_options *options,
++                      int *strings_counted)
++{
++  const int chunk_size = 0x20;
++  gdb_byte *buffer = NULL;
++  struct cleanup *cleanup = NULL;
++  int read_error = 0;
++  int chars_read = 0;
++  int chars_to_read = chunk_size;
++  int chars_counted = 0;
++  int count_original = count;
++  CORE_ADDR string_start_addr = addr;
++
++  gdb_assert (char_size == 1 || char_size == 2 || char_size == 4);
++  buffer = (gdb_byte *) xmalloc (chars_to_read * char_size);
++  cleanup = make_cleanup (xfree, buffer);
++  while (count &gt; 0 &amp;&amp; read_error == 0)
++    {
++      int i;
++
++      addr -= chars_to_read * char_size;
++      chars_read = read_memory_backward (gdbarch, addr, buffer,
++                                         chars_to_read * char_size);
++      chars_read /= char_size;
++      read_error = (chars_read == chars_to_read) ? 0 : 1;
++      /* Searching for '\0' from the end of buffer in backward direction.  */
++      for (i = 0; i &lt; chars_read &amp;&amp; count &gt; 0 ; ++i, ++chars_counted)
++        {
++          int offset = (chars_to_read - i - 1) * char_size;
++
++          if (integer_is_zero (buffer + offset, char_size)
++              || chars_counted == options-&gt;print_max)
++            {
++              /* Found '\0' or reached print_max.  As OFFSET is the offset to
++                 '\0', we add CHAR_SIZE to return the start address of
++                 a string.  */
++              --count;
++              string_start_addr = addr + offset + char_size;
++              chars_counted = 0;
++            }
++        }
++    }
++
++  /* Update STRINGS_COUNTED with the actual number of loaded strings.  */
++  *strings_counted = count_original - count;
++
++  if (read_error != 0)
++    {
++      /* In error case, STRING_START_ADDR is pointing to the string that
++         was last successfully loaded.  Rewind the partially loaded string.  */
++      string_start_addr -= chars_counted * char_size;
++    }
++
++  do_cleanups (cleanup);
++  return string_start_addr;
++}
++
+ /* Examine data at address ADDR in format FMT.
+    Fetch it from memory and print on gdb_stdout.  */
+ 
+@@ -808,12 +1039,16 @@ do_examine (struct format_data fmt, struct gdbarch *gdbarch, CORE_ADDR addr)
+   int i;
+   int maxelts;
+   struct value_print_options opts;
++  int need_to_update_next_address = 0;
++  CORE_ADDR addr_rewound = 0;
++  int is_backward;
+ 
+   format = fmt.format;
+   size = fmt.size;
+   count = fmt.count;
+   next_gdbarch = gdbarch;
+   next_address = addr;
++  is_backward = count &lt; 0;
+ 
+   /* Instruction format implies fetch single bytes
+      regardless of the specified size.
+@@ -878,9 +1113,43 @@ do_examine (struct format_data fmt, struct gdbarch *gdbarch, CORE_ADDR addr)
+ 
+   get_formatted_print_options (&amp;opts, format);
+ 
++  if (is_backward)
++    {
++      /* This is the negative repeat count case.
++         We rewind the address based on the given repeat count and format,
++         then examine memory from there in forward direction.  */
++
++      count = -count;
++      if (format == 'i')
++        {
++          next_address = find_instruction_backward (gdbarch, addr, count,
++                                                    &amp;count);
++        }
++      else if (format == 's')
++        {
++          next_address = find_string_backward (gdbarch, addr, count,
++                                               TYPE_LENGTH (val_type),
++                                               &amp;opts, &amp;count);
++        }
++      else
++        {
++          next_address = addr - count * TYPE_LENGTH (val_type);
++        }
++
++      /* The following call to print_formatted updates next_address in every
++         iteration.  In backward case, we store the start address here
++         and update next_address with it before exiting the function.  */
++      addr_rewound = (format == 's'
++                      ? next_address - TYPE_LENGTH (val_type)
++                      : next_address);
++      need_to_update_next_address = 1;
++    }
++
+   /* Print as many objects as specified in COUNT, at most maxelts per line,
+      with the address of the next one at the start of each line.  */
+ 
++  if (is_backward)
++    count++;
+   while (count &gt; 0)
+     {
+       QUIT;
+@@ -923,6 +1192,9 @@ do_examine (struct format_data fmt, struct gdbarch *gdbarch, CORE_ADDR addr)
+       printf_filtered (&quot;\n&quot;);
+       gdb_flush (gdb_stdout);
+     }
++
++  if (need_to_update_next_address)
++    next_address = addr_rewound;
+ }
+ 
+ static void
+@@ -2535,7 +2807,8 @@ Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),\n\
+   t(binary), f(float), a(address), i(instruction), c(char) and s(string).\n\
+ Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).\n\
+ The specified number of objects of the specified size are printed\n\
+-according to the format.\n\n\
++according to the format.  If a negative number is specified, memory is\n\
++examined backward from the address.\n\n\
+ Defaults for format and size letters are those previously used.\n\
+ Default count is 1.  Default address is following last thing printed\n\
+ with this command or \&quot;print\&quot;.&quot;));
diff --git a/help.c b/help.c
index 581e616..4d028e1 100644
--- a/help.c
+++ b/help.c
@@ -7278,8 +7278,8 @@ char *help_dis[] = {
 &quot;         count  the number of instructions to be disassembled (default is 1).&quot;,
 &quot;                If no count argument is entered, and the starting address&quot;,
 &quot;                is entered as a text symbol, then the whole routine will be&quot;,
-&quot;                disassembled.  The count argument is ignored when used with&quot;,
-&quot;                the -r option.&quot;,
+&quot;                disassembled.  The count argument is supported when used with&quot;,
+&quot;                the -r and -f option.&quot;,
 &quot;\nEXAMPLES&quot;,
 &quot;  Disassemble the sys_signal() routine without, and then with, line numbers:\n&quot;,
 &quot;    %s&gt; dis sys_signal&quot;,
diff --git a/kernel.c b/kernel.c
index f01dc2e..e1f0b7e 100644
--- a/kernel.c
+++ b/kernel.c
@@ -1931,16 +1931,10 @@ cmd_dis(void)
                 }
 
                 if (args[++optind]) {
-			if (reverse || forward) {
-				error(INFO, 
-			            &quot;count argument ignored with -%s option\n&quot;,
-				    	reverse ? &quot;r&quot; : &quot;f&quot;);
-			} else {
-                        	req-&gt;count = stol(args[optind], 
+			req-&gt;count = stol(args[optind], 
 					FAULT_ON_ERROR, NULL);
-				req-&gt;flags &amp;= ~GNU_FUNCTION_ONLY;
-				count_entered++;
-			}
+			req-&gt;flags &amp;= ~GNU_FUNCTION_ONLY;
+			count_entered++;
 		}
 
 		if (sources) {
@@ -1992,6 +1986,10 @@ cmd_dis(void)
 			}
 		}
 
+		if (reverse || forward)
+			if (count_entered &amp;&amp; req-&gt;count == 1)
+				reverse = forward = 0;
+
 		if (reverse || forward) {
 			target = req-&gt;addr;
 			if ((sp = value_search(target, NULL)) == NULL)
@@ -2006,14 +2004,19 @@ cmd_dis(void)
 		do_machdep_filter = machdep-&gt;dis_filter(req-&gt;addr, NULL, radix);
 		open_tmpfile();
 
-		if (reverse)
-			sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,
-				(target - req-&gt;addr) ? target - req-&gt;addr : 1, 
-				req-&gt;addr);
-		else
+		if (reverse || forward) {
+			if (count_entered &amp;&amp; req-&gt;count)
+				sprintf(buf5, &quot;x/%s%ldi 0x%lx&quot;, reverse ? &quot;-&quot; : &quot;&quot;,
+					req-&gt;count, target);
+			else
+				sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,
+					forward ?  req-&gt;addr2 - req-&gt;addr : 
+					(target - req-&gt;addr) ? target - req-&gt;addr : 1, 
+					forward ? target : req-&gt;addr);
+		} else
 			sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,
 				count_entered &amp;&amp; req-&gt;count ? req-&gt;count : 
-				forward || req-&gt;flags &amp; GNU_FUNCTION_ONLY ? 
+				req-&gt;flags &amp; GNU_FUNCTION_ONLY ? 
 				req-&gt;addr2 - req-&gt;addr : 1, 
 				req-&gt;addr);
 		gdb_pass_through(buf5, NULL, GNU_RETURN_ON_ERROR);
-- 
2.20.1

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="07791" href="msg07791.html">Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</a></strong>
<ul><li><em>From:</em> Dave Anderson</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07786.html">Re:  [PATCH] crash: dis: introduce count in reverse and forward mode</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07788.html">Re:  [PATCH] timers: add option to show expired	timers only</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07782.html">[PATCH] timers: add option to show expired timers	only</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07791.html">Re:  [PATCH v2] crash: dis: introduce count in reverse and forward mode</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07787"><strong>Date</strong></a></li>
<li><a href="index.html#07787"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
