<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH] OMAP: Serial: Define register access modes in LCR -->
<!--X-From-R13: Ubivaqenw &#60;tbivaqenw.gvNtznvy.pbz> -->
<!--X-Date: Wed, 17 Nov 2010 01:30:26 &#45;0800 -->
<!--X-Message-Id: AANLkTins9SKmugD344NddhpAJ8POGZy2ZS_=dbChm3Ta@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 1289982712&#45;7309&#45;1&#45;git&#45;send&#45;email&#45;Andrei.Emeltchenko.news@gmail.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux ARM: Re: [PATCH] OMAP: Serial: Define register access modes in LCR">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux ARM, Xscale &mdash; Re: [PATCH] OMAP: Serial: Define register access modes in LCR</title>
<link rel="alternate" type="application/rss+xml" title="Linux ARM" href="//feeds.feedburner.com/LinuxArmxscaleEtc">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:1790192168" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" async defer></script>
<h1 itemprop="name">Re: [PATCH] OMAP: Serial: Define register access modes in LCR</h1>
[<a href="msg15784.html">Date Prev</a>][<a href="msg15786.html">Date Next</a>][<a href="msg15784.html">Thread Prev</a>][<a href="msg15787.html">Thread Next</a>][<a href="maillist.html#15785">Date Index</a>][<a href="threads.html#15785">Thread Index</a>] 


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Emeltchenko Andrei &lt;<a href="mailto:Andrei.Emeltchenko.news@DOMAIN.HIDDEN">Andrei.Emeltchenko.news@xxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: [PATCH] OMAP: Serial: Define register access modes in LCR</li>
<li><em>From</em>: Govindraj &lt;<a href="mailto:govindraj.ti@DOMAIN.HIDDEN">govindraj.ti@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 17 Nov 2010 14:36:59 +0530</li>
<li><em>Cc</em>: <a href="mailto:linux-omap@DOMAIN.HIDDEN">linux-omap@xxxxxxxxxxxxxxx</a>, <a href="mailto:linux-kernel@DOMAIN.HIDDEN">linux-kernel@xxxxxxxxxxxxxxx</a>,        <a href="mailto:linux-serial@DOMAIN.HIDDEN">linux-serial@xxxxxxxxxxxxxxx</a>, <a href="mailto:linux-arm@DOMAIN.HIDDEN">linux-arm@xxxxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:1289982712-7309-1-git-send-email-Andrei.Emeltchenko.news@DOMAIN.HIDDEN">1289982712-7309-1-git-send-email-Andrei.Emeltchenko.news@xxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Wed, Nov 17, 2010 at 2:01 PM, Emeltchenko Andrei
&lt;Andrei.Emeltchenko.news@xxxxxxxxx&gt; wrote:
&gt; From: Andrei Emeltchenko &lt;andrei.emeltchenko@xxxxxxxxx&gt;
&gt;
&gt; Access to some registers depends on register access mode
&gt; Three different modes are available for OMAP (at least)
&gt; &#x2022; Operational mode &#xA0; &#xA0; LCR_REG[7] = 0x0
&gt; &#x2022; Configuration mode A LCR_REG[7] = 0x1 and LCR_REG[7:0]! = 0xBF
&gt; &#x2022; Configuration mode B LCR_REG[7] = 0x1 and LCR_REG[7:0] &#xA0;= 0xBF
&gt;
&gt; Define access modes and remove redefinitions and magic numbers
&gt; in serial drivers (and later in bluetooth driver).
&gt;
&gt; Signed-off-by: Andrei Emeltchenko &lt;andrei.emeltchenko@xxxxxxxxx&gt;
&gt; ---
&gt; &#xA0;arch/arm/mach-omap2/serial.c &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;| &#xA0; 12 ++++----
&gt; &#xA0;arch/arm/plat-omap/include/plat/omap-serial.h | &#xA0; &#xA0;9 ------
&gt; &#xA0;drivers/serial/8250.c &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; | &#xA0; 26 +++++++++---------
&gt; &#xA0;drivers/serial/omap-serial.c &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;| &#xA0; 34 ++++++++++++------------
&gt; &#xA0;include/linux/serial_reg.h &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;| &#xA0; &#xA0;7 +++++
&gt; &#xA0;5 files changed, 43 insertions(+), 45 deletions(-)
&gt;
&gt; diff --git a/arch/arm/mach-omap2/serial.c b/arch/arm/mach-omap2/serial.c
&gt; index edd7c99de38dde5bf877788fb4e48055c0d9fbfa..14c87157d70758d4203593f78f2eaf4c2f2cca68 100644
&gt; --- a/arch/arm/mach-omap2/serial.c
&gt; +++ b/arch/arm/mach-omap2/serial.c
&gt; @@ -218,7 +218,7 @@ static void omap_uart_save_context(struct omap_uart_state *uart)
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;return;
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;lcr = serial_read_reg(uart, UART_LCR);
&gt; - &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, 0xBF);
&gt; + &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;uart-&gt;dll = serial_read_reg(uart, UART_DLL);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;uart-&gt;dlh = serial_read_reg(uart, UART_DLM);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_LCR, lcr);
&gt; @@ -226,7 +226,7 @@ static void omap_uart_save_context(struct omap_uart_state *uart)
&gt; &#xA0; &#xA0; &#xA0; &#xA0;uart-&gt;sysc = serial_read_reg(uart, UART_OMAP_SYSC);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;uart-&gt;scr = serial_read_reg(uart, UART_OMAP_SCR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;uart-&gt;wer = serial_read_reg(uart, UART_OMAP_WER);
&gt; - &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, 0x80);
&gt; + &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;uart-&gt;mcr = serial_read_reg(uart, UART_MCR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_LCR, lcr);
&gt;
&gt; @@ -250,19 +250,19 @@ static void omap_uart_restore_context(struct omap_uart_state *uart)
&gt; &#xA0; &#xA0; &#xA0; &#xA0;else
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);
&gt;
&gt; - &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, 0xBF); /* Config B mode */
&gt; + &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;efr = serial_read_reg(uart, UART_EFR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_EFR, UART_EFR_ECB);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_LCR, 0x0); /* Operational mode */
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_IER, 0x0);
&gt; - &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, 0xBF); /* Config B mode */
&gt; + &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_DLL, uart-&gt;dll);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_DLM, uart-&gt;dlh);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_LCR, 0x0); /* Operational mode */
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_IER, uart-&gt;ier);
&gt; - &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, 0x80);
&gt; + &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_MCR, uart-&gt;mcr);
&gt; - &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, 0xBF); /* Config B mode */
&gt; + &#xA0; &#xA0; &#xA0; serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_EFR, efr);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_LCR, UART_LCR_WLEN8);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_write_reg(uart, UART_OMAP_SCR, uart-&gt;scr);
&gt; diff --git a/arch/arm/plat-omap/include/plat/omap-serial.h b/arch/arm/plat-omap/include/plat/omap-serial.h
&gt; index 6a17880146111ddfabef564583e464c1c75bb379..b3e0bad9b77eb5138fe01253bd99bfc62bd6ac2d 100644
&gt; --- a/arch/arm/plat-omap/include/plat/omap-serial.h
&gt; +++ b/arch/arm/plat-omap/include/plat/omap-serial.h
&gt; @@ -33,15 +33,6 @@
&gt;
&gt; &#xA0;#define OMAP_MODE13X_SPEED &#xA0; &#xA0; 230400
&gt;
&gt; -/*
&gt; - * LCR = 0XBF: Switch to Configuration Mode B.
&gt; - * In configuration mode b allow access
&gt; - * to EFR,DLL,DLH.
&gt; - * Reference OMAP TRM Chapter 17
&gt; - * Section: 1.4.3 Mode Selection
&gt; - */
&gt; -#define OMAP_UART_LCR_CONF_MDB 0XBF
&gt; -
&gt; &#xA0;/* WER = 0x7F
&gt; &#xA0;* Enable module level wakeup in WER reg
&gt; &#xA0;*/
&gt; diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
&gt; index 4d8e14b7aa931bcf3de11c6e5805005e0bf413ca..aaf9907e6014f547f28a617504125e6ffd177cbe 100644
&gt; --- a/drivers/serial/8250.c
&gt; +++ b/drivers/serial/8250.c
&gt; @@ -653,13 +653,13 @@ static void serial8250_set_sleep(struct uart_8250_port *p, int sleep)
&gt; &#xA0;{
&gt; &#xA0; &#xA0; &#xA0; &#xA0;if (p-&gt;capabilities &amp; UART_CAP_SLEEP) {
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;if (p-&gt;capabilities &amp; UART_CAP_EFR) {
&gt; - &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(p, UART_LCR, 0xBF);
&gt; + &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(p, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(p, UART_EFR, UART_EFR_ECB);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(p, UART_LCR, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;}
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;if (p-&gt;capabilities &amp; UART_CAP_EFR) {
&gt; - &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(p, UART_LCR, 0xBF);
&gt; + &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(p, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(p, UART_EFR, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(p, UART_LCR, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;}
&gt; @@ -752,7 +752,7 @@ static int size_fifo(struct uart_8250_port *up)
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_MCR, UART_MCR_LOOP);
&gt; - &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;old_dl = serial_dl_read(up);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_dl_write(up, 0x0001);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_LCR, 0x03);
&gt; @@ -764,7 +764,7 @@ static int size_fifo(struct uart_8250_port *up)
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_inp(up, UART_RX);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_FCR, old_fcr);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_MCR, old_mcr);
&gt; - &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_dl_write(up, old_dl);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_LCR, old_lcr);
&gt;
&gt; @@ -782,7 +782,7 @@ static unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)
&gt; &#xA0; &#xA0; &#xA0; &#xA0;unsigned int id;
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;old_lcr = serial_inp(p, UART_LCR);
&gt; - &#xA0; &#xA0; &#xA0; serial_outp(p, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_outp(p, UART_LCR, UART_LCR_CONF_MODE_A);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;old_dll = serial_inp(p, UART_DLL);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;old_dlm = serial_inp(p, UART_DLM);
&gt; @@ -836,7 +836,7 @@ static void autoconfig_has_efr(struct uart_8250_port *up)
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * recommended for new designs).
&gt; &#xA0; &#xA0; &#xA0; &#xA0; */
&gt; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;acr = 0;
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, 0xBF);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, UART_EFR_ECB);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, 0x00);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;id1 = serial_icr_read(up, UART_ID1);
&gt; @@ -945,7 +945,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * Check for presence of the EFR when DLAB is set.
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * Only ST16C650V1 UARTs pass this test.
&gt; &#xA0; &#xA0; &#xA0; &#xA0; */
&gt; - &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;if (serial_in(up, UART_EFR) == 0) {
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_EFR, 0xA8);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;if (serial_in(up, UART_EFR) != 0) {
&gt; @@ -963,7 +963,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * Maybe it requires 0xbf to be written to the LCR.
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * (other ST16C650V2 UARTs, TI16C752A, etc)
&gt; &#xA0; &#xA0; &#xA0; &#xA0; */
&gt; - &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, 0xBF);
&gt; + &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;if (serial_in(up, UART_EFR) == 0 &amp;&amp; !broken_efr(up)) {
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;DEBUG_AUTOCONF(&quot;EFRv2 &quot;);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;autoconfig_has_efr(up);
&gt; @@ -1024,7 +1024,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;status1 = serial_in(up, UART_IIR) &gt;&gt; 5;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
&gt; - &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;status2 = serial_in(up, UART_IIR) &gt;&gt; 5;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
&gt; @@ -1183,7 +1183,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * We also initialise the EFR (if any) to zero for later. &#xA0;The
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * EFR occupies the same register location as the FCR and IIR.
&gt; &#xA0; &#xA0; &#xA0; &#xA0; */
&gt; - &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, 0xBF);
&gt; + &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_EFR, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_LCR, 0);
&gt;
&gt; @@ -1952,7 +1952,7 @@ static int serial8250_startup(struct uart_port *port)
&gt; &#xA0; &#xA0; &#xA0; &#xA0;if (up-&gt;port.type == PORT_16C950) {
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;/* Wake up and initialize UART */
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;acr = 0;
&gt; - &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, 0xBF);
&gt; + &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_EFR, UART_EFR_ECB);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_IER, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_LCR, 0);
&gt; @@ -2002,7 +2002,7 @@ static int serial8250_startup(struct uart_port *port)
&gt; &#xA0; &#xA0; &#xA0; &#xA0;if (up-&gt;port.type == PORT_16850) {
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;unsigned char fctr;
&gt;
&gt; - &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, 0xbf);
&gt; + &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;fctr = serial_inp(up, UART_FCTR) &amp; ~(UART_FCTR_RX|UART_FCTR_TX);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_FCTR, fctr | UART_FCTR_TRGD | UART_FCTR_RX);
&gt; @@ -2363,7 +2363,7 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;if (termios-&gt;c_cflag &amp; CRTSCTS)
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;efr |= UART_EFR_CTS;
&gt;
&gt; - &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, 0xBF);
&gt; + &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_outp(up, UART_EFR, efr);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;}
&gt;
&gt; diff --git a/drivers/serial/omap-serial.c b/drivers/serial/omap-serial.c
&gt; index 03a96db67de4a5b3120e094b25e10e2364b8be86..1201eff1831e976910cefebed09882c26e2fcf01 100644
&gt; --- a/drivers/serial/omap-serial.c
&gt; +++ b/drivers/serial/omap-serial.c
&gt; @@ -570,7 +570,7 @@ serial_omap_configure_xonxoff
&gt; &#xA0; &#xA0; &#xA0; &#xA0;unsigned char efr = 0;
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;lcr = serial_in(up, UART_LCR);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;efr = serial_in(up, UART_EFR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, up-&gt;efr &amp; ~UART_EFR_ECB);
&gt;
&gt; @@ -598,7 +598,7 @@ serial_omap_configure_xonxoff
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;efr |= OMAP_UART_SW_RX;
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, up-&gt;efr | UART_EFR_ECB);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;mcr = serial_in(up, UART_MCR);
&gt;
&gt; @@ -612,14 +612,14 @@ serial_omap_configure_xonxoff
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;mcr |= UART_MCR_XONANY;
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_MCR, up-&gt;mcr | UART_MCR_TCRTLR);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;/* Enable special char function UARTi.EFR_REG[5] and
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * load the new software flow control mode IXON or IXOFF
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * and restore the UARTi.EFR_REG[4] ENHANCED_EN value.
&gt; &#xA0; &#xA0; &#xA0; &#xA0; */
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, efr | UART_EFR_SCD);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_MCR, up-&gt;mcr &amp; ~UART_MCR_TCRTLR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, up-&gt;lcr);
&gt; @@ -724,22 +724,22 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * baud clock is not running
&gt; &#xA0; &#xA0; &#xA0; &#xA0; * DLL_REG and DLH_REG set to 0.
&gt; &#xA0; &#xA0; &#xA0; &#xA0; */
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_DLL, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_DLM, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, 0);
&gt;
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;efr = serial_in(up, UART_EFR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, up-&gt;efr | UART_EFR_ECB);
&gt;
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;mcr = serial_in(up, UART_MCR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_MCR, up-&gt;mcr | UART_MCR_TCRTLR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;/* FIFO ENABLE, DMA MODE */
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_FCR, up-&gt;fcr);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;if (up-&gt;use_dma) {
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_TI752_TLR, 0);
&gt; @@ -748,27 +748,27 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
&gt; &#xA0; &#xA0; &#xA0; &#xA0;}
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, up-&gt;efr);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_MCR, up-&gt;mcr);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;/* Protocol, Baud Rate, and Interrupt Settings */
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;efr = serial_in(up, UART_EFR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, up-&gt;efr | UART_EFR_ECB);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_IER, 0);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_DLL, quot &amp; 0xff); &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;/* LS of divisor */
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_DLM, quot &gt;&gt; 8); &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;/* MS of divisor */
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_IER, up-&gt;ier);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, up-&gt;efr);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, cval);
&gt; @@ -782,18 +782,18 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;if (termios-&gt;c_cflag &amp; CRTSCTS) {
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;efr |= (UART_EFR_CTS | UART_EFR_RTS);
&gt; - &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;mcr = serial_in(up, UART_MCR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_MCR, up-&gt;mcr | UART_MCR_TCRTLR);
&gt;
&gt; - &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;up-&gt;efr = serial_in(up, UART_EFR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, up-&gt;efr | UART_EFR_ECB);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, efr); /* Enable AUTORTS and AUTOCTS */
&gt; - &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_DLAB);
&gt; + &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_MCR, up-&gt;mcr | UART_MCR_RTS);
&gt; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, cval);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;}
&gt; @@ -815,13 +815,13 @@ serial_omap_pm(struct uart_port *port, unsigned int state,
&gt; &#xA0; &#xA0; &#xA0; &#xA0;unsigned char efr;
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;dev_dbg(up-&gt;port.dev, &quot;serial_omap_pm+%d\n&quot;, up-&gt;pdev-&gt;id);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;efr = serial_in(up, UART_EFR);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, efr | UART_EFR_ECB);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, 0);
&gt;
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);
&gt; - &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
&gt; + &#xA0; &#xA0; &#xA0; serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_EFR, efr);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;serial_out(up, UART_LCR, 0);
&gt; &#xA0; &#xA0; &#xA0; &#xA0;/* Enable module level wake up */
&gt; diff --git a/include/linux/serial_reg.h b/include/linux/serial_reg.h
&gt; index 6f3823474e6c070bd8456d4dd70559f4e18f2500..3ecb71a9e505901c1a0ff3a3780ba29d3c4c3741 100644
&gt; --- a/include/linux/serial_reg.h
&gt; +++ b/include/linux/serial_reg.h
&gt; @@ -99,6 +99,13 @@
&gt; &#xA0;#define UART_LCR_WLEN7 &#xA0; &#xA0; &#xA0; &#xA0; 0x02 /* Wordlength: 7 bits */
&gt; &#xA0;#define UART_LCR_WLEN8 &#xA0; &#xA0; &#xA0; &#xA0; 0x03 /* Wordlength: 8 bits */
&gt;
&gt; +/*
&gt; + * Access to some registers depends on register access / configuration
&gt; + * mode.
&gt; + */
&gt; +#define UART_LCR_CONF_MODE_A &#xA0; UART_LCR_DLAB &#xA0; /* Configutation mode A */
&gt; +#define UART_LCR_CONF_MODE_B &#xA0; 0xBF &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;/* Configutation mode B */

Looks fine to me.

Acked-by: Govindraj.R &lt;govindraj.raja@xxxxxx&gt;

--
Regards,
Govindraj.R

&gt; +
&gt; &#xA0;#define UART_MCR &#xA0; &#xA0; &#xA0; 4 &#xA0; &#xA0; &#xA0; /* Out: Modem Control Register */
&gt; &#xA0;#define UART_MCR_CLKSEL &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
&gt; &#xA0;#define UART_MCR_TCRTLR &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
&gt; --
&gt; 1.7.0.4
&gt;
&gt; --
&gt; To unsubscribe from this list: send the line &quot;unsubscribe linux-serial&quot; in
&gt; the body of a message to majordomo@xxxxxxxxxxxxxxx
&gt; More majordomo info at &#xA0;<a  rel="nofollow" href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a>
&gt;

_______________________________________________
linux-arm mailing list
linux-arm@xxxxxxxxxxxxxxxxxxx
<a  rel="nofollow" href="http://lists.infradead.org/mailman/listinfo/linux-arm">http://lists.infradead.org/mailman/listinfo/linux-arm</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="15784" href="msg15784.html">[PATCH] OMAP: Serial: Define register access modes in LCR</a></strong>
<ul><li><em>From:</em> Emeltchenko Andrei</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg15784.html">[PATCH] OMAP: Serial: Define register access modes in LCR</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg15786.html">arm-linux-ld: BFD 2.16.1 assertion fail</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg15784.html">[PATCH] OMAP: Serial: Define register access modes in LCR</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg15787.html">Re: [PATCH] OMAP: Serial: Define register access modes in LCR</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#15785"><strong>Date</strong></a></li>
<li><a href="threads.html#15785"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm/>[Linux&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm-msm/>[Linux&nbsp;ARM&nbsp;MSM]</a>
&nbsp;
&nbsp;
<a href=/lists/arm-kernel/>[Linux&nbsp;ARM&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-arm/>[Fedora&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm-msm/>[Linux&nbsp;ARM&nbsp;MSM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;OMAP]</a>
&nbsp;
&nbsp;
<a href=/lists/mips/>[Linux&nbsp;MIPS]</a>
&nbsp;
&nbsp;
<a href=/lists/ecos/>[ECOS]</a>
&nbsp;
&nbsp;
<a href=/lists/asterisk/>[Asterisk&nbsp;Internet&nbsp;PBX]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-api/>[Linux&nbsp;API]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
