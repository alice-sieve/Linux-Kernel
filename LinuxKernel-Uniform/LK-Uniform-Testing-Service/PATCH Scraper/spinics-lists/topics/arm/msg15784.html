<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH] OMAP: Serial: Define register access modes in LCR -->
<!--X-From-R13: Szrygpuraxb Oaqerv &#60;Oaqerv.Szrygpuraxb.arjfNtznvy.pbz> -->
<!--X-Date: Wed, 17 Nov 2010 00:41:02 &#45;0800 -->
<!--X-Message-Id: 1289982712&#45;7309&#45;1&#45;git&#45;send&#45;email&#45;Andrei.Emeltchenko.news@gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux ARM: [PATCH] OMAP: Serial: Define register access modes in LCR">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux ARM, Xscale &mdash; [PATCH] OMAP: Serial: Define register access modes in LCR</title>
<link rel="alternate" type="application/rss+xml" title="Linux ARM" href="//feeds.feedburner.com/LinuxArmxscaleEtc">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:1790192168" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" async defer></script>
<h1 itemprop="name">[PATCH] OMAP: Serial: Define register access modes in LCR</h1>
[<a href="msg15783.html">Date Prev</a>][<a href="msg15785.html">Date Next</a>][<a href="msg15781.html">Thread Prev</a>][<a href="msg15785.html">Thread Next</a>][<a href="maillist.html#15784">Date Index</a>][<a href="threads.html#15784">Thread Index</a>] 


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:linux-omap@DOMAIN.HIDDEN">linux-omap@xxxxxxxxxxxxxxx</a>, <a href="mailto:linux-kernel@DOMAIN.HIDDEN">linux-kernel@xxxxxxxxxxxxxxx</a>,        <a href="mailto:linux-arm@DOMAIN.HIDDEN">linux-arm@xxxxxxxxxxxxxxxxxxx</a>, <a href="mailto:linux-serial@DOMAIN.HIDDEN">linux-serial@xxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: [PATCH] OMAP: Serial: Define register access modes in LCR</li>
<li><em>From</em>: Emeltchenko Andrei &lt;<a href="mailto:Andrei.Emeltchenko.news@DOMAIN.HIDDEN">Andrei.Emeltchenko.news@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 17 Nov 2010 10:31:52 +0200</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>From: Andrei Emeltchenko &lt;andrei.emeltchenko@xxxxxxxxx&gt;

Access to some registers depends on register access mode
Three different modes are available for OMAP (at least)
&#xE2; Operational mode     LCR_REG[7] = 0x0
&#xE2; Configuration mode A LCR_REG[7] = 0x1 and LCR_REG[7:0]! = 0xBF
&#xE2; Configuration mode B LCR_REG[7] = 0x1 and LCR_REG[7:0]  = 0xBF

Define access modes and remove redefinitions and magic numbers
in serial drivers (and later in bluetooth driver).

Signed-off-by: Andrei Emeltchenko &lt;andrei.emeltchenko@xxxxxxxxx&gt;
---
 arch/arm/mach-omap2/serial.c                  |   12 ++++----
 arch/arm/plat-omap/include/plat/omap-serial.h |    9 ------
 drivers/serial/8250.c                         |   26 +++++++++---------
 drivers/serial/omap-serial.c                  |   34 ++++++++++++------------
 include/linux/serial_reg.h                    |    7 +++++
 5 files changed, 43 insertions(+), 45 deletions(-)

diff --git a/arch/arm/mach-omap2/serial.c b/arch/arm/mach-omap2/serial.c
index edd7c99de38dde5bf877788fb4e48055c0d9fbfa..14c87157d70758d4203593f78f2eaf4c2f2cca68 100644
--- a/arch/arm/mach-omap2/serial.c
+++ b/arch/arm/mach-omap2/serial.c
@@ -218,7 +218,7 @@ static void omap_uart_save_context(struct omap_uart_state *uart)
 		return;
 
 	lcr = serial_read_reg(uart, UART_LCR);
-	serial_write_reg(uart, UART_LCR, 0xBF);
+	serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_B);
 	uart-&gt;dll = serial_read_reg(uart, UART_DLL);
 	uart-&gt;dlh = serial_read_reg(uart, UART_DLM);
 	serial_write_reg(uart, UART_LCR, lcr);
@@ -226,7 +226,7 @@ static void omap_uart_save_context(struct omap_uart_state *uart)
 	uart-&gt;sysc = serial_read_reg(uart, UART_OMAP_SYSC);
 	uart-&gt;scr = serial_read_reg(uart, UART_OMAP_SCR);
 	uart-&gt;wer = serial_read_reg(uart, UART_OMAP_WER);
-	serial_write_reg(uart, UART_LCR, 0x80);
+	serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_A);
 	uart-&gt;mcr = serial_read_reg(uart, UART_MCR);
 	serial_write_reg(uart, UART_LCR, lcr);
 
@@ -250,19 +250,19 @@ static void omap_uart_restore_context(struct omap_uart_state *uart)
 	else
 		serial_write_reg(uart, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);
 
-	serial_write_reg(uart, UART_LCR, 0xBF); /* Config B mode */
+	serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_B);
 	efr = serial_read_reg(uart, UART_EFR);
 	serial_write_reg(uart, UART_EFR, UART_EFR_ECB);
 	serial_write_reg(uart, UART_LCR, 0x0); /* Operational mode */
 	serial_write_reg(uart, UART_IER, 0x0);
-	serial_write_reg(uart, UART_LCR, 0xBF); /* Config B mode */
+	serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_B);
 	serial_write_reg(uart, UART_DLL, uart-&gt;dll);
 	serial_write_reg(uart, UART_DLM, uart-&gt;dlh);
 	serial_write_reg(uart, UART_LCR, 0x0); /* Operational mode */
 	serial_write_reg(uart, UART_IER, uart-&gt;ier);
-	serial_write_reg(uart, UART_LCR, 0x80);
+	serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_A);
 	serial_write_reg(uart, UART_MCR, uart-&gt;mcr);
-	serial_write_reg(uart, UART_LCR, 0xBF); /* Config B mode */
+	serial_write_reg(uart, UART_LCR, UART_LCR_CONF_MODE_B);
 	serial_write_reg(uart, UART_EFR, efr);
 	serial_write_reg(uart, UART_LCR, UART_LCR_WLEN8);
 	serial_write_reg(uart, UART_OMAP_SCR, uart-&gt;scr);
diff --git a/arch/arm/plat-omap/include/plat/omap-serial.h b/arch/arm/plat-omap/include/plat/omap-serial.h
index 6a17880146111ddfabef564583e464c1c75bb379..b3e0bad9b77eb5138fe01253bd99bfc62bd6ac2d 100644
--- a/arch/arm/plat-omap/include/plat/omap-serial.h
+++ b/arch/arm/plat-omap/include/plat/omap-serial.h
@@ -33,15 +33,6 @@
 
 #define OMAP_MODE13X_SPEED	230400
 
-/*
- * LCR = 0XBF: Switch to Configuration Mode B.
- * In configuration mode b allow access
- * to EFR,DLL,DLH.
- * Reference OMAP TRM Chapter 17
- * Section: 1.4.3 Mode Selection
- */
-#define OMAP_UART_LCR_CONF_MDB	0XBF
-
 /* WER = 0x7F
  * Enable module level wakeup in WER reg
  */
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 4d8e14b7aa931bcf3de11c6e5805005e0bf413ca..aaf9907e6014f547f28a617504125e6ffd177cbe 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -653,13 +653,13 @@ static void serial8250_set_sleep(struct uart_8250_port *p, int sleep)
 {
 	if (p-&gt;capabilities &amp; UART_CAP_SLEEP) {
 		if (p-&gt;capabilities &amp; UART_CAP_EFR) {
-			serial_outp(p, UART_LCR, 0xBF);
+			serial_outp(p, UART_LCR, UART_LCR_CONF_MODE_B);
 			serial_outp(p, UART_EFR, UART_EFR_ECB);
 			serial_outp(p, UART_LCR, 0);
 		}
 		serial_outp(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
 		if (p-&gt;capabilities &amp; UART_CAP_EFR) {
-			serial_outp(p, UART_LCR, 0xBF);
+			serial_outp(p, UART_LCR, UART_LCR_CONF_MODE_B);
 			serial_outp(p, UART_EFR, 0);
 			serial_outp(p, UART_LCR, 0);
 		}
@@ -752,7 +752,7 @@ static int size_fifo(struct uart_8250_port *up)
 	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |
 		    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
 	serial_outp(up, UART_MCR, UART_MCR_LOOP);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
+	serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
 	old_dl = serial_dl_read(up);
 	serial_dl_write(up, 0x0001);
 	serial_outp(up, UART_LCR, 0x03);
@@ -764,7 +764,7 @@ static int size_fifo(struct uart_8250_port *up)
 		serial_inp(up, UART_RX);
 	serial_outp(up, UART_FCR, old_fcr);
 	serial_outp(up, UART_MCR, old_mcr);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
+	serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
 	serial_dl_write(up, old_dl);
 	serial_outp(up, UART_LCR, old_lcr);
 
@@ -782,7 +782,7 @@ static unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)
 	unsigned int id;
 
 	old_lcr = serial_inp(p, UART_LCR);
-	serial_outp(p, UART_LCR, UART_LCR_DLAB);
+	serial_outp(p, UART_LCR, UART_LCR_CONF_MODE_A);
 
 	old_dll = serial_inp(p, UART_DLL);
 	old_dlm = serial_inp(p, UART_DLM);
@@ -836,7 +836,7 @@ static void autoconfig_has_efr(struct uart_8250_port *up)
 	 * recommended for new designs).
 	 */
 	up-&gt;acr = 0;
-	serial_out(up, UART_LCR, 0xBF);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	serial_out(up, UART_EFR, UART_EFR_ECB);
 	serial_out(up, UART_LCR, 0x00);
 	id1 = serial_icr_read(up, UART_ID1);
@@ -945,7 +945,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	 * Check for presence of the EFR when DLAB is set.
 	 * Only ST16C650V1 UARTs pass this test.
 	 */
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
+	serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
 	if (serial_in(up, UART_EFR) == 0) {
 		serial_outp(up, UART_EFR, 0xA8);
 		if (serial_in(up, UART_EFR) != 0) {
@@ -963,7 +963,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	 * Maybe it requires 0xbf to be written to the LCR.
 	 * (other ST16C650V2 UARTs, TI16C752A, etc)
 	 */
-	serial_outp(up, UART_LCR, 0xBF);
+	serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	if (serial_in(up, UART_EFR) == 0 &amp;&amp; !broken_efr(up)) {
 		DEBUG_AUTOCONF(&quot;EFRv2 &quot;);
 		autoconfig_has_efr(up);
@@ -1024,7 +1024,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
 	status1 = serial_in(up, UART_IIR) &gt;&gt; 5;
 	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
+	serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
 	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
 	status2 = serial_in(up, UART_IIR) &gt;&gt; 5;
 	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
@@ -1183,7 +1183,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 	 * We also initialise the EFR (if any) to zero for later.  The
 	 * EFR occupies the same register location as the FCR and IIR.
 	 */
-	serial_outp(up, UART_LCR, 0xBF);
+	serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	serial_outp(up, UART_EFR, 0);
 	serial_outp(up, UART_LCR, 0);
 
@@ -1952,7 +1952,7 @@ static int serial8250_startup(struct uart_port *port)
 	if (up-&gt;port.type == PORT_16C950) {
 		/* Wake up and initialize UART */
 		up-&gt;acr = 0;
-		serial_outp(up, UART_LCR, 0xBF);
+		serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
 		serial_outp(up, UART_EFR, UART_EFR_ECB);
 		serial_outp(up, UART_IER, 0);
 		serial_outp(up, UART_LCR, 0);
@@ -2002,7 +2002,7 @@ static int serial8250_startup(struct uart_port *port)
 	if (up-&gt;port.type == PORT_16850) {
 		unsigned char fctr;
 
-		serial_outp(up, UART_LCR, 0xbf);
+		serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
 
 		fctr = serial_inp(up, UART_FCTR) &amp; ~(UART_FCTR_RX|UART_FCTR_TX);
 		serial_outp(up, UART_FCTR, fctr | UART_FCTR_TRGD | UART_FCTR_RX);
@@ -2363,7 +2363,7 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 		if (termios-&gt;c_cflag &amp; CRTSCTS)
 			efr |= UART_EFR_CTS;
 
-		serial_outp(up, UART_LCR, 0xBF);
+		serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
 		serial_outp(up, UART_EFR, efr);
 	}
 
diff --git a/drivers/serial/omap-serial.c b/drivers/serial/omap-serial.c
index 03a96db67de4a5b3120e094b25e10e2364b8be86..1201eff1831e976910cefebed09882c26e2fcf01 100644
--- a/drivers/serial/omap-serial.c
+++ b/drivers/serial/omap-serial.c
@@ -570,7 +570,7 @@ serial_omap_configure_xonxoff
 	unsigned char efr = 0;
 
 	up-&gt;lcr = serial_in(up, UART_LCR);
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	up-&gt;efr = serial_in(up, UART_EFR);
 	serial_out(up, UART_EFR, up-&gt;efr &amp; ~UART_EFR_ECB);
 
@@ -598,7 +598,7 @@ serial_omap_configure_xonxoff
 		efr |= OMAP_UART_SW_RX;
 
 	serial_out(up, UART_EFR, up-&gt;efr | UART_EFR_ECB);
-	serial_out(up, UART_LCR, UART_LCR_DLAB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
 
 	up-&gt;mcr = serial_in(up, UART_MCR);
 
@@ -612,14 +612,14 @@ serial_omap_configure_xonxoff
 		up-&gt;mcr |= UART_MCR_XONANY;
 
 	serial_out(up, UART_MCR, up-&gt;mcr | UART_MCR_TCRTLR);
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	serial_out(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);
 	/* Enable special char function UARTi.EFR_REG[5] and
 	 * load the new software flow control mode IXON or IXOFF
 	 * and restore the UARTi.EFR_REG[4] ENHANCED_EN value.
 	 */
 	serial_out(up, UART_EFR, efr | UART_EFR_SCD);
-	serial_out(up, UART_LCR, UART_LCR_DLAB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
 
 	serial_out(up, UART_MCR, up-&gt;mcr &amp; ~UART_MCR_TCRTLR);
 	serial_out(up, UART_LCR, up-&gt;lcr);
@@ -724,22 +724,22 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
 	 * baud clock is not running
 	 * DLL_REG and DLH_REG set to 0.
 	 */
-	serial_out(up, UART_LCR, UART_LCR_DLAB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
 	serial_out(up, UART_DLL, 0);
 	serial_out(up, UART_DLM, 0);
 	serial_out(up, UART_LCR, 0);
 
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 
 	up-&gt;efr = serial_in(up, UART_EFR);
 	serial_out(up, UART_EFR, up-&gt;efr | UART_EFR_ECB);
 
-	serial_out(up, UART_LCR, UART_LCR_DLAB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
 	up-&gt;mcr = serial_in(up, UART_MCR);
 	serial_out(up, UART_MCR, up-&gt;mcr | UART_MCR_TCRTLR);
 	/* FIFO ENABLE, DMA MODE */
 	serial_out(up, UART_FCR, up-&gt;fcr);
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 
 	if (up-&gt;use_dma) {
 		serial_out(up, UART_TI752_TLR, 0);
@@ -748,27 +748,27 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
 	}
 
 	serial_out(up, UART_EFR, up-&gt;efr);
-	serial_out(up, UART_LCR, UART_LCR_DLAB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
 	serial_out(up, UART_MCR, up-&gt;mcr);
 
 	/* Protocol, Baud Rate, and Interrupt Settings */
 
 	serial_out(up, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 
 	up-&gt;efr = serial_in(up, UART_EFR);
 	serial_out(up, UART_EFR, up-&gt;efr | UART_EFR_ECB);
 
 	serial_out(up, UART_LCR, 0);
 	serial_out(up, UART_IER, 0);
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 
 	serial_out(up, UART_DLL, quot &amp; 0xff);          /* LS of divisor */
 	serial_out(up, UART_DLM, quot &gt;&gt; 8);            /* MS of divisor */
 
 	serial_out(up, UART_LCR, 0);
 	serial_out(up, UART_IER, up-&gt;ier);
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 
 	serial_out(up, UART_EFR, up-&gt;efr);
 	serial_out(up, UART_LCR, cval);
@@ -782,18 +782,18 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
 
 	if (termios-&gt;c_cflag &amp; CRTSCTS) {
 		efr |= (UART_EFR_CTS | UART_EFR_RTS);
-		serial_out(up, UART_LCR, UART_LCR_DLAB);
+		serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
 
 		up-&gt;mcr = serial_in(up, UART_MCR);
 		serial_out(up, UART_MCR, up-&gt;mcr | UART_MCR_TCRTLR);
 
-		serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+		serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 		up-&gt;efr = serial_in(up, UART_EFR);
 		serial_out(up, UART_EFR, up-&gt;efr | UART_EFR_ECB);
 
 		serial_out(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);
 		serial_out(up, UART_EFR, efr); /* Enable AUTORTS and AUTOCTS */
-		serial_out(up, UART_LCR, UART_LCR_DLAB);
+		serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
 		serial_out(up, UART_MCR, up-&gt;mcr | UART_MCR_RTS);
 		serial_out(up, UART_LCR, cval);
 	}
@@ -815,13 +815,13 @@ serial_omap_pm(struct uart_port *port, unsigned int state,
 	unsigned char efr;
 
 	dev_dbg(up-&gt;port.dev, &quot;serial_omap_pm+%d\n&quot;, up-&gt;pdev-&gt;id);
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	efr = serial_in(up, UART_EFR);
 	serial_out(up, UART_EFR, efr | UART_EFR_ECB);
 	serial_out(up, UART_LCR, 0);
 
 	serial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);
-	serial_out(up, UART_LCR, OMAP_UART_LCR_CONF_MDB);
+	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	serial_out(up, UART_EFR, efr);
 	serial_out(up, UART_LCR, 0);
 	/* Enable module level wake up */
diff --git a/include/linux/serial_reg.h b/include/linux/serial_reg.h
index 6f3823474e6c070bd8456d4dd70559f4e18f2500..3ecb71a9e505901c1a0ff3a3780ba29d3c4c3741 100644
--- a/include/linux/serial_reg.h
+++ b/include/linux/serial_reg.h
@@ -99,6 +99,13 @@
 #define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
 #define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
 
+/*
+ * Access to some registers depends on register access / configuration
+ * mode.
+ */
+#define UART_LCR_CONF_MODE_A	UART_LCR_DLAB	/* Configutation mode A */
+#define UART_LCR_CONF_MODE_B	0xBF		/* Configutation mode B */
+
 #define UART_MCR	4	/* Out: Modem Control Register */
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
-- 
1.7.0.4


_______________________________________________
linux-arm mailing list
linux-arm@xxxxxxxxxxxxxxxxxxx
<a  rel="nofollow" href="http://lists.infradead.org/mailman/listinfo/linux-arm">http://lists.infradead.org/mailman/listinfo/linux-arm</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="15787" href="msg15787.html">Re: [PATCH] OMAP: Serial: Define register access modes in LCR</a></strong>
<ul><li><em>From:</em> Greg KH</li></ul></li>
<li><strong><a name="15785" href="msg15785.html">Re: [PATCH] OMAP: Serial: Define register access modes in LCR</a></strong>
<ul><li><em>From:</em> Govindraj</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg15783.html">Re: Help loading kernel image</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg15785.html">Re: [PATCH] OMAP: Serial: Define register access modes in LCR</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg15781.html">[RFC] OMAP: Serial: Define register access modes in LCR</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg15785.html">Re: [PATCH] OMAP: Serial: Define register access modes in LCR</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#15784"><strong>Date</strong></a></li>
<li><a href="threads.html#15784"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm/>[Linux&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm-msm/>[Linux&nbsp;ARM&nbsp;MSM]</a>
&nbsp;
&nbsp;
<a href=/lists/arm-kernel/>[Linux&nbsp;ARM&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-arm/>[Fedora&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm-msm/>[Linux&nbsp;ARM&nbsp;MSM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;OMAP]</a>
&nbsp;
&nbsp;
<a href=/lists/mips/>[Linux&nbsp;MIPS]</a>
&nbsp;
&nbsp;
<a href=/lists/ecos/>[ECOS]</a>
&nbsp;
&nbsp;
<a href=/lists/asterisk/>[Asterisk&nbsp;Internet&nbsp;PBX]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-api/>[Linux&nbsp;API]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
