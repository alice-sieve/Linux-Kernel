<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock -->
<!--X-From-R13: Oyrk Ybtna &#60;nyrk.xbtnaNbenpyr.pbz> -->
<!--X-Date: Tue, 16 Jul 2019 07:28:22 &#45;0700 -->
<!--X-Message-Id: 32DD898E&#45;0F5E&#45;4A63&#45;9795&#45;F78411B77A98@oracle.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190715192536.104548&#45;1&#45;alex.kogan@oracle.com -->
<!--X-Reference: 20190715192536.104548&#45;4&#45;alex.kogan@oracle.com -->
<!--X-Reference: 77bba626&#45;f3e6&#45;45a8&#45;aae8&#45;43b945d0fab9@redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<meta name="description" content="Linux ARM, OMAP, Xscale Kernel: Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock &mdash; ARM, OMAP, Xscale Linux Kernel</title>
<link rel="alternate" type="application/rss+xml" title="Linux ARM Kernel" href="//feedproxy.google.com/LinuxArmKernel">
<link rel="alternate" type="application/rss+xml" title="Linux ARM Kernel" href="//feeds.feedburner.com/LinuxArmxscaleEtc">
<link rel="alternate" type="application/rss+xml" title="Fedora ARM" href="//feeds.feedburner.com/FedoraArm">
<link rel="alternate" type="application/rss+xml" title="Linux for OMAP" href="//feedproxy.google.com/LinuxOmap">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<td align=right><form action="//www.google.com/cse" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:isdiegq275o" />
    <input type="hidden" name="ie" value="ISO-8859-1" />
    <input type="text" name="q" size="37" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&amp;lang=en" async></script>
<h1 itemprop="name">Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock</h1>
[<a href="msg741342.html">Date Prev</a>][<a href="msg741344.html">Date Next</a>][<a href="msg741302.html">Thread Prev</a>][<a href="msg741351.html">Thread Next</a>][<a href="maillist.html#741343">Date Index</a>][<a href="threads.html#741343">Thread Index</a>] 
<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock</li>
<li><em>From</em>: Alex Kogan &lt;alex.kogan@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Tue, 16 Jul 2019 10:26:56 -0400</li>
<li><em>In-reply-to</em>: &lt;<a href="msg741222.html">77bba626-f3e6-45a8-aae8-43b945d0fab9@redhat.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>
&gt;<i> On Jul 15, 2019, at 5:30 PM, Waiman Long &lt;longman@xxxxxxxxxx&gt; wrote:</i>
&gt;<i> </i>
&gt;<i> On 7/15/19 3:25 PM, Alex Kogan wrote:</i>
&gt;<i>&gt; In CNA, spinning threads are organized in two queues, a main queue for</i>
&gt;<i>&gt; threads running on the same node as the current lock holder, and a</i>
&gt;<i>&gt; secondary queue for threads running on other nodes. At the unlock time,</i>
&gt;<i>&gt; the lock holder scans the main queue looking for a thread running on</i>
&gt;<i>&gt; the same node. If found (call it thread T), all threads in the main queue</i>
&gt;<i>&gt; between the current lock holder and T are moved to the end of the</i>
&gt;<i>&gt; secondary queue, and the lock is passed to T. If such T is not found, the</i>
&gt;<i>&gt; lock is passed to the first node in the secondary queue. Finally, if the</i>
&gt;<i>&gt; secondary queue is empty, the lock is passed to the next thread in the</i>
&gt;<i>&gt; main queue. For more details, see <a  rel="nofollow" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__arxiv.org_abs_1810.05600&amp;d=DwICaQ&amp;c=RoP1YumCXCgaWHvlZYR8PZh8Bv7qIrMUB65eapI_JnE&amp;r=Hvhk3F4omdCk-GE1PTOm3Kn0A7ApWOZ2aZLTuVxFK4k&amp;m=NH4Xld7c5GQcD5N1oCMpapcK4gtC1Lg6WNc__6B-qlo&amp;s=DBj9a52iqQ8TW5raX7fVjytlskLrPc9gseyBQCM0GS0&amp;e=">https://urldefense.proofpoint.com/v2/url?u=https-3A__arxiv.org_abs_1810.05600&amp;d=DwICaQ&amp;c=RoP1YumCXCgaWHvlZYR8PZh8Bv7qIrMUB65eapI_JnE&amp;r=Hvhk3F4omdCk-GE1PTOm3Kn0A7ApWOZ2aZLTuVxFK4k&amp;m=NH4Xld7c5GQcD5N1oCMpapcK4gtC1Lg6WNc__6B-qlo&amp;s=DBj9a52iqQ8TW5raX7fVjytlskLrPc9gseyBQCM0GS0&amp;e=</a> .</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; Note that this variant of CNA may introduce starvation by continuously</i>
&gt;<i>&gt; passing the lock to threads running on the same node. This issue</i>
&gt;<i>&gt; will be addressed later in the series.</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; Enabling CNA is controlled via a new configuration option</i>
&gt;<i>&gt; (NUMA_AWARE_SPINLOCKS). The CNA variant is patched in</i>
&gt;<i>&gt; at the boot time only if we run a multi-node machine, and the new</i>
&gt;<i>&gt; config is enabled. For the time being, the patching requires</i>
&gt;<i>&gt; CONFIG_PARAVIRT_SPINLOCKS to be enabled as well.</i>
&gt;<i>&gt; However, this should be resolved once static_call() is available.</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; Signed-off-by: Alex Kogan &lt;alex.kogan@xxxxxxxxxx&gt;</i>
&gt;<i>&gt; Reviewed-by: Steve Sistare &lt;steven.sistare@xxxxxxxxxx&gt;</i>
&gt;<i>&gt; ---</i>
&gt;<i>&gt; arch/x86/Kconfig                 |  18 +++++</i>
&gt;<i>&gt; arch/x86/include/asm/qspinlock.h |   4 +</i>
&gt;<i>&gt; arch/x86/kernel/alternative.c    |  12 +++</i>
&gt;<i>&gt; kernel/locking/mcs_spinlock.h    |   2 +-</i>
&gt;<i>&gt; kernel/locking/qspinlock.c       |  41 +++++++---</i>
&gt;<i>&gt; kernel/locking/qspinlock_cna.h   | 164 +++++++++++++++++++++++++++++++++++++++</i>
&gt;<i>&gt; 6 files changed, 229 insertions(+), 12 deletions(-)</i>
&gt;<i>&gt; create mode 100644 kernel/locking/qspinlock_cna.h</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</i>
&gt;<i>&gt; index 2bbbd4d1ba31..1d8f80c47687 100644</i>
&gt;<i>&gt; --- a/arch/x86/Kconfig</i>
&gt;<i>&gt; +++ b/arch/x86/Kconfig</i>
&gt;<i>&gt; @@ -1548,6 +1548,24 @@ config NUMA</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; 	  Otherwise, you should say N.</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; +config NUMA_AWARE_SPINLOCKS</i>
&gt;<i>&gt; +	bool &quot;Numa-aware spinlocks&quot;</i>
&gt;<i>&gt; +	depends on NUMA</i>
&gt;<i>&gt; +	# For now, we depend on PARAVIRT_SPINLOCKS to make the patching work.</i>
&gt;<i>&gt; +	# This is awkward, but hopefully would be resolved once static_call()</i>
&gt;<i>&gt; +	# is available.</i>
&gt;<i>&gt; +	depends on PARAVIRT_SPINLOCKS</i>
&gt;<i>&gt; +	default y</i>
&gt;<i>&gt; +	help</i>
&gt;<i>&gt; +	  Introduce NUMA (Non Uniform Memory Access) awareness into</i>
&gt;<i>&gt; +	  the slow path of spinlocks.</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +	  The kernel will try to keep the lock on the same node,</i>
&gt;<i>&gt; +	  thus reducing the number of remote cache misses, while</i>
&gt;<i>&gt; +	  trading some of the short term fairness for better performance.</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +	  Say N if you want absolute first come first serve fairness.</i>
&gt;<i> </i>
&gt;<i> You should also add a dependency on QUEUED_SPINLOCKS to highlight the</i>
&gt;<i> fact that it is a variant of qspinlock. You should also mention that in</i>
&gt;<i> the help text.</i>
Will do.

&gt;<i> </i>
&gt;<i> </i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; config AMD_NUMA</i>
&gt;<i>&gt; 	def_bool y</i>
&gt;<i>&gt; 	prompt &quot;Old style AMD Opteron NUMA detection&quot;</i>
&gt;<i>&gt; diff --git a/arch/x86/include/asm/qspinlock.h b/arch/x86/include/asm/qspinlock.h</i>
&gt;<i>&gt; index bd5ac6cc37db..d9b6c34d5eb4 100644</i>
&gt;<i>&gt; --- a/arch/x86/include/asm/qspinlock.h</i>
&gt;<i>&gt; +++ b/arch/x86/include/asm/qspinlock.h</i>
&gt;<i>&gt; @@ -27,6 +27,10 @@ static __always_inline u32 queued_fetch_set_pending_acquire(struct qspinlock *lo</i>
&gt;<i>&gt; 	return val;</i>
&gt;<i>&gt; }</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; +#ifdef CONFIG_NUMA_AWARE_SPINLOCKS</i>
&gt;<i>&gt; +extern void __cna_queued_spin_lock_slowpath(struct qspinlock *lock, u32 val);</i>
&gt;<i>&gt; +#endif</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; #ifdef CONFIG_PARAVIRT_SPINLOCKS</i>
&gt;<i>&gt; extern void native_queued_spin_lock_slowpath(struct qspinlock *lock, u32 val);</i>
&gt;<i>&gt; extern void __pv_init_lock_hash(void);</i>
&gt;<i>&gt; diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c</i>
&gt;<i>&gt; index 0d57015114e7..1c25f0505ec0 100644</i>
&gt;<i>&gt; --- a/arch/x86/kernel/alternative.c</i>
&gt;<i>&gt; +++ b/arch/x86/kernel/alternative.c</i>
&gt;<i>&gt; @@ -649,6 +649,18 @@ void __init alternative_instructions(void)</i>
&gt;<i>&gt; 				(unsigned long)__smp_locks_end);</i>
&gt;<i>&gt; #endif</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; +#if defined(CONFIG_NUMA_AWARE_SPINLOCKS)</i>
&gt;<i>&gt; +	/*</i>
&gt;<i>&gt; +	 * If we have multiple NUMA nodes, switch from native</i>
&gt;<i>&gt; +	 * to the NUMA-friendly slow path for spin locks.</i>
&gt;<i>&gt; +	 */</i>
&gt;<i>&gt; +	if (nr_node_ids &gt; 1 &amp;&amp; pv_ops.lock.queued_spin_lock_slowpath ==</i>
&gt;<i>&gt; +			native_queued_spin_lock_slowpath) {</i>
&gt;<i>&gt; +		pv_ops.lock.queued_spin_lock_slowpath =</i>
&gt;<i>&gt; +			__cna_queued_spin_lock_slowpath;</i>
&gt;<i>&gt; +	}</i>
&gt;<i>&gt; +#endif</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; 	apply_paravirt(__parainstructions, __parainstructions_end);</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; 	restart_nmi();</i>
&gt;<i>&gt; diff --git a/kernel/locking/mcs_spinlock.h b/kernel/locking/mcs_spinlock.h</i>
&gt;<i>&gt; index bc6d3244e1af..36b802babc88 100644</i>
&gt;<i>&gt; --- a/kernel/locking/mcs_spinlock.h</i>
&gt;<i>&gt; +++ b/kernel/locking/mcs_spinlock.h</i>
&gt;<i>&gt; @@ -17,7 +17,7 @@</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; struct mcs_spinlock {</i>
&gt;<i>&gt; 	struct mcs_spinlock *next;</i>
&gt;<i>&gt; -	int locked; /* 1 if lock acquired */</i>
&gt;<i>&gt; +	u64 locked; /* 1 if lock acquired */</i>
&gt;<i>&gt; 	int count;  /* nesting count, see qspinlock.c */</i>
&gt;<i>&gt; };</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; diff --git a/kernel/locking/qspinlock.c b/kernel/locking/qspinlock.c</i>
&gt;<i>&gt; index 5668466b3006..1ba38f85d0ae 100644</i>
&gt;<i>&gt; --- a/kernel/locking/qspinlock.c</i>
&gt;<i>&gt; +++ b/kernel/locking/qspinlock.c</i>
&gt;<i>&gt; @@ -20,7 +20,7 @@</i>
&gt;<i>&gt;  *          Peter Zijlstra &lt;peterz@xxxxxxxxxxxxx&gt;</i>
&gt;<i>&gt;  */</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; -#ifndef _GEN_PV_LOCK_SLOWPATH</i>
&gt;<i>&gt; +#if !defined(_GEN_PV_LOCK_SLOWPATH) &amp;&amp; !defined(_GEN_CNA_LOCK_SLOWPATH)</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; #include &lt;linux/smp.h&gt;</i>
&gt;<i>&gt; #include &lt;linux/bug.h&gt;</i>
&gt;<i>&gt; @@ -77,18 +77,14 @@</i>
&gt;<i>&gt; #define MAX_NODES	4</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; /*</i>
&gt;<i>&gt; - * On 64-bit architectures, the mcs_spinlock structure will be 16 bytes in</i>
&gt;<i>&gt; - * size and four of them will fit nicely in one 64-byte cacheline. For</i>
&gt;<i>&gt; - * pvqspinlock, however, we need more space for extra data. To accommodate</i>
&gt;<i>&gt; - * that, we insert two more long words to pad it up to 32 bytes. IOW, only</i>
&gt;<i>&gt; - * two of them can fit in a cacheline in this case. That is OK as it is rare</i>
&gt;<i>&gt; - * to have more than 2 levels of slowpath nesting in actual use. We don't</i>
&gt;<i>&gt; - * want to penalize pvqspinlocks to optimize for a rare case in native</i>
&gt;<i>&gt; - * qspinlocks.</i>
&gt;<i>&gt; + * On 64-bit architectures, the mcs_spinlock structure will be 20 bytes in</i>
&gt;<i>&gt; + * size. For pvqspinlock or the NUMA-aware variant, however, we need more</i>
&gt;<i>&gt; + * space for extra data. To accommodate that, we insert two more long words</i>
&gt;<i>&gt; + * to pad it up to 36 bytes.</i>
&gt;<i>&gt;  */</i>
&gt;<i> The 20 bytes figure is wrong. It is actually 24 bytes for 64-bit as the</i>
&gt;<i> mcs_spinlock structure is 8-byte aligned. For better cacheline</i>
&gt;<i> alignment, I will like to keep mcs_spinlock to 16 bytes as before.</i>
&gt;<i> Instead, you can use encode_tail() to store the CNA node pointer in</i>
&gt;<i> &quot;locked&quot;. For instance, use (encode_tail() &lt;&lt; 1) in locked to</i>
&gt;<i> distinguish it from the regular locked=1 value.</i>
I think this can work.
decode_tail() will get the actual node pointer from the encoded value.
And that would keep the size of mcs_spinlock intact.
Good idea, thanks!

BTW, maybe better change those function names to encode_node() / decode_node() then?

&gt;<i>&gt; struct qnode {</i>
&gt;<i>&gt; 	struct mcs_spinlock mcs;</i>
&gt;<i>&gt; -#ifdef CONFIG_PARAVIRT_SPINLOCKS</i>
&gt;<i>&gt; +#if defined(CONFIG_PARAVIRT_SPINLOCKS) || defined(CONFIG_NUMA_AWARE_SPINLOCKS)</i>
&gt;<i>&gt; 	long reserved[2];</i>
&gt;<i>&gt; #endif</i>
&gt;<i>&gt; };</i>
&gt;<i>&gt; @@ -327,7 +323,7 @@ static __always_inline void __pass_mcs_lock(struct mcs_spinlock *node,</i>
&gt;<i>&gt; #define set_locked_empty_mcs	__set_locked_empty_mcs</i>
&gt;<i>&gt; #define pass_mcs_lock		__pass_mcs_lock</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; -#endif /* _GEN_PV_LOCK_SLOWPATH */</i>
&gt;<i>&gt; +#endif /* _GEN_PV_LOCK_SLOWPATH &amp;&amp; _GEN_CNA_LOCK_SLOWPATH */</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; /**</i>
&gt;<i>&gt;  * queued_spin_lock_slowpath - acquire the queued spinlock</i>
&gt;<i>&gt; @@ -600,6 +596,29 @@ void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val)</i>
&gt;<i>&gt; EXPORT_SYMBOL(queued_spin_lock_slowpath);</i>
&gt;<i>&gt; </i>
&gt;<i>&gt; /*</i>
&gt;<i>&gt; + * Generate the code for NUMA-aware spin locks</i>
&gt;<i>&gt; + */</i>
&gt;<i>&gt; +#if !defined(_GEN_CNA_LOCK_SLOWPATH) &amp;&amp; defined(CONFIG_NUMA_AWARE_SPINLOCKS)</i>
&gt;<i>&gt; +#define _GEN_CNA_LOCK_SLOWPATH</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +#undef pv_init_node</i>
&gt;<i>&gt; +#define pv_init_node cna_init_node</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +#undef set_locked_empty_mcs</i>
&gt;<i>&gt; +#define set_locked_empty_mcs		cna_set_locked_empty_mcs</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +#undef pass_mcs_lock</i>
&gt;<i>&gt; +#define pass_mcs_lock			cna_pass_mcs_lock</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +#undef  queued_spin_lock_slowpath</i>
&gt;<i>&gt; +#define queued_spin_lock_slowpath	__cna_queued_spin_lock_slowpath</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +#include &quot;qspinlock_cna.h&quot;</i>
&gt;<i>&gt; +#include &quot;qspinlock.c&quot;</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +#endif</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +/*</i>
&gt;<i>&gt;  * Generate the paravirt code for queued_spin_unlock_slowpath().</i>
&gt;<i>&gt;  */</i>
&gt;<i>&gt; #if !defined(_GEN_PV_LOCK_SLOWPATH) &amp;&amp; defined(CONFIG_PARAVIRT_SPINLOCKS)</i>
&gt;<i>&gt; diff --git a/kernel/locking/qspinlock_cna.h b/kernel/locking/qspinlock_cna.h</i>
&gt;<i>&gt; new file mode 100644</i>
&gt;<i>&gt; index 000000000000..efb9b12b2f9b</i>
&gt;<i>&gt; --- /dev/null</i>
&gt;<i>&gt; +++ b/kernel/locking/qspinlock_cna.h</i>
&gt;<i>&gt; @@ -0,0 +1,164 @@</i>
&gt;<i>&gt; +/* SPDX-License-Identifier: GPL-2.0 */</i>
&gt;<i>&gt; +#ifndef _GEN_CNA_LOCK_SLOWPATH</i>
&gt;<i>&gt; +#error &quot;do not include this file&quot;</i>
&gt;<i>&gt; +#endif</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +#include &lt;linux/topology.h&gt;</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +/*</i>
&gt;<i>&gt; + * Implement a NUMA-aware version of MCS (aka CNA, or compact NUMA-aware lock).</i>
&gt;<i>&gt; + *</i>
&gt;<i>&gt; + * In CNA, spinning threads are organized in two queues, a main queue for</i>
&gt;<i>&gt; + * threads running on the same node as the current lock holder, and a</i>
&gt;<i>&gt; + * secondary queue for threads running on other nodes. At the unlock time,</i>
&gt;<i>&gt; + * the lock holder scans the main queue looking for a thread running on</i>
&gt;<i>&gt; + * the same node. If found (call it thread T), all threads in the main queue</i>
&gt;<i>&gt; + * between the current lock holder and T are moved to the end of the</i>
&gt;<i>&gt; + * secondary queue, and the lock is passed to T. If such T is not found, the</i>
&gt;<i>&gt; + * lock is passed to the first node in the secondary queue. Finally, if the</i>
&gt;<i>&gt; + * secondary queue is empty, the lock is passed to the next thread in the</i>
&gt;<i>&gt; + * main queue. To avoid starvation of threads in the secondary queue,</i>
&gt;<i>&gt; + * those threads are moved back to the head of the main queue</i>
&gt;<i>&gt; + * after a certain expected number of intra-node lock hand-offs.</i>
&gt;<i>&gt; + *</i>
&gt;<i>&gt; + * For more details, see <a  rel="nofollow" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__arxiv.org_abs_1810.05600&amp;d=DwICaQ&amp;c=RoP1YumCXCgaWHvlZYR8PZh8Bv7qIrMUB65eapI_JnE&amp;r=Hvhk3F4omdCk-GE1PTOm3Kn0A7ApWOZ2aZLTuVxFK4k&amp;m=NH4Xld7c5GQcD5N1oCMpapcK4gtC1Lg6WNc__6B-qlo&amp;s=DBj9a52iqQ8TW5raX7fVjytlskLrPc9gseyBQCM0GS0&amp;e=">https://urldefense.proofpoint.com/v2/url?u=https-3A__arxiv.org_abs_1810.05600&amp;d=DwICaQ&amp;c=RoP1YumCXCgaWHvlZYR8PZh8Bv7qIrMUB65eapI_JnE&amp;r=Hvhk3F4omdCk-GE1PTOm3Kn0A7ApWOZ2aZLTuVxFK4k&amp;m=NH4Xld7c5GQcD5N1oCMpapcK4gtC1Lg6WNc__6B-qlo&amp;s=DBj9a52iqQ8TW5raX7fVjytlskLrPc9gseyBQCM0GS0&amp;e=</a> .</i>
&gt;<i>&gt; + *</i>
&gt;<i>&gt; + * Authors: Alex Kogan &lt;alex.kogan@xxxxxxxxxx&gt;</i>
&gt;<i>&gt; + *          Dave Dice &lt;dave.dice@xxxxxxxxxx&gt;</i>
&gt;<i>&gt; + */</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +struct cna_node {</i>
&gt;<i>&gt; +	struct	mcs_spinlock mcs;</i>
&gt;<i>&gt; +	u32	numa_node;</i>
&gt;<i>&gt; +	u32	encoded_tail;</i>
&gt;<i>&gt; +	struct	cna_node *tail;    /* points to the secondary queue tail */</i>
&gt;<i>&gt; +};</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +#define CNA_NODE(ptr) ((struct cna_node *)(ptr))</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +static void cna_init_node(struct mcs_spinlock *node)</i>
&gt;<i>&gt; +{</i>
&gt;<i>&gt; +	struct cna_node *cn = CNA_NODE(node);</i>
&gt;<i>&gt; +	struct mcs_spinlock *base_node;</i>
&gt;<i>&gt; +	int cpuid;</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +	BUILD_BUG_ON(sizeof(struct cna_node) &gt; sizeof(struct qnode));</i>
&gt;<i>&gt; +	/* we store a pointer in the node's @locked field */</i>
&gt;<i>&gt; +	BUILD_BUG_ON(sizeof(uintptr_t) &gt; sizeof_field(struct mcs_spinlock, locked));</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +	cpuid = smp_processor_id();</i>
&gt;<i>&gt; +	cn-&gt;numa_node = cpu_to_node(cpuid);</i>
&gt;<i>&gt; +</i>
&gt;<i>&gt; +	base_node = this_cpu_ptr(&amp;qnodes[0].mcs);</i>
&gt;<i>&gt; +	cn-&gt;encoded_tail = encode_tail(cpuid, base_node-&gt;count - 1);</i>
&gt;<i>&gt; +}</i>
&gt;<i> </i>
&gt;<i> </i>
&gt;<i> I think you can use an early_init call to initialize the numa_node and</i>
&gt;<i> encoded_tail values for all the per-cpu CNA nodes instead of doing it</i>
&gt;<i> every time a node is used. If it turns out that pv_qspinlock is used,</i>
&gt;<i> the pv_node_init() will properly re-initialize it.</i>
Yes, this should work. Thanks.

BTW, should not we initialize `cpu` in pv_init_node() that same way?

&gt;<i> The only thing left</i>
&gt;<i> to do here is perhaps setting tail to NULL.</i>
There is no need to initialize cna_node.tail &#x2014; we never access it unless
the node is at the head of the secondary queue, and in that case we 
initialize it before placing the node at the head of that queue 
(see find_successor()).

Best regards,
&#x2014; Alex

&gt;<i> </i>
&gt;<i> -Longman</i>
&gt;<i> </i>


_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@xxxxxxxxxxxxxxxxxxx
<a  rel="nofollow" href="http://lists.infradead.org/mailman/listinfo/linux-arm-kernel">http://lists.infradead.org/mailman/listinfo/linux-arm-kernel</a>



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="741351" href="msg741351.html">Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock</a></strong>
<ul><li><em>From:</em> Waiman Long</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="741213" href="msg741213.html">[PATCH v3 0/5] Add NUMA-awareness to qspinlock</a></strong>
<ul><li><em>From:</em> Alex Kogan</li></ul></li>
<li><strong><a name="741214" href="msg741214.html">[PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock</a></strong>
<ul><li><em>From:</em> Alex Kogan</li></ul></li>
<li><strong><a name="741222" href="msg741222.html">Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock</a></strong>
<ul><li><em>From:</em> Waiman Long</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg741342.html">Re: [PATCH v2 19/19] drm/mediatek: drop use of drmP.h</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg741344.html">Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg741302.html">Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg741351.html">Re: [PATCH v3 3/5] locking/qspinlock: Introduce CNA into the slow path of qspinlock</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#741343"><strong>Date</strong></a></li>
<li><a href="threads.html#741343"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/kernel/>[Linux&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm/>[Linux&nbsp;ARM&nbsp;(vger)]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm-msm/>[Linux&nbsp;ARM&nbsp;MSM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;Omap]</a>
&nbsp;
&nbsp;
<a href=/lists/centos-arm-devel/>[CentOS&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/arm/>[Linux&nbsp;Arm]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-tegra/>[Linux&nbsp;Tegra]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-arm/>[Fedora&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-samsung-soc/>[Linux&nbsp;for&nbsp;Samsung&nbsp;SOC]</a>
&nbsp;
&nbsp;
<a href=/lists/ecos/>[eCos]</a>
&nbsp;
&nbsp;
<a href=/lists/fastboot/>[Linux&nbsp;Fastboot]</a>
&nbsp;
&nbsp;
<a href=/lists/gcchelp/>[Gcc&nbsp;Help]</a>
&nbsp;
&nbsp;
<a href=/lists/git/>[Git]</a>
&nbsp;
&nbsp;
<a href=/lists/dccp/>[DCCP]</a>
&nbsp;
&nbsp;
<a href=/lists/ietf-ann>[IETF&nbsp;Announce]</a>
&nbsp;
&nbsp;
<a href=/lists/security/>[Security]</a>
&nbsp;
&nbsp;
<a href=/lists/mips/>[Linux&nbsp;MIPS]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }

initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
