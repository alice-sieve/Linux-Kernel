<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH 3/3] autofs &#45; fix AT_NO_AUTOMOUNT not being honored -->
<!--X-From-R13: Wna Yrag &#60;eniraNgurznj.arg> -->
<!--X-Date: Wed, 22 Nov 2017 17:44:01 &#45;0800 -->
<!--X-Message-Id: 74aa625f&#45;29c9&#45;89c8&#45;c58b&#45;f60b183413ed@themaw.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 149438991819.26550.11290804420751932707.stgit@pluto.themaw.net -->
<!--X-Reference: 149438992850.26550.14370272866390445786.stgit@pluto.themaw.net -->
<!--X-Reference: 874lpo2y9e.fsf@notabene.neil.brown.name -->
<!--X-Reference: ed908288&#45;536c&#45;d34a&#45;6d3d&#45;c21bb8fdfc62@themaw.net -->
<!--X-Reference: 8760a1254e.fsf@notabene.neil.brown.name -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored &mdash; Linux AutoFS">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored &mdash; Linux AutoFS</title>
<link rel="alternate" type="application/rss+xml" title="Linux AutoFS" href="//feeds.feedburner.com/autofs">
<script type="text/javascript">
var addthis_config = addthis_config||{};
addthis_config.data_track_addressbar = false;
</script>
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com/cse" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:isdiegq275o" />
    <input type="hidden" name="ie" value="ISO-8859-1" />
    <input type="text" name="q" size="37" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</h1>
[<a href="msg01767.html">Date Prev</a>][<a href="msg01769.html">Date Next</a>][<a href="msg01767.html">Thread Prev</a>][<a href="msg01770.html">Thread Next</a>][<a href="maillist.html#01768">Date Index</a>][<a href="index.html#01768">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: NeilBrown &lt;neilb@xxxxxxxx&gt;, Al Viro &lt;viro@xxxxxxxxxxxxxxxxxx&gt;</li>
<li><em>Subject</em>: Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</li>
<li><em>From</em>: Ian Kent &lt;raven@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Thu, 23 Nov 2017 09:43:51 +0800</li>
<li><em>Cc</em>: Colin Walters &lt;walters@xxxxxxxxxx&gt;, Ondrej Holy &lt;oholy@xxxxxxxxxx&gt;,        autofs mailing list &lt;autofs@xxxxxxxxxxxxxxx&gt;,        Kernel Mailing List &lt;linux-kernel@xxxxxxxxxxxxxxx&gt;,        David Howells &lt;dhowells@xxxxxxxxxx&gt;,        linux-fsdevel &lt;linux-fsdevel@xxxxxxxxxxxxxxx&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg01767.html">8760a1254e.fsf@notabene.neil.brown.name</a>&gt;</li>
<li><em>References</em>: &lt;<a href="msg01593.html">149438991819.26550.11290804420751932707.stgit@pluto.themaw.net</a>&gt; &lt;<a href="msg01595.html">149438992850.26550.14370272866390445786.stgit@pluto.themaw.net</a>&gt; &lt;<a href="msg01764.html">874lpo2y9e.fsf@notabene.neil.brown.name</a>&gt; &lt;<a href="msg01765.html">ed908288-536c-d34a-6d3d-c21bb8fdfc62@themaw.net</a>&gt; &lt;<a href="msg01767.html">8760a1254e.fsf@notabene.neil.brown.name</a>&gt;</li>
<li><em>User-agent</em>: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Thunderbird/52.3.0</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On 23/11/17 08:47, NeilBrown wrote:
&gt; On Wed, Nov 22 2017, Ian Kent wrote:
&gt; 
&gt;&gt; On 21/11/17 09:53, NeilBrown wrote:
&gt;&gt;&gt; On Wed, May 10 2017, Ian Kent wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; The fstatat(2) and statx() calls can pass the flag AT_NO_AUTOMOUNT
&gt;&gt;&gt;&gt; which is meant to clear the LOOKUP_AUTOMOUNT flag and prevent triggering
&gt;&gt;&gt;&gt; of an automount by the call. But this flag is unconditionally cleared
&gt;&gt;&gt;&gt; for all stat family system calls except statx().
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; stat family system calls have always triggered mount requests for the
&gt;&gt;&gt;&gt; negative dentry case in follow_automount() which is intended but prevents
&gt;&gt;&gt;&gt; the fstatat(2) and statx() AT_NO_AUTOMOUNT case from being handled.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; In order to handle the AT_NO_AUTOMOUNT for both system calls the
&gt;&gt;&gt;&gt; negative dentry case in follow_automount() needs to be changed to
&gt;&gt;&gt;&gt; return ENOENT when the LOOKUP_AUTOMOUNT flag is clear (and the other
&gt;&gt;&gt;&gt; required flags are clear).
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; AFAICT this change doesn't have any noticable side effects and may,
&gt;&gt;&gt;&gt; in some use cases (although I didn't see it in testing) prevent
&gt;&gt;&gt;&gt; unnecessary callbacks to the automount daemon.
&gt;&gt;&gt;
&gt;&gt;&gt; Actually, this patch does have a noticeable side effect.
&gt;&gt;
&gt;&gt; That's right.
&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Previously, if /home were an indirect mount point so that /home/neilb
&gt;&gt;&gt; would mount my home directory, &quot;ls -l /home/neilb&quot; would always work.
&gt;&gt;&gt; Now it doesn't.
&gt;&gt;
&gt;&gt; An this is correct too.
&gt;&gt;
&gt;&gt; The previous policy was that a -&gt;lookup() would always cause a mount to
&gt;&gt; occur. It's that policy that prevents the AT_NO_AUTOMOUNT flag from being
&gt;&gt; able to work consistently.
&gt; 
&gt; Just to be clear, the previous policy was:
&gt;  kernel - a lookup would cause a message to be sent to the automount daemon
&gt;  daemon - the receipt of a message would cause a mount to occur.
&gt; 
&gt; Either part of this policy could be changed to allow AT_NO_AUTOMOUNT to
&gt; work reliably.  You chose to change the first.  At the time I thought
&gt; this was a good idea.  I no longer think so.
&gt; 
&gt; Specifically, I think the second part of the policy should be revised a little.
&gt; 
&gt;&gt;
&gt;&gt; If you set the indirect mount &quot;browse&quot; option that will cause the mount
&gt;&gt; point directories for each of the map keys to be pre-created. So a
&gt;&gt; directory listing will show the mount points and an attempt to access
&gt;&gt; anything within the mount point directory will cause it to be mounted.
&gt;&gt;
&gt;&gt; There is still the problem of not knowing map keys when the wildcard
&gt;&gt; map entry is used.
&gt;&gt;
&gt;&gt; Still, stat family systems calls have always had similar problems that
&gt;&gt; prevent consistent behavior.
&gt; 
&gt; Yes, I understand all this.  stat family sys-call have some odd
&gt; behaviours at times like &quot;stat(); open(); fstat()&quot; will result in
&gt; different sets of status info.  This is known.
&gt; The point is that these odd behaviours have changed in a noticeably way
&gt; (contrary to the change log comment) and it isn't clear these changes
&gt; are good.
&gt; 
&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; This happens because &quot;ls&quot; calls 'lstat' on the path and when that fails
&gt;&gt;&gt; with &quot;ENOENT&quot;, it doesn't bother trying to open.
&gt;&gt;
&gt;&gt; I know, I believe the ENOENT is appropriate because there is no mount
&gt;&gt; and no directory at the time this happens.
&gt; 
&gt; Two distinct statements here.  &quot;no mount&quot; and &quot;no directory&quot;.
&gt; If AT_NO_AUTOMOUNT is given (or implicit) the &quot;no mount&quot; is significant
&gt; and shouldn't be changed.   It isn't clear that &quot;no directory&quot; is
&gt; significant.
&gt; If you think of the list of names stored in the autofs filesystem as a
&gt; cache of recently used names from the map, then the directory *does*
&gt; exist (in the map), it is just that the (in-kernel) cache hasn't been
&gt; populated yet.
&gt; Should &quot;AT_NO_AUTOMOUNT&quot; prevent the cache from being populated?
&gt; 
&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; An alternate approach to the problem that this patch addresses is to
&gt;&gt;&gt; *not* change follow_automount() but instead change the automount daemon
&gt;&gt;&gt; and possibly autofs.
&gt;&gt;
&gt;&gt; Perhaps, but the daemon probably doesn't have enough information to
&gt;&gt; make decisions about this so there would need to be something coming
&gt;&gt; from the kernel too.
&gt; 
&gt; I don't think so.
&gt; The daemon already has a promise that upcalls for a given name are
&gt; serialized, and it has the ability to test if a name is already in the
&gt; cache.  This is enough.
&gt; I applied the following patch:
&gt; 
&gt; diff --git a/modules/mount_nfs.c b/modules/mount_nfs.c
&gt; index c558a7381054..7ddfe9c61038 100644
&gt; --- a/modules/mount_nfs.c
&gt; +++ b/modules/mount_nfs.c
&gt; @@ -269,6 +269,11 @@ dont_probe:
&gt;  		free_host_list(&amp;hosts);
&gt;  		return 1;
&gt;  	}
&gt; +	if (!status) {
&gt; +		debug(ap-&gt;logopt, MODPREFIX &quot;created dir, that'll do for now&quot;);
&gt; +		free_host_list(&amp;hosts);
&gt; +		return 0;
&gt; +	}
&gt;  
&gt;  	if (!status)
&gt;  		existed = 0;
&gt; 
&gt; to automount and now it behaves (for NFS mounts) how I would like (though
&gt; there is room for improvement).
&gt; 
&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; When a notification of access for an indirect mount point is received,
&gt;&gt;&gt; it would firstly just create the directory - not triggering a mount.
&gt;&gt;&gt; If another notification is then received (after the directory has been
&gt;&gt;&gt; created), it then triggers the mount.
&gt;&gt;
&gt;&gt; Not sure, perhaps.
&gt;&gt;
&gt;&gt; But I don't think that will work, I've had many problems with this type
&gt;&gt; behavior due to bugs and I think the the same sort of problems would be
&gt;&gt; encountered.
&gt;&gt;
&gt;&gt; The indirect mount &quot;browse&quot; option which behaves very much like what your
&gt;&gt; suggesting is the internal program default, and has been since the initial
&gt;&gt; v5 release. Historically it is disabled on install to maintain backward
&gt;&gt; compatibility with the original Linux autofs (which is also the reason for
&gt;&gt; always triggering an automount on -&gt;lookup()).
&gt;&gt;
&gt;&gt; Perhaps now is the time for that to change.
&gt; 
&gt; Enabling browse mode does resolve this problem when the map is
&gt; enumerable (as you say, wildcards can't be supported).
&gt; But browse mode isn't always wanted.  If you have a very large map, then
&gt; caching all 10,000 entries in the kernel may be a pointless waste of
&gt; time and space.

Indeed, that's the main use of nobrowse indirect maps.

In fact another recent change where I moved the last_used field so it
wouldn't be updated on every walk, to help with mounts never expiring,
also needs at different approach.

Doing that causes more aggressive expiring of automounts which increases
umount to mount churn and leads to increased server load at sites with a
very large number of clients.
 
&gt; 
&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; I suspect this might need changes to autofs to avoid races when two
&gt;&gt;&gt; threads call lstat() on the same path at the same time.  We would need
&gt;&gt;&gt; to ensure that automount didn't see this as two requests.... though
&gt;&gt;&gt; maybe it already has enough locking.
&gt;&gt;&gt;
&gt;&gt;&gt; Does that seem reasonable?  Should we revert this patch (as a
&gt;&gt;&gt; regression) and do something in automount instead?
&gt;&gt;
&gt;&gt; Can you check out the &quot;browse&quot; option behavior before we talk further
&gt;&gt; about this please.
&gt; 
&gt; Done that.
&gt; 
&gt;&gt;
&gt;&gt; The problem in user space now is that there is no way to control
&gt;&gt; whether an indirect mount that uses the &quot;nobrowse&quot; option is triggered
&gt;&gt; or not (using fstatat() or statx()) regardless of the flags used and it's
&gt;&gt; essential the AT_NO_AUTOMOUNT flag work as expected to have user space
&gt;&gt; take more care in not triggering automounts.
&gt; 
&gt; I think that user-space has all the control that it needs.
&gt; There are two cases:
&gt; 1/ daemon receives &quot;missing indirect&quot; message and the directory
&gt;    doesn't currently exist (mkdir() by the daemon succeeds).
&gt;    This could be an AT_NO_AUTOMOUNT lookup, or it could be a full
&gt;    open() or similar.  In either case the directory gets created if
&gt;    the map suggests that the name should exist.  The daemon needs to
&gt;    be careful not to block for long if it goes off-host to check for
&gt;    validity of the name.

Aren't you assuming the the daemon only receives these lookups
on the last path component?

Intermediate path components that can trigger an automount must
be treated as not having AT_NO_AUTOMOUNT in order for the walk to
continue or fail at that point.

&gt; 
&gt; 2/ daemon received &quot;missing indirect&quot; message and the directory
&gt;    *does* exist (mkdir() by daemon fails with -EEXIST).
&gt;    This cannot be an AT_NO_AUTOMOUNT lookup, it must be a lookup
&gt;    intended to trigger automounts.  In this case, we trigger the
&gt;    mount.

An fstatat(&lt;path&gt;, AT_NO_AUTOMOUNT) on a browse indirect map entry
means the directory will exist but user space has asked not to trigger
the mount and return the stat info of the autofs dentry.

Please don't get me wrong, I think the suggestion is good, I just
don't think it's as simple to do as it appears.

&gt; 
&gt; This does lead to an odd behaviour with wildcards.
&gt; If /misc is a map with a wildcard entry, then
&gt;   ls -d /misc/IDoNotExist
&gt; will create IDoNotExist and report its existence.
&gt;   ls -l /misc/IDoNotExist
&gt; will report that it doesn't exist, but it will still have
&gt; been created.
&gt; 
&gt; Removing the directory after a mount-attempt fails is probably only
&gt; a few more lines of code to my patch, and would fix the worst of this.
&gt; Have a very short timeout on directories that don't immediately get
&gt; mounted on (e.g. 2 seconds??) would further improve the situation.
&gt; That timeout would have to be completely managed in the daemon
&gt; as the kernel doesn't expire empty directories.
&gt; 
&gt; Thanks,
&gt; NeilBrown
&gt; 

--
To unsubscribe from this list: send the line &quot;unsubscribe autofs&quot; in


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="01773" href="msg01773.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
<ul><li><em>From:</em> NeilBrown</li></ul></li>
<li><strong><a name="01770" href="msg01770.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
<ul><li><em>From:</em> Ian Kent</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="01593" href="msg01593.html">[PATCH 1/3] autofs - make disc device user accessible</a></strong>
<ul><li><em>From:</em> Ian Kent</li></ul></li>
<li><strong><a name="01595" href="msg01595.html">[PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
<ul><li><em>From:</em> Ian Kent</li></ul></li>
<li><strong><a name="01764" href="msg01764.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
<ul><li><em>From:</em> NeilBrown</li></ul></li>
<li><strong><a name="01765" href="msg01765.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
<ul><li><em>From:</em> Ian Kent</li></ul></li>
<li><strong><a name="01767" href="msg01767.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
<ul><li><em>From:</em> NeilBrown</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg01767.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg01769.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg01767.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg01770.html">Re: [PATCH 3/3] autofs - fix AT_NO_AUTOMOUNT not being honored</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#01768"><strong>Date</strong></a></li>
<li><a href="index.html#01768"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-fsdevel/>[Linux&nbsp;Filesystem&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-ext4/>[Linux&nbsp;Ext4]</a>
&nbsp;
&nbsp;
<a href=/lists/arm-kernel/>[Linux&nbsp;ARM&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/arm/>[Linux&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;Omap]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-arm/>[Fedora&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/ietf-ann/>[IETF&nbsp;Annouce]</a>
&nbsp;
&nbsp;
<a href=/lists/security/>[Security]</a>
&nbsp;
&nbsp;
<a href=/lists/bugtraq/>[Bugtraq]</a>
&nbsp;
&nbsp;
<a href=/linux/>[Linux]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;OMAP]</a>
&nbsp;
&nbsp;
<a href=/lists/mips/>[Linux&nbsp;MIPS]</a>
&nbsp;
&nbsp;
<a href=/lists/ecos/>[ECOS]</a>
&nbsp;
&nbsp;
<a href=/lists/asterisk/>[Asterisk&nbsp;Internet&nbsp;PBX]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-api/>[Linux&nbsp;API]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
