<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH 23/37] autofs&#45;5.1.2 &#45; wait for master map available at start -->
<!--X-From-R13: Wna Yrag &#60;eniraNgurznj.arg> -->
<!--X-Date: Mon, 24 Oct 2016 18:19:34 &#45;0700 -->
<!--X-Message-Id: 20161025011927.7778.7380.stgit@pluto.themaw.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20161025010014.7778.69274.stgit@pluto.themaw.net -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="[PATCH 23/37] autofs-5.1.2 - wait for master map available at start &mdash; Linux AutoFS">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>[PATCH 23/37] autofs-5.1.2 - wait for master map available at start &mdash; Linux AutoFS</title>
<link rel="alternate" type="application/rss+xml" title="Linux AutoFS" href="//feeds.feedburner.com/autofs">
<script type="text/javascript">
var addthis_config = addthis_config||{};
addthis_config.data_track_addressbar = false;
</script>
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com/cse" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:isdiegq275o" />
    <input type="hidden" name="ie" value="ISO-8859-1" />
    <input type="text" name="q" size="37" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH 23/37] autofs-5.1.2 - wait for master map available at start</h1>
[<a href="msg01475.html">Date Prev</a>][<a href="msg01477.html">Date Next</a>][<a href="msg01475.html">Thread Prev</a>][<a href="msg01477.html">Thread Next</a>][<a href="maillist.html#01476">Date Index</a>][<a href="index.html#01476">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: autofs mailing list &lt;autofs@xxxxxxxxxxxxxxx&gt;</li>
<li><em>Subject</em>: [PATCH 23/37] autofs-5.1.2 - wait for master map available at start</li>
<li><em>From</em>: Ian Kent &lt;raven@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Tue, 25 Oct 2016 09:19:27 +0800</li>
<li><em>In-reply-to</em>: &lt;<a href="msg01453.html">20161025010014.7778.69274.stgit@pluto.themaw.net</a>&gt;</li>
<li><em>References</em>: &lt;<a href="msg01453.html">20161025010014.7778.69274.stgit@pluto.themaw.net</a>&gt;</li>
<li><em>User-agent</em>: StGit/0.17.1-dirty</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>If the network map source isn't available at start the master map
can't be read. In this case we should wait until it is available
so we can get a startup map.

Signed-off-by: Ian Kent &lt;raven@xxxxxxxxxx&gt;
---
 CHANGELOG                |    1 +
 daemon/automount.c       |   81 ++++++++++++++++++++++++++++++++++++++++------
 daemon/lookup.c          |    8 +++++
 lib/master.c             |    3 ++
 modules/lookup_file.c    |    6 +++
 modules/lookup_nisplus.c |   14 ++++++--
 modules/lookup_yp.c      |   13 +++++--
 7 files changed, 108 insertions(+), 18 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index 686d404..d1bc1e1 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -20,6 +20,7 @@ xx/xx/2016 autofs-5.1.3
 - fix _strncmp() usage.
 - fix create_client() RPC client handling.
 - update and add README for old autofs schema.
+- wait for master map available at start.
 
 15/06/2016 autofs-5.1.2
 =======================
diff --git a/daemon/automount.c b/daemon/automount.c
index 9d4c2b7..14af9ff 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -1403,9 +1403,10 @@ static void *do_read_master(void *arg)
 	return NULL;
 }
 
-static int do_hup_signal(struct master *master, time_t age)
+static int do_hup_signal(struct master *master)
 {
 	unsigned int logopt = master-&gt;logopt;
+	time_t age = monotonic_time(NULL);
 	pthread_t thid;
 	int status;
 
@@ -1494,7 +1495,7 @@ static void *statemachine(void *arg)
 			break;
 
 		case SIGHUP:
-			do_hup_signal(master_list, monotonic_time(NULL));
+			do_hup_signal(master_list);
 			break;
 
 		default:
@@ -2052,12 +2053,56 @@ static void remove_empty_args(char **argv, int *argc)
 	*argc = j;
 }
 
+static int do_master_read_master(struct master *master, int wait)
+{
+	sigset_t signalset;
+	/* Wait must be at least 1 second */
+	unsigned int retry_wait = 2;
+	unsigned int elapsed = 0;
+	int max_wait = wait;
+	int ret = 0;
+	time_t age;
+
+	sigemptyset(&amp;signalset);
+	sigaddset(&amp;signalset, SIGTERM);
+	sigaddset(&amp;signalset, SIGINT);
+	sigaddset(&amp;signalset, SIGHUP);
+	sigprocmask(SIG_UNBLOCK, &amp;signalset, NULL);
+
+	while (1) {
+		struct timespec t = { retry_wait, 0 };
+
+		age = monotonic_time(NULL);
+		if (master_read_master(master, age, 0)) {
+			ret = 1;
+			break;
+		}
+
+		if (nanosleep(&amp;t, NULL) == -1)
+			break;
+
+		if (max_wait &gt; 0) {
+			elapsed += retry_wait;
+			if (elapsed &gt;= max_wait) {
+				logmsg(&quot;problem reading master map, &quot;
+					&quot;maximum wait exceeded&quot;);
+				break;
+			}
+		}
+	}
+
+	sigprocmask(SIG_BLOCK, &amp;signalset, NULL);
+
+	return ret;
+}
+
 int main(int argc, char *argv[])
 {
 	int res, opt, status;
 	int logpri = -1;
 	unsigned ghost, logging, daemon_check;
 	unsigned dumpmaps, foreground, have_global_options;
+	unsigned master_read;
 	time_t timeout;
 	time_t age = monotonic_time(NULL);
 	struct rlimit rlim;
@@ -2452,14 +2497,16 @@ int main(int argc, char *argv[])
 		dh_tirpc = dlopen(&quot;libtirpc.so.3&quot;, RTLD_NOW);
 #endif
 
-	if (!master_read_master(master_list, age, 0)) {
-		master_kill(master_list);
-		*pst_stat = 3;
-		res = write(start_pipefd[1], pst_stat, sizeof(*pst_stat));
-		close(start_pipefd[1]);
-		release_flag_file();
-		macro_free_global_table();
-		exit(3);
+	master_read = master_read_master(master_list, age, 0);
+	if (!master_read) {
+		if (foreground)
+			logerr(&quot;%s: failed to read master map, &quot;
+			       &quot;will retry!&quot;,
+			       program);
+		else
+			logerr(&quot;%s: failed to read master map, &quot;
+			       &quot;will retry in background!&quot;,
+			       program);
 	}
 
 	/*
@@ -2472,6 +2519,20 @@ int main(int argc, char *argv[])
 	res = write(start_pipefd[1], pst_stat, sizeof(*pst_stat));
 	close(start_pipefd[1]);
 
+	if (!master_read) {
+		/*
+		 * Read master map, waiting until it is available, unless
+		 * a signal is received, in which case exit returning an
+		 * error.
+		 */
+		if (!do_master_read_master(master_list, -1)) {
+			logerr(&quot;%s: failed to read master map!&quot;, program);
+			master_kill(master_list);
+			release_flag_file();
+			exit(3);
+		}
+	}
+
 	state_mach_thid = pthread_self();
 	statemachine(NULL);
 
diff --git a/daemon/lookup.c b/daemon/lookup.c
index 582b5c9..0c2a01f 100644
--- a/daemon/lookup.c
+++ b/daemon/lookup.c
@@ -241,6 +241,7 @@ int lookup_nss_read_master(struct master *master, time_t age)
 	}
 
 	/* First one gets it */
+	result = NSS_STATUS_UNKNOWN;
 	head = &amp;nsslist;
 	list_for_each(p, head) {
 		struct nss_source *this;
@@ -248,6 +249,13 @@ int lookup_nss_read_master(struct master *master, time_t age)
 
 		this = list_entry(p, struct nss_source, list);
 
+		if (strncmp(this-&gt;source, &quot;files&quot;, 5) &amp;&amp;
+		    strncmp(this-&gt;source, &quot;nis&quot;, 3) &amp;&amp;
+		    strncmp(this-&gt;source, &quot;nisplus&quot;, 7) &amp;&amp;
+		    strncmp(this-&gt;source, &quot;ldap&quot;, 4) &amp;&amp;
+		    strncmp(this-&gt;source, &quot;sss&quot;, 3))
+			continue;
+
 		debug(logopt,
 		      &quot;reading master %s %s&quot;, this-&gt;source, master-&gt;name);
 
diff --git a/lib/master.c b/lib/master.c
index 9ffdd1a..4c6e79b 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -923,7 +923,10 @@ int master_read_master(struct master *master, time_t age, int readall)
 		master_mount_mounts(master, age, readall);
 	else {
 		master-&gt;read_fail = 0;
+		/* HUP signal sets readall == 1 only */
 		if (!readall)
+			return 0;
+		else
 			master_mount_mounts(master, age, readall);
 	}
 
diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index d87ec73..d5f8c9e 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -507,6 +507,12 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 				     MODPREFIX
 				     &quot;failed to read included master map %s&quot;,
 				     master-&gt;name);
+				/*
+				 * If we're starting up wee need the whole
+				 * master map initially, so tell the upper
+				 * layer to retry.
+				 */
+				master-&gt;read_fail = 1;
 			}
 			master-&gt;depth--;
 			master-&gt;recurse = 0;
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index 7832611..c8b75e6 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -149,19 +149,25 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 		logerr(MODPREFIX &quot;malloc: %s&quot;, estr);
 		pthread_setcancelstate(cur_state, NULL);
-		return NSS_STATUS_UNAVAIL;
+		return NSS_STATUS_UNKNOWN;
 	}
 	sprintf(tablename, &quot;%s.org_dir.%s&quot;, ctxt-&gt;mapname, ctxt-&gt;domainname);
 
 	/* check that the table exists */
 	result = nis_lookup(tablename, FOLLOW_PATH | FOLLOW_LINKS);
 	if (result-&gt;status != NIS_SUCCESS &amp;&amp; result-&gt;status != NIS_S_SUCCESS) {
+		int status = result-&gt;status;
 		nis_freeresult(result);
-		crit(logopt,
-		     MODPREFIX &quot;couldn't locate nis+ table %s&quot;, ctxt-&gt;mapname);
 		free(tablename);
 		pthread_setcancelstate(cur_state, NULL);
-		return NSS_STATUS_NOTFOUND;
+		if (status == NIS_UNAVAIL || status == NIS_FAIL)
+			return NSS_STATUS_UNAVAIL;
+		else {
+			crit(logopt,
+			     MODPREFIX &quot;couldn't locate nis+ table %s&quot;,
+			     ctxt-&gt;mapname);
+			return NSS_STATUS_NOTFOUND;
+		}
 	}
 
 	sprintf(tablename, &quot;[],%s.org_dir.%s&quot;, ctxt-&gt;mapname, ctxt-&gt;domainname);
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index 502d850..0d319fd 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -282,9 +282,9 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	char *mapname;
 	int err;
 
-	mapname = alloca(strlen(ctxt-&gt;mapname) + 1);
+	mapname = malloc(strlen(ctxt-&gt;mapname) + 1);
 	if (!mapname)
-		return 0;
+		return NSS_STATUS_UNKNOWN;
 
 	strcpy(mapname, ctxt-&gt;mapname);
 
@@ -308,19 +308,24 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 			err = yp_all((char *) ctxt-&gt;domainname, mapname, &amp;ypcb);
 		}
 
-		if (err == YPERR_SUCCESS)
+		if (err == YPERR_SUCCESS) {
+			free(mapname);
 			return NSS_STATUS_SUCCESS;
+		}
 
 		info(logopt,
 		     MODPREFIX &quot;read of master map %s failed: %s&quot;,
 		     mapname, yperr_string(err));
 
-		if (err == YPERR_PMAP || err == YPERR_YPSERV)
+		free(mapname);
+
+		if (err == YPERR_YPSERV || err == YPERR_DOMAIN)
 			return NSS_STATUS_UNAVAIL;
 
 		return NSS_STATUS_NOTFOUND;
 	}
 
+	free(mapname);
 	return NSS_STATUS_SUCCESS;
 }
 

--
To unsubscribe from this list: send the line &quot;unsubscribe autofs&quot; in


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="01453" href="msg01453.html">[PATCH 00/37] Current patch queue for review</a></strong>
<ul><li><em>From:</em> Ian Kent</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg01475.html">[PATCH 22/37] autofs-5.1.2 - update and add README for old autofs schema</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg01477.html">[PATCH 24/37] autofs-5.1.2 - add master read wait option</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg01475.html">[PATCH 22/37] autofs-5.1.2 - update and add README for old autofs schema</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg01477.html">[PATCH 24/37] autofs-5.1.2 - add master read wait option</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#01476"><strong>Date</strong></a></li>
<li><a href="index.html#01476"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-fsdevel/>[Linux&nbsp;Filesystem&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-ext4/>[Linux&nbsp;Ext4]</a>
&nbsp;
&nbsp;
<a href=/lists/arm-kernel/>[Linux&nbsp;ARM&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/arm/>[Linux&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;Omap]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-arm/>[Fedora&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/ietf-ann/>[IETF&nbsp;Annouce]</a>
&nbsp;
&nbsp;
<a href=/lists/security/>[Security]</a>
&nbsp;
&nbsp;
<a href=/lists/bugtraq/>[Bugtraq]</a>
&nbsp;
&nbsp;
<a href=/linux/>[Linux]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;OMAP]</a>
&nbsp;
&nbsp;
<a href=/lists/mips/>[Linux&nbsp;MIPS]</a>
&nbsp;
&nbsp;
<a href=/lists/ecos/>[ECOS]</a>
&nbsp;
&nbsp;
<a href=/lists/asterisk/>[Asterisk&nbsp;Internet&nbsp;PBX]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-api/>[Linux&nbsp;API]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
