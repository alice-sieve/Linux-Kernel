<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re:  [PATCH] Add support for Texas Instruments' chips -->
<!--X-From-R13: "Aunq Pra&#45;Qbura" &#60;bunqNorapbura.bet> -->
<!--X-Date: Wed, 9 Jul 2008 23:58:06 &#45;0700 -->
<!--X-Message-Id: bd5b16740807092358y33b8f219h8dd4e16b09005939@mail.gmail.com -->
<!--X-Content-Type: multipart/mixed -->
<!--X-Reference: 00695C9C8F8B4448856F48142B4AA2012032A21E@dnce02.ent.ti.com -->
<!--X-Reference: 1215662827.24462.2.camel@californication -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Bluez Devel: Re:  [PATCH] Add support for Texas Instruments' chips">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Re:  [PATCH] Add support for Texas Instruments' chips &mdash; Bluez Devel</title>
<link rel="alternate" type="application/rss+xml" title="Bluez Devel" href="maillist.rdf">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re:  [PATCH] Add support for Texas Instruments' chips</h1>
[<a href="msg00415.html">Date Prev</a>][<a href="msg00417.html">Date Next</a>][<a href="msg00431.html">Thread Prev</a>][<a href="msg00419.html">Thread Next</a>][<a href="maillist.html#00416">Date Index</a>][<a href="index.html#00416">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re:  [PATCH] Add support for Texas Instruments' chips</li>
<li><em>From</em>: &quot;Ohad Ben-Cohen&quot; &lt;<a href="mailto:ohad@DOMAIN.HIDDEN">ohad@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 10 Jul 2008 09:58:00 +0300</li>
<li><em>Cc</em>: BlueZ development &lt;<a href="mailto:bluez-devel@DOMAIN.HIDDEN">bluez-devel@xxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:1215662827.24462.2.camel@DOMAIN.HIDDEN"><a href="msg00414.html">1215662827.24462.2.camel@californication</a></a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:00695C9C8F8B4448856F48142B4AA2012032A21E@DOMAIN.HIDDEN">00695C9C8F8B4448856F48142B4AA2012032A21E@xxxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:1215662827.24462.2.camel@DOMAIN.HIDDEN"><a href="msg00414.html">1215662827.24462.2.camel@californication</a></a>&gt;</li>
<li><em>Reply-to</em>: BlueZ development &lt;<a href="mailto:bluez-devel@DOMAIN.HIDDEN">bluez-devel@xxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Thu, Jul 10, 2008 at 7:07 AM, Marcel Holtmann &lt;marcel@xxxxxxxxxxxx&gt; wrote:
&gt;<i> please put all the TI code into hciattach_ti.c and then I gonna apply</i>
&gt;<i> this patch.</i>

Patch attached.

Thanks,
Ohad.
</pre><pre>From 61318cd9e55edf87556456350b144ccd281491ce Mon Sep 17 00:00:00 2001
From: Ohad &lt;ohad@muesli.(none)&gt;
Date: Thu, 10 Jul 2008 09:53:09 +0300
Subject: [PATCH] Add support for Texas Instruments' chips

---
 utils/tools/Makefile.am    |    2 +-
 utils/tools/hciattach.8    |    3 +
 utils/tools/hciattach.c    |  158 +++++++++------
 utils/tools/hciattach.h    |   69 +++++++
 utils/tools/hciattach_ti.c |  455 ++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 623 insertions(+), 64 deletions(-)
 create mode 100644 utils/tools/hciattach.h
 create mode 100644 utils/tools/hciattach_ti.c

diff --git a/utils/tools/Makefile.am b/utils/tools/Makefile.am
index bc46b3d..c0af73e 100644
--- a/utils/tools/Makefile.am
+++ b/utils/tools/Makefile.am
@@ -43,7 +43,7 @@ bin_PROGRAMS = $(tools_programs) $(dfutool_programs) $(dfubabel_programs)
 
 noinst_PROGRAMS = hcisecfilter ppporc avinfo $(usb_programs)
 
-hciattach_SOURCES = hciattach.c hciattach_st.c
+hciattach_SOURCES = hciattach.c hciattach_st.c hciattach_ti.c
 hciattach_LDADD = @BLUEZ_LIBS@
 
 hciconfig_SOURCES = hciconfig.c csr.h csr.c
diff --git a/utils/tools/hciattach.8 b/utils/tools/hciattach.8
index f9d295e..e658d87 100644
--- a/utils/tools/hciattach.8
+++ b/utils/tools/hciattach.8
@@ -69,6 +69,9 @@ Silicon Wave kits
 .TP
 .B bcsp
 Serial adapters using CSR chips with BCSP serial protocol
+.TP
+.B texas
+Texas Instruments' chips with HCILL serial protocol and BTS initialization files (put .bts files in /lib/firmware)
 .RE
 
 Supported IDs are (manufacturer id, product id)
diff --git a/utils/tools/hciattach.c b/utils/tools/hciattach.c
index 36f3c72..e382003 100644
--- a/utils/tools/hciattach.c
+++ b/utils/tools/hciattach.c
@@ -42,37 +42,13 @@
 #include &lt;sys/param.h&gt;
 #include &lt;sys/ioctl.h&gt;
 #include &lt;sys/socket.h&gt;
+#include &lt;linux/types.h&gt;
 
 #include &lt;bluetooth/bluetooth.h&gt;
 #include &lt;bluetooth/hci.h&gt;
 #include &lt;bluetooth/hci_lib.h&gt;
 
-#ifndef N_HCI
-#define N_HCI	15
-#endif
-
-#define HCIUARTSETPROTO		_IOW('U', 200, int)
-#define HCIUARTGETPROTO		_IOR('U', 201, int)
-#define HCIUARTGETDEVICE	_IOR('U', 202, int)
-
-#define HCI_UART_H4	0
-#define HCI_UART_BCSP	1
-#define HCI_UART_3WIRE	2
-#define HCI_UART_H4DS	3
-
-struct uart_t {
-	char *type;
-	int  m_id;
-	int  p_id;
-	int  proto;
-	int  init_speed;
-	int  speed;
-	int  flags;
-	char *bdaddr;
-	int  (*init) (int fd, struct uart_t *u, struct termios *ti);
-};
-
-#define FLOW_CTL	0x0001
+#include &quot;hciattach.h&quot;
 
 static volatile sig_atomic_t __io_canceled = 0;
 
@@ -143,7 +119,7 @@ static int uart_speed(int s)
 	}
 }
 
-static int set_speed(int fd, struct termios *ti, int speed)
+int set_speed(int fd, struct termios *ti, int speed)
 {
 	cfsetospeed(ti, uart_speed(speed));
 	return tcsetattr(fd, TCSANOW, ti);
@@ -152,7 +128,7 @@ static int set_speed(int fd, struct termios *ti, int speed)
 /* 
  * Read an HCI event from the given file descriptor.
  */
-static int read_hci_event(int fd, unsigned char* buf, int size) 
+int read_hci_event(int fd, unsigned char* buf, int size) 
 {
 	int remain, r;
 	int count = 0;
@@ -287,11 +263,49 @@ static int digi(int fd, struct uart_t *u, struct termios *ti)
 	return 0;
 }
 
+extern int brf_do_script(int fd, struct uart_t *u, struct termios *ti,
+							const char *bts_file);
+extern int is_it_texas(const __u8 *respond);
+extern const char *get_firmware_name(const __u8 *respond);
+
+#define BRF_DEEP_SLEEP_OPCODE_BYTE_1 	0x0c
+#define BRF_DEEP_SLEEP_OPCODE_BYTE_2 	0xfd
+#define BRF_DEEP_SLEEP_OPCODE		\
+	(BRF_DEEP_SLEEP_OPCODE_BYTE_1 |(BRF_DEEP_SLEEP_OPCODE_BYTE_2 &lt;&lt; 8))
+
+static int texas_continue_script(int fd, struct uart_t *u, struct termios *ti)
+{
+	int dev_id, dd, ret = 0;
+
+	sleep(1);
+
+	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
+	if (dev_id &lt; 0) {
+		perror(&quot;cannot get device id&quot;);
+		return -1;
+	}
+
+	DPRINTF(&quot;\nAdded device hci%d\n&quot;, dev_id);
+
+	dd = hci_open_dev(dev_id);
+	if (dd &lt; 0) {
+		perror(&quot;HCI device open failed&quot;);
+		return -1;
+	}
+
+	ret = brf_do_script(dd, u, ti, NULL);
+
+	hci_close_dev(dd);
+
+	return ret;
+}
+
 static int texas(int fd, struct uart_t *u, struct termios *ti)
 {
 	struct timespec tm = {0, 50000};
 	char cmd[4];
 	unsigned char resp[100];		/* Response */
+	const char *bts_file;
 	int n;
 
 	memset(resp,'\0', 100);
@@ -327,17 +341,20 @@ static int texas(int fd, struct uart_t *u, struct termios *ti)
 	} while (resp[4] != cmd[1] &amp;&amp; resp[5] != cmd[2]);
 
 	/* Verify manufacturer */
-	if ((resp[11] &amp; 0xFF) != 0x0d)
-		fprintf(stderr,&quot;WARNING : module's manufacturer is not Texas Instrument\n&quot;);
+	if (! is_it_texas(resp)) {
+		fprintf(stderr,&quot;ERROR: module's manufacturer is not Texas Instruments\n&quot;);
+		return -1;
+	}
 
-	/* Print LMP version */
-	fprintf(stderr, &quot;Texas module LMP version : 0x%02x\n&quot;, resp[10] &amp; 0xFF);
+	fprintf(stderr, &quot;Found a Texas Instruments' chip!\n&quot;);
 
-	/* Print LMP subversion */
-	fprintf(stderr, &quot;Texas module LMP sub-version : 0x%02x%02x\n&quot;, resp[14] &amp; 0xFF, resp[13] &amp; 0xFF);
+	bts_file = get_firmware_name(resp);
+	fprintf(stderr, &quot;Firmware file : %s\n&quot;, bts_file);
+
+	n = brf_do_script( fd, u, ti, bts_file);
 
 	nanosleep(&amp;tm, NULL);
-	return 0;
+	return n;
 }
 
 static int read_check(int fd, void *buf, int count)
@@ -1050,69 +1067,71 @@ static int bcm2035(int fd, struct uart_t *u, struct termios *ti)
 }
 
 struct uart_t uart[] = {
-	{ &quot;any&quot;,        0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
-	{ &quot;ericsson&quot;,   0x0000, 0x0000, HCI_UART_H4,   57600,  115200, FLOW_CTL, NULL, ericsson },
-	{ &quot;digi&quot;,       0x0000, 0x0000, HCI_UART_H4,   9600,   115200, FLOW_CTL, NULL, digi     },
-	{ &quot;texas&quot;,      0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, texas    },
+	{ &quot;any&quot;,        0x0000, 0x0000, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, NULL, NULL, NULL     },
+	{ &quot;ericsson&quot;,   0x0000, 0x0000, HCI_UART_H4, 0, 57600,  115200, FLOW_CTL, NULL, ericsson, NULL },
+	{ &quot;digi&quot;,       0x0000, 0x0000, HCI_UART_H4, 0, 9600,   115200, FLOW_CTL, NULL, digi, NULL     },
 
-	{ &quot;bcsp&quot;,       0x0000, 0x0000, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+	/* Texas Instruments Bluelink (BRF) modules */
+	{ &quot;texas&quot;,      0x0000, 0x0000, HCI_UART_LL, BRF_DEEP_SLEEP_OPCODE, 115200, 115200, FLOW_CTL, NULL, texas, texas_continue_script    },
+
+	{ &quot;bcsp&quot;,       0x0000, 0x0000, HCI_UART_BCSP, 0, 115200, 115200, 0,        NULL, bcsp, NULL     },
 
 	/* Xircom PCMCIA cards: Credit Card Adapter and Real Port Adapter */
-	{ &quot;xircom&quot;,     0x0105, 0x080a, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+	{ &quot;xircom&quot;,     0x0105, 0x080a, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, NULL, NULL, NULL     },
 
 	/* CSR Casira serial adapter or BrainBoxes serial dongle (BL642) */
-	{ &quot;csr&quot;,        0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, csr      },
+	{ &quot;csr&quot;,        0x0000, 0x0000, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, NULL, csr, NULL      },
 
 	/* BrainBoxes PCMCIA card (BL620) */
-	{ &quot;bboxes&quot;,     0x0160, 0x0002, HCI_UART_H4,   115200, 460800, FLOW_CTL, NULL, csr      },
+	{ &quot;bboxes&quot;,     0x0160, 0x0002, HCI_UART_H4, 0, 115200, 460800, FLOW_CTL, NULL, csr, NULL      },
 
 	/* Silicon Wave kits */
-	{ &quot;swave&quot;,      0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, swave    },
+	{ &quot;swave&quot;,      0x0000, 0x0000, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, NULL, swave, NULL    },
 
 	/* ST Microelectronics minikits based on STLC2410/STLC2415 */
-	{ &quot;st&quot;,         0x0000, 0x0000, HCI_UART_H4,    57600, 115200, FLOW_CTL, NULL, st       },
+	{ &quot;st&quot;,         0x0000, 0x0000, HCI_UART_H4, 0, 57600, 115200, FLOW_CTL, NULL, st, NULL       },
 
 	/* ST Microelectronics minikits based on STLC2500 */
-	{ &quot;stlc2500&quot;,   0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, &quot;00:80:E1:00:AB:BA&quot;, stlc2500  },
+	{ &quot;stlc2500&quot;,   0x0000, 0x0000, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, &quot;00:80:E1:00:AB:BA&quot;, stlc2500, NULL  },
 
 	/* Philips generic Ericsson IP core based */
-	{ &quot;philips&quot;,    0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+	{ &quot;philips&quot;,    0x0000, 0x0000, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, NULL, NULL, NULL     },
 
 	/* Philips BGB2xx Module */
-	{ &quot;bgb2xx&quot;,    0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, &quot;BD:B2:10:00:AB:BA&quot;, bgb2xx   },
+	{ &quot;bgb2xx&quot;,    0x0000, 0x0000, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, &quot;BD:B2:10:00:AB:BA&quot;, bgb2xx, NULL   },
 
 	/* Sphinx Electronics PICO Card */
-	{ &quot;picocard&quot;,   0x025e, 0x1000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+	{ &quot;picocard&quot;,   0x025e, 0x1000, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, NULL, NULL, NULL     },
 
 	/* Inventel BlueBird Module */
-	{ &quot;inventel&quot;,   0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+	{ &quot;inventel&quot;,   0x0000, 0x0000, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, NULL, NULL, NULL     },
 
 	/* COM One Platinium Bluetooth PC Card */
-	{ &quot;comone&quot;,     0xffff, 0x0101, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+	{ &quot;comone&quot;,     0xffff, 0x0101, HCI_UART_BCSP, 0, 115200, 115200, 0,        NULL, bcsp, NULL     },
 
 	/* TDK Bluetooth PC Card and IBM Bluetooth PC Card II */
-	{ &quot;tdk&quot;,        0x0105, 0x4254, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+	{ &quot;tdk&quot;,        0x0105, 0x4254, HCI_UART_BCSP, 0, 115200, 115200, 0,        NULL, bcsp, NULL     },
 
 	/* Socket Bluetooth CF Card (Rev G) */
-	{ &quot;socket&quot;,     0x0104, 0x0096, HCI_UART_BCSP, 230400, 230400, 0,        NULL, bcsp     },
+	{ &quot;socket&quot;,     0x0104, 0x0096, HCI_UART_BCSP, 0, 230400, 230400, 0,        NULL, bcsp, NULL     },
 
 	/* 3Com Bluetooth Card (Version 3.0) */
-	{ &quot;3com&quot;,       0x0101, 0x0041, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, csr      },
+	{ &quot;3com&quot;,       0x0101, 0x0041, HCI_UART_H4, 0, 115200, 115200, FLOW_CTL, NULL, csr, NULL      },
 
 	/* AmbiCom BT2000C Bluetooth PC/CF Card */
-	{ &quot;bt2000c&quot;,    0x022d, 0x2000, HCI_UART_H4,    57600, 460800, FLOW_CTL, NULL, csr      },
+	{ &quot;bt2000c&quot;,    0x022d, 0x2000, HCI_UART_H4, 0, 57600, 460800, FLOW_CTL, NULL, csr, NULL      },
 
 	/* Zoom Bluetooth PCMCIA Card */
-	{ &quot;zoom&quot;,       0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+	{ &quot;zoom&quot;,       0x0279, 0x950b, HCI_UART_BCSP, 0, 115200, 115200, 0,        NULL, bcsp, NULL     },
 
 	/* Sitecom CN-504 PCMCIA Card */
-	{ &quot;sitecom&quot;,    0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+	{ &quot;sitecom&quot;,    0x0279, 0x950b, HCI_UART_BCSP, 0, 115200, 115200, 0,        NULL, bcsp, NULL     },
 
 	/* Billionton PCBTC1 PCMCIA Card */
-	{ &quot;billionton&quot;, 0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+	{ &quot;billionton&quot;, 0x0279, 0x950b, HCI_UART_BCSP, 0, 115200, 115200, 0,        NULL, bcsp, NULL     },
 
 	/* Broadcom BCM2035 */
-	{ &quot;bcm2035&quot;,    0x0A5C, 0x2035, HCI_UART_H4,   115200, 460800, FLOW_CTL, NULL, bcm2035  },
+	{ &quot;bcm2035&quot;,    0x0A5C, 0x2035, HCI_UART_H4, 0, 115200, 115200, 0,        NULL, bcm2035, NULL  },
 
 	{ NULL, 0 }
 };
@@ -1205,6 +1224,9 @@ int init_uart(char *dev, struct uart_t *u, int send_break)
 		return -1;
 	}
 
+	if (u-&gt;init_post &amp;&amp; u-&gt;init_post(fd, u, &amp;ti) &lt; 0)
+		return -1;
+
 	return fd;
 }
 
@@ -1212,7 +1234,7 @@ static void usage(void)
 {
 	printf(&quot;hciattach - HCI UART driver initialization utility\n&quot;);
 	printf(&quot;Usage:\n&quot;);
-	printf(&quot;\thciattach [-n] [-p] [-b] [-t timeout] [-s initial_speed] &lt;tty&gt; &lt;type | id&gt; [speed] [flow|noflow] [bdaddr]\n&quot;);
+	printf(&quot;\thciattach [-n] [-p] [-b] [-g device_param] [-t timeout] [-s initial_speed] &lt;tty&gt; &lt;type | id&gt; [speed] [flow|noflow] [bdaddr]\n&quot;);
 	printf(&quot;\thciattach -l\n&quot;);
 }
 
@@ -1220,8 +1242,9 @@ int main(int argc, char *argv[])
 {
 	struct uart_t *u = NULL;
 	int detach, printpid, opt, i, n, ld, err;
-	int to = 5; 
+	int to = 10;
 	int init_speed = 0;
+	__u16 device_param = 0;
 	int send_break = 0;
 	pid_t pid;
 	struct sigaction sa;
@@ -1231,7 +1254,7 @@ int main(int argc, char *argv[])
 	detach = 1;
 	printpid = 0;
 
-	while ((opt=getopt(argc, argv, &quot;bnpt:s:l&quot;)) != EOF) {
+	while ((opt=getopt(argc, argv, &quot;bnpt:g:s:l&quot;)) != EOF) {
 		switch(opt) {
 		case 'b':
 			send_break = 1;
@@ -1249,6 +1272,10 @@ int main(int argc, char *argv[])
 			to = atoi(optarg);
 			break;
 
+		case 'g':
+			device_param = (__u16)strtol(optarg, NULL, 16);
+			break;
+
 		case 's':
 			init_speed = atoi(optarg);
 			break;
@@ -1328,12 +1355,17 @@ int main(int argc, char *argv[])
 	if (init_speed)
 		u-&gt;init_speed = init_speed;
 
+	/* If user specified a device parameter, use that instead of
+	   the hardware's default */
+	if (device_param)
+		u-&gt;device_param = device_param;
+
 	memset(&amp;sa, 0, sizeof(sa));
 	sa.sa_flags   = SA_NOCLDSTOP;
 	sa.sa_handler = sig_alarm;
 	sigaction(SIGALRM, &amp;sa, NULL);
 
-	/* 5 seconds should be enough for initialization */
+	/* 10 seconds should be enough for initialization */
 	alarm(to);
 
 	n = init_uart(dev, u, send_break);
diff --git a/utils/tools/hciattach.h b/utils/tools/hciattach.h
new file mode 100644
index 0000000..c739101
--- /dev/null
+++ b/utils/tools/hciattach.h
@@ -0,0 +1,69 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky &lt;maxk@xxxxxxxxxxxx&gt;
+ *  Copyright (C) 2002-2008  Marcel Holtmann &lt;marcel@xxxxxxxxxxxx&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _HCIATTACH_H_
+#define _HCIATTACH_H_
+
+#ifndef N_HCI
+#define N_HCI	15
+#endif
+
+#define HCIUARTSETPROTO		_IOW('U', 200, int)
+#define HCIUARTGETPROTO		_IOR('U', 201, int)
+#define HCIUARTGETDEVICE	_IOR('U', 202, int)
+
+#define HCI_UART_H4	0
+#define HCI_UART_BCSP	1
+#define HCI_UART_3WIRE	2
+#define HCI_UART_H4DS	3
+#define HCI_UART_LL	4
+
+#ifdef HCIATTACH_DEBUG
+#define DPRINTF(x...)	printf(x)
+#else
+#define DPRINTF(x...)
+#endif
+
+struct uart_t {
+	char *type;
+	int  m_id;
+	int  p_id;
+	int  proto;
+	__u16 device_param;
+	int  init_speed;
+	int  speed;
+	int  flags;
+	char *bdaddr;
+	int  (*init) (int fd, struct uart_t *u, struct termios *ti);
+	int  (*init_post) (int fd, struct uart_t *u, struct termios *ti);
+};
+
+#define FLOW_CTL	0x0001
+
+extern int set_speed(int fd, struct termios *ti, int speed);
+extern int read_hci_event(int fd, unsigned char* buf, int size);
+
+#endif /* _HCIATTACH_H_ */
+
diff --git a/utils/tools/hciattach_ti.c b/utils/tools/hciattach_ti.c
new file mode 100644
index 0000000..ad9f12a
--- /dev/null
+++ b/utils/tools/hciattach_ti.c
@@ -0,0 +1,455 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2007-2008  Texas Instruments
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &lt;stdio.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;syslog.h&gt;
+#include &lt;termios.h&gt;
+#include &lt;time.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;sys/poll.h&gt;
+#include &lt;sys/param.h&gt;
+#include &lt;sys/ioctl.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;linux/types.h&gt;
+
+#include &lt;bluetooth/bluetooth.h&gt;
+#include &lt;bluetooth/hci.h&gt;
+#include &lt;bluetooth/hci_lib.h&gt;
+
+#include &quot;hciattach.h&quot;
+
+#ifndef MAKEWORD
+#define MAKEWORD(a, b)      ((__u16)(((__u8)(a)) | ((__u16)((__u8)(b))) &lt;&lt; 8))
+#endif
+
+#define TI_MANUFACTURER_ID		13
+
+#define FIRMWARE_DIRECTORY 		&quot;/lib/firmware/&quot;
+
+#define ACTION_SEND_COMMAND		1
+#define ACTION_WAIT_EVENT		2
+#define ACTION_SERIAL			3
+#define ACTION_DELAY			4
+#define ACTION_RUN_SCRIPT		5
+#define ACTION_REMARKS			6
+
+
+#define FILE_HEADER_MAGIC   		0x42535442
+
+/*
+ * BRF Firmware header
+ */
+struct bts_header {
+	__u32	magic;
+	__u32	version;
+	__u8	future[24];
+	__u8	actions[0];
+}__attribute__ ((packed));
+
+/*
+ * BRF Actions structure
+ */
+struct bts_action {
+	__u16	type;
+	__u16	size;
+	__u8	data[0];
+} __attribute__ ((packed));
+
+struct bts_action_send
+{
+	__u8 data[0];
+} __attribute__ ((packed));
+
+struct bts_action_wait
+{
+	__u32 msec;
+	__u32 size;
+	__u8 data[0];
+}__attribute__ ((packed));
+
+struct bts_action_delay
+{
+	__u32 msec;
+}__attribute__ ((packed));
+
+struct bts_action_serial
+{
+	__u32 baud;
+	__u32 flow_control;
+}__attribute__ ((packed));
+
+FILE *bts_load_script(const char* file_name, __u32* version)
+{
+	struct bts_header header;
+	FILE* fp;
+
+	fp = fopen(file_name, &quot;rb&quot;);
+	if (!fp) {
+		perror(&quot;can't open firmware file&quot;);
+		goto out;
+	}
+
+	if (1 != fread(&amp;header, sizeof(struct bts_header), 1, fp)) {
+		perror(&quot;can't read firmware file&quot;);
+		goto errclose;
+	}
+
+	if (header.magic != FILE_HEADER_MAGIC) {
+		fprintf(stderr, &quot;%s not a legal TI firmware file\n&quot;, file_name);
+		goto errclose;
+	}
+
+	if (NULL != version)
+		*version = header.version;
+
+	goto out;
+
+errclose:
+	fclose(fp);
+	fp = NULL;
+out:
+	return fp;
+}
+
+unsigned long bts_fetch_action(FILE* fp,
+				unsigned char* action_buf,
+				unsigned long buf_size,
+				__u16* action_type)
+{
+	struct bts_action action_hdr;
+	unsigned long nread;
+
+	if (!fp)
+		return 0;
+
+	if (1 != fread(&amp;action_hdr, sizeof(struct bts_action), 1, fp))
+		return 0;
+
+	if (action_hdr.size &gt; buf_size) {
+		fprintf(stderr, &quot;bts_next_action: not enough space to read next action\n&quot;);
+		return 0;
+	}
+
+	nread = fread(action_buf, sizeof(__u8), action_hdr.size, fp);
+	if (nread != (action_hdr.size)) {
+		fprintf(stderr, &quot;bts_next_action: fread failed to read next action\n&quot;);
+		return 0;
+	}
+
+	*action_type = action_hdr.type;
+
+	return nread * sizeof(__u8);
+}
+
+void bts_unload_script(FILE* fp)
+{
+	if (fp)
+		fclose(fp);
+}
+
+int is_it_texas(const __u8 *respond)
+{
+	__u16 manufacturer_id;
+
+	manufacturer_id = MAKEWORD(respond[11], respond[12]);
+
+	return TI_MANUFACTURER_ID == manufacturer_id ? 1 : 0;
+}
+
+const char *get_firmware_name(const __u8 *respond)
+{
+	static char firmware_file_name[PATH_MAX] = {0};
+	__u16 version = 0, chip = 0, min_ver = 0, maj_ver = 0;
+
+	version = MAKEWORD(respond[13], respond[14]);
+	chip =  (version &amp; 0x7C00) &gt;&gt; 10;
+	min_ver = (version &amp; 0x007F);
+	maj_ver = (version &amp; 0x0380) &gt;&gt; 7;
+
+	if (version &amp; 0x8000)
+		maj_ver |= 0x0008;
+
+	sprintf(firmware_file_name, FIRMWARE_DIRECTORY &quot;TIInit_%d.%d.%d.bts&quot;,
+						chip, maj_ver, min_ver);
+
+	return firmware_file_name;
+}
+
+static void brf_delay(struct bts_action_delay *delay)
+{
+	usleep(1000*delay-&gt;msec);
+}
+
+static int brf_set_serial_params(struct bts_action_serial *serial_action,
+				int fd,
+				struct uart_t *u,
+				struct termios *ti)
+{
+	fprintf(stderr, &quot;texas: changing baud rate to %u, flow control to %u\n&quot;,
+						serial_action-&gt;baud,
+						serial_action-&gt;flow_control );
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (serial_action-&gt;flow_control)
+		ti-&gt;c_cflag |= CRTSCTS;
+	else
+		ti-&gt;c_cflag &amp;= ~CRTSCTS;
+
+	if (tcsetattr(fd, TCSANOW, ti) &lt; 0) {
+		perror(&quot;Can't set port settings&quot;);
+		return -1;
+	}
+
+	u-&gt;speed = serial_action-&gt;baud;
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (set_speed(fd, ti, serial_action-&gt;baud) &lt; 0) {
+		perror(&quot;Can't set baud rate&quot;);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int brf_send_command_socket(int fd, struct bts_action_send* send_action)
+{
+	char response[1024] = {0};
+	hci_command_hdr *cmd = (hci_command_hdr *) send_action-&gt;data;
+	uint16_t opcode = cmd-&gt;opcode;
+
+	struct hci_request rq;
+	memset(&amp;rq, 0, sizeof(rq));
+	rq.ogf    = cmd_opcode_ogf(opcode);
+	rq.ocf    = cmd_opcode_ocf(opcode);
+	rq.event  = EVT_CMD_COMPLETE;
+	rq.cparam = &amp;send_action-&gt;data[3];
+	rq.clen   = send_action-&gt;data[2];
+	rq.rparam = response;
+	rq.rlen   = sizeof(response);
+
+	if (hci_send_req(fd, &amp;rq, 15) &lt; 0) {
+		perror(&quot;Cannot send hci command to socket&quot;);
+		return -1;
+	}
+
+	/* verify success */
+	if (response[0]) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int brf_send_command_file(int fd, struct bts_action_send* send_action, long size)
+{
+	unsigned char response[1024] = {0};
+	long ret = 0;
+
+	/* send command */
+	if (size != write(fd, send_action, size)) {
+		perror(&quot;Texas: Failed to write action command&quot;);
+		return -1;
+	}
+
+	/* read response */
+	ret = read_hci_event(fd, response, sizeof(response));
+	if (ret &lt; 0) {
+		perror(&quot;texas: failed to read command response&quot;);
+		return -1;
+	}
+
+	/* verify success */
+	if (ret &lt; 7 || 0 != response[6]) {
+		fprintf( stderr, &quot;TI init command failed.\n&quot; );
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int brf_send_command(int fd, struct bts_action_send* send_action,
+					long size, int hcill_installed)
+{
+	int ret = 0;
+	char *fixed_action;
+
+	/* remove packet type when giving to socket API */
+	if (hcill_installed) {
+		fixed_action = ((char *) send_action) + 1;
+		ret = brf_send_command_socket(fd, (struct bts_action_send *)
+								fixed_action);
+	} else {
+		ret = brf_send_command_file(fd, send_action, size);
+	}
+
+	return ret;
+}
+
+static int brf_do_action(	__u16 brf_type, __u8 *brf_action,
+				long brf_size, int fd,
+				struct uart_t *u, struct termios *ti,
+				int hcill_installed)
+{
+	int ret = 0;
+
+	switch (brf_type) {
+	case ACTION_SEND_COMMAND:
+		DPRINTF(&quot;W&quot;);
+		ret = brf_send_command(fd, (struct bts_action_send*)
+					brf_action, brf_size, hcill_installed);
+		break;
+	case ACTION_WAIT_EVENT:
+		DPRINTF(&quot;R&quot;);
+		break;
+	case ACTION_SERIAL:
+		DPRINTF(&quot;S&quot;);
+		ret = brf_set_serial_params((struct bts_action_serial *)
+							brf_action, fd, u, ti);
+		break;
+	case ACTION_DELAY:
+		DPRINTF(&quot;D&quot;);
+		brf_delay((struct bts_action_delay *) brf_action);
+		break;
+	case ACTION_REMARKS:
+		DPRINTF(&quot;C&quot;);
+		break;
+	default:
+		fprintf(stderr, &quot;brf_init: unknown firmware action type (%d)\n&quot;,
+								brf_type);
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * tests whether a given brf action is a HCI_VS_Sleep_Mode_Configurations cmd
+ */
+static int brf_action_is_deep_sleep(struct uart_t *u, __u8 *brf_action,
+						long brf_size, __u16 brf_type)
+{
+	__u16 opcode;
+
+	if (brf_type != ACTION_SEND_COMMAND)
+		return 0;
+
+	if (brf_size &lt; 3)
+		return 0;
+
+	if (brf_action[0] != HCI_COMMAND_PKT)
+		return 0;
+
+	/* HCI data is little endian */
+	opcode = brf_action[1] | (brf_action[2] &lt;&lt; 8);
+
+	if (opcode != u-&gt;device_param)
+		return 0;
+
+	/* action is deep sleep configuration command ! */
+	return 1;
+}
+
+/*
+ * This function is called twice.
+ * The first time it is called, it loads the brf script, and executes its
+ * commands until it reaches a deep sleep command (or its end).
+ * The second time it is called, it assumes HCILL protocol is set up,
+ * and sends rest of brf script via the supplied socket.
+ */
+int brf_do_script(int fd, struct uart_t *u, struct termios *ti,
+							const char *bts_file)
+{
+	int ret = 0,  hcill_installed = bts_file ? 0 : 1;
+	__u32 vers;
+	static FILE *brf_script_file = NULL;
+	static __u8 brf_action[256];
+	static long brf_size;
+	static __u16 brf_type;
+
+	/* is it the first time we are called ? */
+	if (0 == hcill_installed) {
+		DPRINTF(&quot;Sending script to serial device\n&quot;);
+		brf_script_file = bts_load_script(bts_file, &amp;vers );
+		if (!brf_script_file) {
+			fprintf(stderr, &quot;Warning: cannot find BTS file: %s\n&quot;,
+					bts_file);
+			return 0;
+		}
+
+		fprintf( stderr, &quot;Loaded BTS script version %u\n&quot;, vers );
+
+		brf_size = bts_fetch_action(	brf_script_file,
+						brf_action,
+						sizeof(brf_action),
+						&amp;brf_type );
+		if (brf_size == 0) {
+			fprintf(stderr, &quot;Warning: BTS file is empty !&quot;);
+			return 0;
+		}
+	}
+	else {
+		DPRINTF(&quot;Sending script to bluetooth socket\n&quot;);
+	}
+
+	/* execute current action and continue to parse brf script file */
+	while (brf_size != 0) {
+		ret = brf_do_action(	brf_type, brf_action, brf_size,
+					fd, u, ti, hcill_installed);
+		if (ret == -1)
+			break;
+
+		brf_size = bts_fetch_action(	brf_script_file,
+						brf_action,
+						sizeof(brf_action),
+						&amp;brf_type );
+
+		/* if this is the first time we run (no HCILL yet) */
+		/* and a deep sleep command is encountered */
+		/* we exit */
+		if (	0 == hcill_installed &amp;&amp;
+			brf_action_is_deep_sleep(u, brf_action,
+						brf_size, brf_type))
+			return 0;
+	}
+
+	bts_unload_script(brf_script_file);
+	brf_script_file = NULL;
+	DPRINTF(&quot;\n&quot;);
+
+	return ret;
+}
+
-- 
1.5.4.3

</pre><pre>-------------------------------------------------------------------------
Sponsored by: SourceForge.net Community Choice Awards: VOTE NOW!
Studies have shown that voting for your favorite open source project,
along with a healthy diet, reduces your potential for chronic lameness
and boredom. Vote Now at <a  rel="nofollow" href="http://www.sourceforge.net/community/cca08">http://www.sourceforge.net/community/cca08</a></pre><pre>_______________________________________________
Bluez-devel mailing list
Bluez-devel@xxxxxxxxxxxxxxxxxxxxx
<a  rel="nofollow" href="https://lists.sourceforge.net/lists/listinfo/bluez-devel">https://lists.sourceforge.net/lists/listinfo/bluez-devel</a>
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00393" href="msg00393.html">[PATCH] Add support for Texas Instruments' chips</a></strong>
<ul><li><em>From:</em> Ben-cohen, Ohad</li></ul></li>
<li><strong><a name="00414" href="msg00414.html">Re:  [PATCH] Add support for Texas Instruments' chips</a></strong>
<ul><li><em>From:</em> Marcel Holtmann</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00415.html">Re:  [PATCH] Add support for Texas Instruments' chips</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00417.html">Re:  [PATCH] Add support for Texas Instruments' chips</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00431.html">Re:  [PATCH] Add support for Texas Instruments' chips</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00419.html">Re:  [PATCH] Add support for Texas Instruments' chips</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00416"><strong>Date</strong></a></li>
<li><a href="index.html#00416"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-bluetooth/>[Linux&nbsp;Bluetooth&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-usb/>[Linux&nbsp;USB&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/netdev/>[Network&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info/>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-scsi/>[Linux&nbsp;SCSI]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
