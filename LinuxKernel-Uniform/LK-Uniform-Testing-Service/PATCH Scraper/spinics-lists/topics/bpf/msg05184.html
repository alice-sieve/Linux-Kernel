<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH V2 1/1 (was 0/1 by accident)] tools/dtrace: initial implementation of DTrace -->
<!--X-From-R13: Yevf Hna Vrrf &#60;xevf.ina.urrfNbenpyr.pbz> -->
<!--X-Date: Wed, 10 Jul 2019 11:13:49 &#45;0700 -->
<!--X-Message-Id: 20190710181227.GA9925@oracle.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 201907101537.x6AFboMR015946@aserv0122.oracle.com -->
<!--X-Reference: 201907101542.x6AFgOO9012232@userv0121.oracle.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="BPF: Re: [PATCH V2 1/1 (was 0/1 by accident)] tools/dtrace: initial implementation of DTrace">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Re: [PATCH V2 1/1 (was 0/1 by accident)] tools/dtrace: initial implementation of DTrace &mdash; BPF</title>
<link rel="alternate" type="application/rss+xml" title="BPF" href="//feeds.feedburner.com/packetfilters">
<script type="text/javascript">
var addthis_config = addthis_config||{};
addthis_config.data_track_addressbar = false;
</script>
</head>
<body itemscope itemtype="//schema.org/Article" bgcolor=white vlink=green link=blue>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH V2 1/1 (was 0/1 by accident)] tools/dtrace: initial implementation of DTrace</h1>
[<a href="msg05183.html">Date Prev</a>][<a href="msg05185.html">Date Next</a>][<a href="msg05176.html">Thread Prev</a>][<a href="msg05190.html">Thread Next</a>][<a href="maillist.html#05184">Date Index</a>][<a href="index.html#05184">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH V2 1/1 (was 0/1 by accident)] tools/dtrace: initial implementation of DTrace</li>
<li><em>From</em>: Kris Van Hees &lt;kris.van.hees@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Wed, 10 Jul 2019 14:12:27 -0400</li>
<li><em>Cc</em>: netdev@xxxxxxxxxxxxxxx, bpf@xxxxxxxxxxxxxxx,        dtrace-devel@xxxxxxxxxxxxxx, linux-kernel@xxxxxxxxxxxxxxx,        rostedt@xxxxxxxxxxx, mhiramat@xxxxxxxxxx, acme@xxxxxxxxxx,        ast@xxxxxxxxxx, daniel@xxxxxxxxxxxxx,        Peter Zijlstra &lt;peterz@xxxxxxxxxxxxx&gt;, Chris Mason &lt;clm@xxxxxx&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg05176.html">201907101542.x6AFgOO9012232@userv0121.oracle.com</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.5.23 (2014-03-12)</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>This patch's subject should of course be [PATCH V2 1/1] rather than 0/1.
Sorry about that.

On Wed, Jul 10, 2019 at 08:42:24AM -0700, Kris Van Hees wrote:
&gt;<i> This initial implementation of a tiny subset of DTrace functionality</i>
&gt;<i> provides the following options:</i>
&gt;<i> </i>
&gt;<i> 	dtrace [-lvV] [-b bufsz] -s script</i>
&gt;<i> 	    -b  set trace buffer size</i>
&gt;<i> 	    -l  list probes (only works with '-s script' for now)</i>
&gt;<i> 	    -s  enable or list probes for the specified BPF program</i>
&gt;<i> 	    -V  report DTrace API version</i>
&gt;<i> </i>
&gt;<i> The patch comprises quite a bit of code due to DTrace requiring a few</i>
&gt;<i> crucial components, even in its most basic form.</i>
&gt;<i> </i>
&gt;<i> The code is structured around the command line interface implemented in</i>
&gt;<i> dtrace.c.  It provides option parsing and drives the three modes of</i>
&gt;<i> operation that are currently implemented:</i>
&gt;<i> </i>
&gt;<i> 1. Report DTrace API version information.</i>
&gt;<i> 	Report the version information and terminate.</i>
&gt;<i> </i>
&gt;<i> 2. List probes in BPF programs.</i>
&gt;<i> 	Initialize the list of probes that DTrace recognizes, load BPF</i>
&gt;<i> 	programs, parse all BPF ELF section names, resolve them into</i>
&gt;<i> 	known probes, and emit the probe names.  Then terminate.</i>
&gt;<i> </i>
&gt;<i> 3. Load BPF programs and collect tracing data.</i>
&gt;<i> 	Initialize the list of probes that DTrace recognizes, load BPF</i>
&gt;<i> 	programs and attach them to their corresponding probes, set up</i>
&gt;<i> 	perf event output buffers, and start processing tracing data.</i>
&gt;<i> </i>
&gt;<i> This implementation makes extensive use of BPF (handled by dt_bpf.c) and</i>
&gt;<i> the perf event output ring buffer (handled by dt_buffer.c).  DTrace-style</i>
&gt;<i> probe handling (dt_probe.c) offers an interface to probes that hides the</i>
&gt;<i> implementation details of the individual probe types by provider (dt_fbt.c</i>
&gt;<i> and dt_syscall.c).  Probe lookup by name uses a hashtable implementation</i>
&gt;<i> (dt_hash.c).  The dt_utils.c code populates a list of online CPU ids, so</i>
&gt;<i> we know what CPUs we can obtain tracing data from.</i>
&gt;<i> </i>
&gt;<i> Building the tool is trivial because its only dependency (libbpf) is in</i>
&gt;<i> the kernel tree under tools/lib/bpf.  A simple 'make' in the tools/dtrace</i>
&gt;<i> directory suffices.</i>
&gt;<i> </i>
&gt;<i> The 'dtrace' executable needs to run as root because BPF programs cannot</i>
&gt;<i> be loaded by non-root users.</i>
&gt;<i> </i>
&gt;<i> Signed-off-by: Kris Van Hees &lt;kris.van.hees@xxxxxxxxxx&gt;</i>
&gt;<i> Reviewed-by: David Mc Lean &lt;david.mclean@xxxxxxxxxx&gt;</i>
&gt;<i> Reviewed-by: Eugene Loh &lt;eugene.loh@xxxxxxxxxx&gt;</i>
&gt;<i> ---</i>
&gt;<i> Changes in v2:</i>
&gt;<i>         - Use ring_buffer_read_head() and ring_buffer_write_tail() to</i>
&gt;<i>           avoid use of volatile.</i>
&gt;<i>         - Handle perf events that wrap around the ring buffer boundary.</i>
&gt;<i>         - Remove unnecessary PERF_EVENT_IOC_ENABLE.</i>
&gt;<i>         - Remove -I$(srctree)/tools/perf from KBUILD_HOSTCFLAGS since it</i>
&gt;<i>           is not actually used.</i>
&gt;<i>         - Use PT_REGS_PARM1(x), etc instead of my own macros.  Adding </i>
&gt;<i>           PT_REGS_PARM6(x) in bpf_sample.c because we need to be able to</i>
&gt;<i>           support up to 6 arguments passed by registers.</i>
&gt;<i> ---</i>
&gt;<i>  MAINTAINERS                |   6 +</i>
&gt;<i>  tools/dtrace/Makefile      |  87 ++++++++++</i>
&gt;<i>  tools/dtrace/bpf_sample.c  | 146 ++++++++++++++++</i>
&gt;<i>  tools/dtrace/dt_bpf.c      | 185 ++++++++++++++++++++</i>
&gt;<i>  tools/dtrace/dt_buffer.c   | 338 +++++++++++++++++++++++++++++++++++++</i>
&gt;<i>  tools/dtrace/dt_fbt.c      | 201 ++++++++++++++++++++++</i>
&gt;<i>  tools/dtrace/dt_hash.c     | 211 +++++++++++++++++++++++</i>
&gt;<i>  tools/dtrace/dt_probe.c    | 230 +++++++++++++++++++++++++</i>
&gt;<i>  tools/dtrace/dt_syscall.c  | 179 ++++++++++++++++++++</i>
&gt;<i>  tools/dtrace/dt_utils.c    | 132 +++++++++++++++</i>
&gt;<i>  tools/dtrace/dtrace.c      | 249 +++++++++++++++++++++++++++</i>
&gt;<i>  tools/dtrace/dtrace.h      |  13 ++</i>
&gt;<i>  tools/dtrace/dtrace_impl.h | 101 +++++++++++</i>
&gt;<i>  13 files changed, 2078 insertions(+)</i>
&gt;<i>  create mode 100644 tools/dtrace/Makefile</i>
&gt;<i>  create mode 100644 tools/dtrace/bpf_sample.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dt_bpf.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dt_buffer.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dt_fbt.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dt_hash.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dt_probe.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dt_syscall.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dt_utils.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dtrace.c</i>
&gt;<i>  create mode 100644 tools/dtrace/dtrace.h</i>
&gt;<i>  create mode 100644 tools/dtrace/dtrace_impl.h</i>
&gt;<i> </i>
&gt;<i> diff --git a/MAINTAINERS b/MAINTAINERS</i>
&gt;<i> index cfa9ed89c031..410240732d55 100644</i>
&gt;<i> --- a/MAINTAINERS</i>
&gt;<i> +++ b/MAINTAINERS</i>
&gt;<i> @@ -5485,6 +5485,12 @@ W:	<a  rel="nofollow" href="https://linuxtv.org">https://linuxtv.org</a></i>
&gt;<i>  S:	Odd Fixes</i>
&gt;<i>  F:	drivers/media/pci/dt3155/</i>
&gt;<i>  </i>
&gt;<i> +DTRACE</i>
&gt;<i> +M:	Kris Van Hees &lt;kris.van.hees@xxxxxxxxxx&gt;</i>
&gt;<i> +L:	dtrace-devel@xxxxxxxxxxxxxx</i>
&gt;<i> +S:	Maintained</i>
&gt;<i> +F:	tools/dtrace/</i>
&gt;<i> +</i>
&gt;<i>  DVB_USB_AF9015 MEDIA DRIVER</i>
&gt;<i>  M:	Antti Palosaari &lt;crope@xxxxxx&gt;</i>
&gt;<i>  L:	linux-media@xxxxxxxxxxxxxxx</i>
&gt;<i> diff --git a/tools/dtrace/Makefile b/tools/dtrace/Makefile</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..03ae498d1429</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/Makefile</i>
&gt;<i> @@ -0,0 +1,87 @@</i>
&gt;<i> +# SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +#</i>
&gt;<i> +# This Makefile is based on samples/bpf.</i>
&gt;<i> +#</i>
&gt;<i> +# Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> +</i>
&gt;<i> +DT_VERSION		:= 2.0.0</i>
&gt;<i> +DT_GIT_VERSION		:= $(shell git rev-parse HEAD 2&gt;/dev/null || \</i>
&gt;<i> +				   echo Unknown)</i>
&gt;<i> +</i>
&gt;<i> +DTRACE_PATH		?= $(abspath $(srctree)/$(src))</i>
&gt;<i> +TOOLS_PATH		:= $(DTRACE_PATH)/..</i>
&gt;<i> +SAMPLES_PATH		:= $(DTRACE_PATH)/../../samples</i>
&gt;<i> +</i>
&gt;<i> +hostprogs-y		:= dtrace</i>
&gt;<i> +</i>
&gt;<i> +LIBBPF			:= $(TOOLS_PATH)/lib/bpf/libbpf.a</i>
&gt;<i> +OBJS			:= dt_bpf.o dt_buffer.o dt_utils.o dt_probe.o \</i>
&gt;<i> +			   dt_hash.o \</i>
&gt;<i> +			   dt_fbt.o dt_syscall.o</i>
&gt;<i> +</i>
&gt;<i> +dtrace-objs		:= $(OBJS) dtrace.o</i>
&gt;<i> +</i>
&gt;<i> +always			:= $(hostprogs-y)</i>
&gt;<i> +always			+= bpf_sample.o</i>
&gt;<i> +</i>
&gt;<i> +KBUILD_HOSTCFLAGS	+= -DDT_VERSION=\&quot;$(DT_VERSION)\&quot;</i>
&gt;<i> +KBUILD_HOSTCFLAGS	+= -DDT_GIT_VERSION=\&quot;$(DT_GIT_VERSION)\&quot;</i>
&gt;<i> +KBUILD_HOSTCFLAGS	+= -I$(srctree)/tools/lib</i>
&gt;<i> +KBUILD_HOSTCFLAGS	+= -I$(srctree)/tools/include/uapi</i>
&gt;<i> +KBUILD_HOSTCFLAGS	+= -I$(srctree)/tools/include/</i>
&gt;<i> +KBUILD_HOSTCFLAGS	+= -I$(srctree)/usr/include</i>
&gt;<i> +</i>
&gt;<i> +KBUILD_HOSTLDLIBS	:= $(LIBBPF) -lelf</i>
&gt;<i> +</i>
&gt;<i> +LLC			?= llc</i>
&gt;<i> +CLANG			?= clang</i>
&gt;<i> +LLVM_OBJCOPY		?= llvm-objcopy</i>
&gt;<i> +</i>
&gt;<i> +ifdef CROSS_COMPILE</i>
&gt;<i> +HOSTCC			= $(CROSS_COMPILE)gcc</i>
&gt;<i> +CLANG_ARCH_ARGS		= -target $(ARCH)</i>
&gt;<i> +endif</i>
&gt;<i> +</i>
&gt;<i> +all:</i>
&gt;<i> +	$(MAKE) -C ../../ $(CURDIR)/ DTRACE_PATH=$(CURDIR)</i>
&gt;<i> +</i>
&gt;<i> +clean:</i>
&gt;<i> +	$(MAKE) -C ../../ M=$(CURDIR) clean</i>
&gt;<i> +	@rm -f *~</i>
&gt;<i> +</i>
&gt;<i> +$(LIBBPF): FORCE</i>
&gt;<i> +	$(MAKE) -C $(dir $@) RM='rm -rf' LDFLAGS= srctree=$(DTRACE_PATH)/../../ O=</i>
&gt;<i> +</i>
&gt;<i> +FORCE:</i>
&gt;<i> +</i>
&gt;<i> +.PHONY: verify_cmds verify_target_bpf $(CLANG) $(LLC)</i>
&gt;<i> +</i>
&gt;<i> +verify_cmds: $(CLANG) $(LLC)</i>
&gt;<i> +	@for TOOL in $^ ; do \</i>
&gt;<i> +		if ! (which -- &quot;$${TOOL}&quot; &gt; /dev/null 2&gt;&amp;1); then \</i>
&gt;<i> +			echo &quot;*** ERROR: Cannot find LLVM tool $${TOOL}&quot; ;\</i>
&gt;<i> +			exit 1; \</i>
&gt;<i> +		else true; fi; \</i>
&gt;<i> +	done</i>
&gt;<i> +</i>
&gt;<i> +verify_target_bpf: verify_cmds</i>
&gt;<i> +	@if ! (${LLC} -march=bpf -mattr=help &gt; /dev/null 2&gt;&amp;1); then \</i>
&gt;<i> +		echo &quot;*** ERROR: LLVM (${LLC}) does not support 'bpf' target&quot; ;\</i>
&gt;<i> +		echo &quot;   NOTICE: LLVM version &gt;= 3.7.1 required&quot; ;\</i>
&gt;<i> +		exit 2; \</i>
&gt;<i> +	else true; fi</i>
&gt;<i> +</i>
&gt;<i> +$(DTRACE_PATH)/*.c: verify_target_bpf $(LIBBPF)</i>
&gt;<i> +$(src)/*.c: verify_target_bpf $(LIBBPF)</i>
&gt;<i> +</i>
&gt;<i> +$(obj)/%.o: $(src)/%.c</i>
&gt;<i> +	@echo &quot;  CLANG-bpf &quot; $@</i>
&gt;<i> +	$(Q)$(CLANG) $(NOSTDINC_FLAGS) $(LINUXINCLUDE) $(EXTRA_CFLAGS) -I$(obj) \</i>
&gt;<i> +		-I$(srctree)/tools/testing/selftests/bpf/ \</i>
&gt;<i> +		-D__KERNEL__ -D__BPF_TRACING__ -Wno-unused-value -Wno-pointer-sign \</i>
&gt;<i> +		-D__TARGET_ARCH_$(ARCH) -Wno-compare-distinct-pointer-types \</i>
&gt;<i> +		-Wno-gnu-variable-sized-type-not-at-end \</i>
&gt;<i> +		-Wno-address-of-packed-member -Wno-tautological-compare \</i>
&gt;<i> +		-Wno-unknown-warning-option $(CLANG_ARCH_ARGS) \</i>
&gt;<i> +		-I$(srctree)/samples/bpf/ -include asm_goto_workaround.h \</i>
&gt;<i> +		-O2 -emit-llvm -c $&lt; -o -| $(LLC) -march=bpf $(LLC_FLAGS) -filetype=obj -o $@</i>
&gt;<i> diff --git a/tools/dtrace/bpf_sample.c b/tools/dtrace/bpf_sample.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..9862f75f92d3</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/bpf_sample.c</i>
&gt;<i> @@ -0,0 +1,146 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * This sample DTrace BPF tracing program demonstrates how actions can be</i>
&gt;<i> + * associated with different probe types.</i>
&gt;<i> + *</i>
&gt;<i> + * The kprobe/ksys_write probe is a Function Boundary Tracing (FBT) entry probe</i>
&gt;<i> + * on the ksys_write(fd, buf, count) function in the kernel.  Arguments to the</i>
&gt;<i> + * function can be retrieved from the CPU registers (struct pt_regs).</i>
&gt;<i> + *</i>
&gt;<i> + * The tracepoint/syscalls/sys_enter_write probe is a System Call entry probe</i>
&gt;<i> + * for the write(d, buf, count) system call.  Arguments to the system call can</i>
&gt;<i> + * be retrieved from the tracepoint data passed to the BPF program as context</i>
&gt;<i> + * struct syscall_data) when the probe fires.</i>
&gt;<i> + *</i>
&gt;<i> + * The BPF program associated with each probe prepares a DTrace BPF context</i>
&gt;<i> + * (struct dt_bpf_context) that stores the probe ID and up to 10 arguments.</i>
&gt;<i> + * Only 3 arguments are used in this sample.  Then the prorgams call a shared</i>
&gt;<i> + * BPF function (bpf_action) that implements the actual action to be taken when</i>
&gt;<i> + * a probe fires.  It prepares a data record to be stored in the tracing buffer</i>
&gt;<i> + * and submits it to the buffer.  The data in the data record is obtained from</i>
&gt;<i> + * the DTrace BPF context.</i>
&gt;<i> + *</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;uapi/linux/bpf.h&gt;</i>
&gt;<i> +#include &lt;linux/ptrace.h&gt;</i>
&gt;<i> +#include &lt;linux/version.h&gt;</i>
&gt;<i> +#include &lt;uapi/linux/unistd.h&gt;</i>
&gt;<i> +#include &quot;bpf_helpers.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +struct syscall_data {</i>
&gt;<i> +	struct pt_regs *regs;</i>
&gt;<i> +	long syscall_nr;</i>
&gt;<i> +	long arg[6];</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +struct bpf_map_def SEC(&quot;maps&quot;) buffers = {</i>
&gt;<i> +	.type = BPF_MAP_TYPE_PERF_EVENT_ARRAY,</i>
&gt;<i> +	.key_size = sizeof(u32),</i>
&gt;<i> +	.value_size = sizeof(u32),</i>
&gt;<i> +	.max_entries = NR_CPUS,</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +#if defined(bpf_target_x86)</i>
&gt;<i> +# define PT_REGS_PARM6(x)	((x)-&gt;r9)</i>
&gt;<i> +#elif defined(bpf_target_s390x)</i>
&gt;<i> +# define PT_REGS_PARM6(x)	((x)-&gt;gprs[7])</i>
&gt;<i> +#elif defined(bpf_target_arm)</i>
&gt;<i> +# define PT_REGS_PARM6(x)	((x)-&gt;uregs[5])</i>
&gt;<i> +#elif defined(bpf_target_arm64)</i>
&gt;<i> +# define PT_REGS_PARM6(x)	((x)-&gt;regs[5])</i>
&gt;<i> +#elif defined(bpf_target_mips)</i>
&gt;<i> +# define PT_REGS_PARM6(x)	((x)-&gt;regs[9])</i>
&gt;<i> +#elif defined(bpf_target_powerpc)</i>
&gt;<i> +# define PT_REGS_PARM6(x)	((x)-&gt;gpr[8])</i>
&gt;<i> +#elif defined(bpf_target_sparc)</i>
&gt;<i> +# define PT_REGS_PARM6(x)	((x)-&gt;u_regs[UREG_I5])</i>
&gt;<i> +#else</i>
&gt;<i> +# error Argument retrieval from pt_regs is not supported yet on this arch.</i>
&gt;<i> +#endif</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * We must pass a valid BPF context pointer because the bpf_perf_event_output()</i>
&gt;<i> + * helper requires a BPF context pointer as first argument (and the verifier is</i>
&gt;<i> + * validating that we pass a value that is known to be a context pointer).</i>
&gt;<i> + *</i>
&gt;<i> + * This BPF function implements the following D action:</i>
&gt;<i> + * {</i>
&gt;<i> + *	trace(curthread);</i>
&gt;<i> + *	trace(arg0);</i>
&gt;<i> + *	trace(arg1);</i>
&gt;<i> + *	trace(arg2);</i>
&gt;<i> + * }</i>
&gt;<i> + *</i>
&gt;<i> + * Expected output will look like:</i>
&gt;<i> + *   CPU     ID</i>
&gt;<i> + *    15  70423 0xffff8c0968bf8ec0 0x00000000000001 0x0055e019eb3f60 0x0000000000002c</i>
&gt;<i> + *    15  18876 0xffff8c0968bf8ec0 0x00000000000001 0x0055e019eb3f60 0x0000000000002c</i>
&gt;<i> + *    |   |     +-- curthread      +--&gt; arg0 (fd)   +--&gt; arg1 (buf)  +-- arg2 (count)</i>
&gt;<i> + *    |   |</i>
&gt;<i> + *    |   +--&gt; probe ID</i>
&gt;<i> + *    |</i>
&gt;<i> + *    +--&gt; CPU the probe fired on</i>
&gt;<i> + */</i>
&gt;<i> +static noinline int bpf_action(void *bpf_ctx, struct dt_bpf_context *ctx)</i>
&gt;<i> +{</i>
&gt;<i> +	int			cpu = bpf_get_smp_processor_id();</i>
&gt;<i> +	struct data {</i>
&gt;<i> +		u32	probe_id;	/* mandatory */</i>
&gt;<i> +</i>
&gt;<i> +		u64	task;		/* first data item (current task) */</i>
&gt;<i> +		u64	arg0;		/* 2nd data item (arg0, fd) */</i>
&gt;<i> +		u64	arg1;		/* 3rd data item (arg1, buf) */</i>
&gt;<i> +		u64	arg2;		/* 4th data item (arg2, count) */</i>
&gt;<i> +	}			rec;</i>
&gt;<i> +</i>
&gt;<i> +	memset(&amp;rec, 0, sizeof(rec));</i>
&gt;<i> +</i>
&gt;<i> +	rec.probe_id = ctx-&gt;probe_id;</i>
&gt;<i> +	rec.task = bpf_get_current_task();</i>
&gt;<i> +	rec.arg0 = ctx-&gt;argv[0];</i>
&gt;<i> +	rec.arg1 = ctx-&gt;argv[1];</i>
&gt;<i> +	rec.arg2 = ctx-&gt;argv[2];</i>
&gt;<i> +</i>
&gt;<i> +	bpf_perf_event_output(bpf_ctx, &amp;buffers, cpu, &amp;rec, sizeof(rec));</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +SEC(&quot;kprobe/ksys_write&quot;)</i>
&gt;<i> +int bpf_kprobe(struct pt_regs *regs)</i>
&gt;<i> +{</i>
&gt;<i> +	struct dt_bpf_context	ctx;</i>
&gt;<i> +</i>
&gt;<i> +	memset(&amp;ctx, 0, sizeof(ctx));</i>
&gt;<i> +</i>
&gt;<i> +	ctx.probe_id = 18876;</i>
&gt;<i> +	ctx.argv[0] = PT_REGS_PARM1(regs);</i>
&gt;<i> +	ctx.argv[1] = PT_REGS_PARM2(regs);</i>
&gt;<i> +	ctx.argv[2] = PT_REGS_PARM3(regs);</i>
&gt;<i> +	ctx.argv[3] = PT_REGS_PARM4(regs);</i>
&gt;<i> +	ctx.argv[4] = PT_REGS_PARM5(regs);</i>
&gt;<i> +	ctx.argv[5] = PT_REGS_PARM6(regs);</i>
&gt;<i> +</i>
&gt;<i> +	return bpf_action(regs, &amp;ctx);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +SEC(&quot;tracepoint/syscalls/sys_enter_write&quot;)</i>
&gt;<i> +int bpf_tp(struct syscall_data *scd)</i>
&gt;<i> +{</i>
&gt;<i> +	struct dt_bpf_context	ctx;</i>
&gt;<i> +</i>
&gt;<i> +	memset(&amp;ctx, 0, sizeof(ctx));</i>
&gt;<i> +</i>
&gt;<i> +	ctx.probe_id = 70423;</i>
&gt;<i> +	ctx.argv[0] = scd-&gt;arg[0];</i>
&gt;<i> +	ctx.argv[1] = scd-&gt;arg[1];</i>
&gt;<i> +	ctx.argv[2] = scd-&gt;arg[2];</i>
&gt;<i> +</i>
&gt;<i> +	return bpf_action(scd, &amp;ctx);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;;</i>
&gt;<i> +u32 _version SEC(&quot;version&quot;) = LINUX_VERSION_CODE;</i>
&gt;<i> diff --git a/tools/dtrace/dt_bpf.c b/tools/dtrace/dt_bpf.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..78c90de016c6</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dt_bpf.c</i>
&gt;<i> @@ -0,0 +1,185 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * This file provides the interface for handling BPF.  It uses the bpf library</i>
&gt;<i> + * to interact with BPF ELF object files.</i>
&gt;<i> + *</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;errno.h&gt;</i>
&gt;<i> +#include &lt;stdarg.h&gt;</i>
&gt;<i> +#include &lt;stdio.h&gt;</i>
&gt;<i> +#include &lt;string.h&gt;</i>
&gt;<i> +#include &lt;unistd.h&gt;</i>
&gt;<i> +#include &lt;bpf/libbpf.h&gt;</i>
&gt;<i> +#include &lt;linux/kernel.h&gt;</i>
&gt;<i> +#include &lt;linux/perf_event.h&gt;</i>
&gt;<i> +#include &lt;sys/ioctl.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace_impl.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Validate the output buffer map that is specified in the BPF ELF object.  It</i>
&gt;<i> + * must match the following definition to be valid:</i>
&gt;<i> + *</i>
&gt;<i> + * struct bpf_map_def SEC(&quot;maps&quot;) buffers = {</i>
&gt;<i> + *	.type = BPF_MAP_TYPE_PERF_EVENT_ARRAY,</i>
&gt;<i> + *	.key_size = sizeof(u32),</i>
&gt;<i> + *	.value_size = sizeof(u32),</i>
&gt;<i> + *	.max_entries = num,</i>
&gt;<i> + * };</i>
&gt;<i> + * where num is greater than dt_maxcpuid.</i>
&gt;<i> + */</i>
&gt;<i> +static int is_valid_buffers(const struct bpf_map_def *mdef)</i>
&gt;<i> +{</i>
&gt;<i> +	return mdef-&gt;type == BPF_MAP_TYPE_PERF_EVENT_ARRAY &amp;&amp;</i>
&gt;<i> +	       mdef-&gt;key_size == sizeof(u32) &amp;&amp;</i>
&gt;<i> +	       mdef-&gt;value_size == sizeof(u32) &amp;&amp;</i>
&gt;<i> +	       mdef-&gt;max_entries &gt; dt_maxcpuid;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * List the probes specified in the given BPF ELF object file.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_bpf_list_probes(const char *fn)</i>
&gt;<i> +{</i>
&gt;<i> +	struct bpf_object	*obj;</i>
&gt;<i> +	struct bpf_program	*prog;</i>
&gt;<i> +	int			rc, fd;</i>
&gt;<i> +</i>
&gt;<i> +	libbpf_set_print(NULL);</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Listing probes is done before the DTrace command line utility loads</i>
&gt;<i> +	 * the supplied programs.  We load them here without attaching them to</i>
&gt;<i> +	 * probes so that we can retrieve the ELF section names for each BPF</i>
&gt;<i> +	 * program.  The section name indicates the probe that the program is</i>
&gt;<i> +	 * associated with.</i>
&gt;<i> +	 */</i>
&gt;<i> +	rc = bpf_prog_load(fn, BPF_PROG_TYPE_UNSPEC, &amp;obj, &amp;fd);</i>
&gt;<i> +	if (rc)</i>
&gt;<i> +		return rc;</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Loop through the programs in the BPF ELF object, and try to resolve</i>
&gt;<i> +	 * the section names into probes.  Use the supplied callback function</i>
&gt;<i> +	 * to emit the probe description.</i>
&gt;<i> +	 */</i>
&gt;<i> +	for (prog = bpf_program__next(NULL, obj); prog != NULL;</i>
&gt;<i> +	     prog = bpf_program__next(prog, obj)) {</i>
&gt;<i> +		struct dt_probe	*probe;</i>
&gt;<i> +</i>
&gt;<i> +		probe = dt_probe_resolve_event(bpf_program__title(prog, false));</i>
&gt;<i> +</i>
&gt;<i> +		printf(&quot;%5d %10s %17s %33s %s\n&quot;, probe-&gt;id,</i>
&gt;<i> +		       probe-&gt;prv_name ? probe-&gt;prv_name : &quot;&quot;,</i>
&gt;<i> +		       probe-&gt;mod_name ? probe-&gt;mod_name : &quot;&quot;,</i>
&gt;<i> +		       probe-&gt;fun_name ? probe-&gt;fun_name : &quot;&quot;,</i>
&gt;<i> +		       probe-&gt;prb_name ? probe-&gt;prb_name : &quot;&quot;);</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +</i>
&gt;<i> +	/* Done with the BPF ELF object.  */</i>
&gt;<i> +	bpf_object__close(obj);</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Load the given BPF ELF object file.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_bpf_load_file(const char *fn)</i>
&gt;<i> +{</i>
&gt;<i> +	struct bpf_object	*obj;</i>
&gt;<i> +	struct bpf_map		*map;</i>
&gt;<i> +	struct bpf_program	*prog;</i>
&gt;<i> +	int			rc, fd;</i>
&gt;<i> +</i>
&gt;<i> +	libbpf_set_print(NULL);</i>
&gt;<i> +</i>
&gt;<i> +	/* Load the BPF ELF object file. */</i>
&gt;<i> +	rc = bpf_prog_load(fn, BPF_PROG_TYPE_UNSPEC, &amp;obj, &amp;fd);</i>
&gt;<i> +	if (rc)</i>
&gt;<i> +		return rc;</i>
&gt;<i> +</i>
&gt;<i> +	/* Validate buffers map. */</i>
&gt;<i> +	map = bpf_object__find_map_by_name(obj, &quot;buffers&quot;);</i>
&gt;<i> +	if (map &amp;&amp; is_valid_buffers(bpf_map__def(map)))</i>
&gt;<i> +		dt_bufmap_fd = bpf_map__fd(map);</i>
&gt;<i> +	else</i>
&gt;<i> +		goto fail;</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Loop through the programs and resolve each into the matching probe.</i>
&gt;<i> +	 * Attach the program to the probe.</i>
&gt;<i> +	 */</i>
&gt;<i> +	for (prog = bpf_program__next(NULL, obj); prog != NULL;</i>
&gt;<i> +	     prog = bpf_program__next(prog, obj)) {</i>
&gt;<i> +		struct dt_probe	*probe;</i>
&gt;<i> +</i>
&gt;<i> +		probe = dt_probe_resolve_event(bpf_program__title(prog, false));</i>
&gt;<i> +		if (!probe)</i>
&gt;<i> +			return -ENOENT;</i>
&gt;<i> +		if (probe-&gt;prov &amp;&amp; probe-&gt;prov-&gt;attach)</i>
&gt;<i> +			probe-&gt;prov-&gt;attach(bpf_program__title(prog, false),</i>
&gt;<i> +					    bpf_program__fd(prog));</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +</i>
&gt;<i> +fail:</i>
&gt;<i> +	bpf_object__close(obj);</i>
&gt;<i> +	return -EINVAL;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Store the (key, value) pair in the map referenced by the given fd.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_bpf_map_update(int fd, const void *key, const void *val)</i>
&gt;<i> +{</i>
&gt;<i> +	union bpf_attr	attr;</i>
&gt;<i> +</i>
&gt;<i> +	memset(&amp;attr, 0, sizeof(attr));</i>
&gt;<i> +</i>
&gt;<i> +	attr.map_fd = fd;</i>
&gt;<i> +	attr.key = (u64)(unsigned long)key;</i>
&gt;<i> +	attr.value = (u64)(unsigned long)val;</i>
&gt;<i> +	attr.flags = 0;</i>
&gt;<i> +</i>
&gt;<i> +	return bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Attach a trace event and associate a BPF program with it.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_bpf_attach(int event_id, int bpf_fd)</i>
&gt;<i> +{</i>
&gt;<i> +	int			event_fd;</i>
&gt;<i> +	int			rc;</i>
&gt;<i> +	struct perf_event_attr	attr = {};</i>
&gt;<i> +</i>
&gt;<i> +	attr.type = PERF_TYPE_TRACEPOINT;</i>
&gt;<i> +	attr.sample_type = PERF_SAMPLE_RAW;</i>
&gt;<i> +	attr.sample_period = 1;</i>
&gt;<i> +	attr.wakeup_events = 1;</i>
&gt;<i> +	attr.config = event_id;</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Register the event (based on its id), and obtain a fd.  It gets</i>
&gt;<i> +	 * created as an enabled probe, so we don't have to explicitly enable</i>
&gt;<i> +	 * it.</i>
&gt;<i> +	 */</i>
&gt;<i> +	event_fd = perf_event_open(&amp;attr, -1, 0, -1, 0);</i>
&gt;<i> +	if (event_fd &lt; 0) {</i>
&gt;<i> +		perror(&quot;sys_perf_event_open&quot;);</i>
&gt;<i> +		return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/* Associate the BPF program with the event. */</i>
&gt;<i> +	rc = ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, bpf_fd);</i>
&gt;<i> +	if (rc &lt; 0) {</i>
&gt;<i> +		perror(&quot;PERF_EVENT_IOC_SET_BPF&quot;);</i>
&gt;<i> +		return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> diff --git a/tools/dtrace/dt_buffer.c b/tools/dtrace/dt_buffer.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..19bb7e4cfc92</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dt_buffer.c</i>
&gt;<i> @@ -0,0 +1,338 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * This file provides the tracing buffer handling for DTrace.  It makes use of</i>
&gt;<i> + * the perf event output ring buffers that can be written to from BPF programs.</i>
&gt;<i> + *</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;errno.h&gt;</i>
&gt;<i> +#include &lt;stdio.h&gt;</i>
&gt;<i> +#include &lt;stdlib.h&gt;</i>
&gt;<i> +#include &lt;string.h&gt;</i>
&gt;<i> +#include &lt;syscall.h&gt;</i>
&gt;<i> +#include &lt;unistd.h&gt;</i>
&gt;<i> +#include &lt;sys/epoll.h&gt;</i>
&gt;<i> +#include &lt;sys/ioctl.h&gt;</i>
&gt;<i> +#include &lt;sys/mman.h&gt;</i>
&gt;<i> +#include &lt;linux/bpf.h&gt;</i>
&gt;<i> +#include &lt;linux/perf_event.h&gt;</i>
&gt;<i> +#include &lt;linux/ring_buffer.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace_impl.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Probe data is recorded in per-CPU perf ring buffers.</i>
&gt;<i> + */</i>
&gt;<i> +struct dtrace_buffer {</i>
&gt;<i> +	int	cpu;			/* ID of CPU that uses this buffer */</i>
&gt;<i> +	int	fd;			/* fd of perf output buffer */</i>
&gt;<i> +	size_t	page_size;		/* size of each page in buffer */</i>
&gt;<i> +	size_t	data_size;		/* total buffer size */</i>
&gt;<i> +	u8	*base;			/* address of buffer */</i>
&gt;<i> +	u8	*endp;			/* address of end of buffer */</i>
&gt;<i> +	u8	*tmp;			/* temporary event buffer */</i>
&gt;<i> +	u32	tmp_len;		/* length of temporary event buffer */</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +static struct dtrace_buffer	*dt_buffers;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * File descriptor for the BPF map that holds the buffers for the online CPUs.</i>
&gt;<i> + * The map is a bpf_array indexed by CPU id, and it stores a file descriptor as</i>
&gt;<i> + * value (the fd for the perf_event that represents the CPU buffer).</i>
&gt;<i> + */</i>
&gt;<i> +int				dt_bufmap_fd = -1;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Create a perf_event buffer for the given DTrace buffer.  This will create</i>
&gt;<i> + * a perf_event ring_buffer, mmap it, and enable the perf_event that owns the</i>
&gt;<i> + * buffer.</i>
&gt;<i> + */</i>
&gt;<i> +static int perf_buffer_open(struct dtrace_buffer *buf)</i>
&gt;<i> +{</i>
&gt;<i> +	int			pefd;</i>
&gt;<i> +	struct perf_event_attr	attr = {};</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Event configuration for BPF-generated output in perf_event ring</i>
&gt;<i> +	 * buffers.  The event is created in enabled state.</i>
&gt;<i> +	 */</i>
&gt;<i> +	attr.config = PERF_COUNT_SW_BPF_OUTPUT;</i>
&gt;<i> +	attr.type = PERF_TYPE_SOFTWARE;</i>
&gt;<i> +	attr.sample_type = PERF_SAMPLE_RAW;</i>
&gt;<i> +	attr.sample_period = 1;</i>
&gt;<i> +	attr.wakeup_events = 1;</i>
&gt;<i> +	pefd = perf_event_open(&amp;attr, -1, buf-&gt;cpu, -1, PERF_FLAG_FD_CLOEXEC);</i>
&gt;<i> +	if (pefd &lt; 0) {</i>
&gt;<i> +		fprintf(stderr, &quot;perf_event_open(cpu %d): %s\n&quot;, buf-&gt;cpu,</i>
&gt;<i> +			strerror(errno));</i>
&gt;<i> +		goto fail;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * We add buf-&gt;page_size to the buf-&gt;data_size, because perf maintains</i>
&gt;<i> +	 * a meta-data page at the beginning of the memory region.  That page</i>
&gt;<i> +	 * is used for reader/writer symchronization.</i>
&gt;<i> +	 */</i>
&gt;<i> +	buf-&gt;fd = pefd;</i>
&gt;<i> +	buf-&gt;base = mmap(NULL, buf-&gt;page_size + buf-&gt;data_size,</i>
&gt;<i> +			 PROT_READ | PROT_WRITE, MAP_SHARED, buf-&gt;fd, 0);</i>
&gt;<i> +	buf-&gt;endp = buf-&gt;base + buf-&gt;page_size + buf-&gt;data_size - 1;</i>
&gt;<i> +	if (!buf-&gt;base)</i>
&gt;<i> +		goto fail;</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +</i>
&gt;<i> +fail:</i>
&gt;<i> +	if (buf-&gt;base) {</i>
&gt;<i> +		munmap(buf-&gt;base, buf-&gt;page_size + buf-&gt;data_size);</i>
&gt;<i> +		buf-&gt;base = NULL;</i>
&gt;<i> +		buf-&gt;endp = NULL;</i>
&gt;<i> +	}</i>
&gt;<i> +	if (buf-&gt;fd) {</i>
&gt;<i> +		close(buf-&gt;fd);</i>
&gt;<i> +		buf-&gt;fd = -1;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return -1;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Close the given DTrace buffer.  This function disables the perf_event that</i>
&gt;<i> + * owns the buffer, munmaps the memory space, and closes the perf buffer fd.</i>
&gt;<i> + */</i>
&gt;<i> +static void perf_buffer_close(struct dtrace_buffer *buf)</i>
&gt;<i> +{</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * If the perf buffer failed to open, there is no need to close it.</i>
&gt;<i> +	 */</i>
&gt;<i> +	if (buf-&gt;fd &lt; 0)</i>
&gt;<i> +		return;</i>
&gt;<i> +</i>
&gt;<i> +	if (ioctl(buf-&gt;fd, PERF_EVENT_IOC_DISABLE, 0) &lt; 0)</i>
&gt;<i> +		fprintf(stderr, &quot;PERF_EVENT_IOC_DISABLE(cpu %d): %s\n&quot;,</i>
&gt;<i> +			buf-&gt;cpu, strerror(errno));</i>
&gt;<i> +</i>
&gt;<i> +	munmap(buf-&gt;base, buf-&gt;page_size + buf-&gt;data_size);</i>
&gt;<i> +</i>
&gt;<i> +	if (close(buf-&gt;fd))</i>
&gt;<i> +		fprintf(stderr, &quot;perf buffer close(cpu %d): %s\n&quot;,</i>
&gt;<i> +			buf-&gt;cpu, strerror(errno));</i>
&gt;<i> +</i>
&gt;<i> +	buf-&gt;base = NULL;</i>
&gt;<i> +	buf-&gt;fd = -1;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Initialize the probe data buffers (one per online CPU).  Each buffer will</i>
&gt;<i> + * contain the given number of pages (i.e. total size of each buffer will be</i>
&gt;<i> + * num_pages * getpagesize()).  This function also sets up an event polling</i>
&gt;<i> + * descriptor that monitors all CPU buffers at once.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_buffer_init(int num_pages)</i>
&gt;<i> +{</i>
&gt;<i> +	int	i;</i>
&gt;<i> +	int	epoll_fd;</i>
&gt;<i> +</i>
&gt;<i> +	if (dt_bufmap_fd &lt; 0)</i>
&gt;<i> +		return -EINVAL;</i>
&gt;<i> +</i>
&gt;<i> +	/* Allocate the per-CPU buffer structs. */</i>
&gt;<i> +	dt_buffers = calloc(dt_numcpus, sizeof(struct dtrace_buffer));</i>
&gt;<i> +	if (dt_buffers == NULL)</i>
&gt;<i> +		return -ENOMEM;</i>
&gt;<i> +</i>
&gt;<i> +	/* Set up the event polling file descriptor. */</i>
&gt;<i> +	epoll_fd = epoll_create1(EPOLL_CLOEXEC);</i>
&gt;<i> +	if (epoll_fd &lt; 0) {</i>
&gt;<i> +		free(dt_buffers);</i>
&gt;<i> +		return -errno;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	for (i = 0; i &lt; dt_numcpus; i++) {</i>
&gt;<i> +		int			cpu = dt_cpuids[i];</i>
&gt;<i> +		struct epoll_event	ev;</i>
&gt;<i> +		struct dtrace_buffer	*buf = &amp;dt_buffers[i];</i>
&gt;<i> +</i>
&gt;<i> +		buf-&gt;cpu = cpu;</i>
&gt;<i> +		buf-&gt;page_size = getpagesize();</i>
&gt;<i> +		buf-&gt;data_size = num_pages * buf-&gt;page_size;</i>
&gt;<i> +		buf-&gt;tmp = NULL;</i>
&gt;<i> +		buf-&gt;tmp_len = 0;</i>
&gt;<i> +</i>
&gt;<i> +		/* Try to create the perf buffer for this DTrace buffer. */</i>
&gt;<i> +		if (perf_buffer_open(buf) == -1)</i>
&gt;<i> +			continue;</i>
&gt;<i> +</i>
&gt;<i> +		/* Store the perf buffer fd in the buffer map. */</i>
&gt;<i> +		dt_bpf_map_update(dt_bufmap_fd, &amp;cpu, &amp;buf-&gt;fd);</i>
&gt;<i> +</i>
&gt;<i> +		/* Add the buffer to the event polling descriptor. */</i>
&gt;<i> +		ev.events = EPOLLIN;</i>
&gt;<i> +		ev.data.ptr = buf;</i>
&gt;<i> +		if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, buf-&gt;fd, &amp;ev) == -1) {</i>
&gt;<i> +			fprintf(stderr, &quot;EPOLL_CTL_ADD(cpu %d): %s\n&quot;,</i>
&gt;<i> +				buf-&gt;cpu, strerror(errno));</i>
&gt;<i> +			continue;</i>
&gt;<i> +		}</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return epoll_fd;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Clean up the buffers.</i>
&gt;<i> + */</i>
&gt;<i> +void dt_buffer_exit(int epoll_fd)</i>
&gt;<i> +{</i>
&gt;<i> +	int	i;</i>
&gt;<i> +</i>
&gt;<i> +	for (i = 0; i &lt; dt_numcpus; i++)</i>
&gt;<i> +		perf_buffer_close(&amp;dt_buffers[i]);</i>
&gt;<i> +</i>
&gt;<i> +	free(dt_buffers);</i>
&gt;<i> +	close(epoll_fd);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Process and output the probe data at the supplied address.</i>
&gt;<i> + */</i>
&gt;<i> +static void output_event(int cpu, u64 *buf)</i>
&gt;<i> +{</i>
&gt;<i> +	u8				*data = (u8 *)buf;</i>
&gt;<i> +	struct perf_event_header	*hdr;</i>
&gt;<i> +</i>
&gt;<i> +	hdr = (struct perf_event_header *)data;</i>
&gt;<i> +	data += sizeof(struct perf_event_header);</i>
&gt;<i> +</i>
&gt;<i> +	if (hdr-&gt;type == PERF_RECORD_SAMPLE) {</i>
&gt;<i> +		u8		*ptr = data;</i>
&gt;<i> +		u32		i, size, probe_id;</i>
&gt;<i> +</i>
&gt;<i> +		/*</i>
&gt;<i> +		 * struct {</i>
&gt;<i> +		 *	struct perf_event_header	header;</i>
&gt;<i> +		 *	u32				size;</i>
&gt;<i> +		 *	u32				probe_id;</i>
&gt;<i> +		 *	u32				gap;</i>
&gt;<i> +		 *	u64				data[n];</i>
&gt;<i> +		 * }</i>
&gt;<i> +		 * and data points to the 'size' member at this point.</i>
&gt;<i> +		 */</i>
&gt;<i> +		if (ptr &gt; (u8 *)buf + hdr-&gt;size) {</i>
&gt;<i> +			fprintf(stderr, &quot;BAD: corrupted sample header\n&quot;);</i>
&gt;<i> +			return;</i>
&gt;<i> +		}</i>
&gt;<i> +</i>
&gt;<i> +		size = *(u32 *)data;</i>
&gt;<i> +		data += sizeof(size);</i>
&gt;<i> +		ptr += sizeof(size) + size;</i>
&gt;<i> +		if (ptr != (u8 *)buf + hdr-&gt;size) {</i>
&gt;<i> +			fprintf(stderr, &quot;BAD: invalid sample size\n&quot;);</i>
&gt;<i> +			return;</i>
&gt;<i> +		}</i>
&gt;<i> +</i>
&gt;<i> +		probe_id = *(u32 *)data;</i>
&gt;<i> +		data += sizeof(probe_id);</i>
&gt;<i> +		size -= sizeof(probe_id);</i>
&gt;<i> +		data += sizeof(u32);		/* skip 32-bit gap */</i>
&gt;<i> +		size -= sizeof(u32);</i>
&gt;<i> +		buf = (u64 *)data;</i>
&gt;<i> +</i>
&gt;<i> +		printf(&quot;%3d %6d &quot;, cpu, probe_id);</i>
&gt;<i> +		for (i = 0, size /= sizeof(u64); i &lt; size; i++)</i>
&gt;<i> +			printf(&quot;%#016lx &quot;, buf[i]);</i>
&gt;<i> +		printf(&quot;\n&quot;);</i>
&gt;<i> +	} else if (hdr-&gt;type == PERF_RECORD_LOST) {</i>
&gt;<i> +		u64	lost;</i>
&gt;<i> +</i>
&gt;<i> +		/*</i>
&gt;<i> +		 * struct {</i>
&gt;<i> +		 *	struct perf_event_header	header;</i>
&gt;<i> +		 *	u64				id;</i>
&gt;<i> +		 *	u64				lost;</i>
&gt;<i> +		 * }</i>
&gt;<i> +		 * and data points to the 'id' member at this point.</i>
&gt;<i> +		 */</i>
&gt;<i> +		lost = *(u64 *)(data + sizeof(u64));</i>
&gt;<i> +</i>
&gt;<i> +		printf(&quot;[%ld probes dropped]\n&quot;, lost);</i>
&gt;<i> +	} else</i>
&gt;<i> +		fprintf(stderr, &quot;UNKNOWN: record type %d\n&quot;, hdr-&gt;type);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Process the available probe data in the given buffer.</i>
&gt;<i> + */</i>
&gt;<i> +static void process_data(struct dtrace_buffer *buf)</i>
&gt;<i> +{</i>
&gt;<i> +	struct perf_event_mmap_page	*rb_page = (void *)buf-&gt;base;</i>
&gt;<i> +	struct perf_event_header	*hdr;</i>
&gt;<i> +	u8				*base;</i>
&gt;<i> +	u64				head, tail;</i>
&gt;<i> +</i>
&gt;<i> +	/* Set base to be the start of the buffer data. */</i>
&gt;<i> +	base = buf-&gt;base + buf-&gt;page_size;</i>
&gt;<i> +</i>
&gt;<i> +	for (;;) {</i>
&gt;<i> +		head = ring_buffer_read_head(rb_page);</i>
&gt;<i> +		tail = rb_page-&gt;data_tail;</i>
&gt;<i> +</i>
&gt;<i> +		if (tail == head)</i>
&gt;<i> +			break;</i>
&gt;<i> +</i>
&gt;<i> +		do {</i>
&gt;<i> +			u8	*event = base + tail % buf-&gt;data_size;</i>
&gt;<i> +			u32	len;</i>
&gt;<i> +</i>
&gt;<i> +			hdr = (struct perf_event_header *)event;</i>
&gt;<i> +			len = hdr-&gt;size;</i>
&gt;<i> +</i>
&gt;<i> +			/*</i>
&gt;<i> +			 * If the perf event data wraps around the boundary of</i>
&gt;<i> +			 * the buffer, we make a copy in contiguous memory.</i>
&gt;<i> +			 */</i>
&gt;<i> +			if (event + len &gt; buf-&gt;endp) {</i>
&gt;<i> +				u8	*dst;</i>
&gt;<i> +				u32	num;</i>
&gt;<i> +</i>
&gt;<i> +				/* Increase buffer as needed. */</i>
&gt;<i> +				if (buf-&gt;tmp_len &lt; len) {</i>
&gt;<i> +					buf-&gt;tmp = realloc(buf-&gt;tmp, len);</i>
&gt;<i> +					buf-&gt;tmp_len = len;</i>
&gt;<i> +				}</i>
&gt;<i> +</i>
&gt;<i> +				dst = buf-&gt;tmp;</i>
&gt;<i> +				num = buf-&gt;endp - event + 1;</i>
&gt;<i> +				memcpy(dst, event, num);</i>
&gt;<i> +				memcpy(dst + num, base, len - num);</i>
&gt;<i> +</i>
&gt;<i> +				event = dst;</i>
&gt;<i> +			}</i>
&gt;<i> +</i>
&gt;<i> +			output_event(buf-&gt;cpu, (u64 *)event);</i>
&gt;<i> +</i>
&gt;<i> +			tail += hdr-&gt;size;</i>
&gt;<i> +		} while (tail != head);</i>
&gt;<i> +</i>
&gt;<i> +		ring_buffer_write_tail(rb_page, tail);</i>
&gt;<i> +	}</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Wait for data to become available in any of the buffers.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_buffer_poll(int epoll_fd, int timeout)</i>
&gt;<i> +{</i>
&gt;<i> +	struct epoll_event	events[dt_numcpus];</i>
&gt;<i> +	int			i, cnt;</i>
&gt;<i> +</i>
&gt;<i> +	cnt = epoll_wait(epoll_fd, events, dt_numcpus, timeout);</i>
&gt;<i> +	if (cnt &lt; 0)</i>
&gt;<i> +		return -errno;</i>
&gt;<i> +</i>
&gt;<i> +	for (i = 0; i &lt; cnt; i++)</i>
&gt;<i> +		process_data((struct dtrace_buffer *)events[i].data.ptr);</i>
&gt;<i> +</i>
&gt;<i> +	return cnt;</i>
&gt;<i> +}</i>
&gt;<i> diff --git a/tools/dtrace/dt_fbt.c b/tools/dtrace/dt_fbt.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..fcf95243bf97</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dt_fbt.c</i>
&gt;<i> @@ -0,0 +1,201 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * The Function Boundary Tracing (FBT) provider for DTrace.</i>
&gt;<i> + *</i>
&gt;<i> + * FBT probes are exposed by the kernel as kprobes.  They are listed in the</i>
&gt;<i> + * TRACEFS/available_filter_functions file.  Some kprobes are associated with</i>
&gt;<i> + * a specific kernel module, while most are in the core kernel.</i>
&gt;<i> + *</i>
&gt;<i> + * Mapping from event name to DTrace probe name:</i>
&gt;<i> + *</i>
&gt;<i> + *      &lt;name&gt;					fbt:vmlinux:&lt;name&gt;:entry</i>
&gt;<i> + *						fbt:vmlinux:&lt;name&gt;:return</i>
&gt;<i> + *   or</i>
&gt;<i> + *      &lt;name&gt; [&lt;modname&gt;]			fbt:&lt;modname&gt;:&lt;name&gt;:entry</i>
&gt;<i> + *						fbt:&lt;modname&gt;:&lt;name&gt;:return</i>
&gt;<i> + *</i>
&gt;<i> + * Mapping from BPF section name to DTrace probe name:</i>
&gt;<i> + *</i>
&gt;<i> + *      kprobe/&lt;name&gt;				fbt:vmlinux:&lt;name&gt;:entry</i>
&gt;<i> + *      kretprobe/&lt;name&gt;			fbt:vmlinux:&lt;name&gt;:return</i>
&gt;<i> + *</i>
&gt;<i> + * (Note that the BPF section does not carry information about the module that</i>
&gt;<i> + *  the function is found in.  This means that BPF section name cannot be used</i>
&gt;<i> + *  to distinguish between functions with the same name occurring in different</i>
&gt;<i> + *  modules.)</i>
&gt;<i> + *</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;fcntl.h&gt;</i>
&gt;<i> +#include &lt;stdio.h&gt;</i>
&gt;<i> +#include &lt;stdlib.h&gt;</i>
&gt;<i> +#include &lt;string.h&gt;</i>
&gt;<i> +#include &lt;unistd.h&gt;</i>
&gt;<i> +#include &lt;linux/bpf.h&gt;</i>
&gt;<i> +#include &lt;sys/stat.h&gt;</i>
&gt;<i> +#include &lt;sys/types.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace_impl.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +#define KPROBE_EVENTS	TRACEFS &quot;kprobe_events&quot;</i>
&gt;<i> +#define PROBE_LIST	TRACEFS &quot;available_filter_functions&quot;</i>
&gt;<i> +</i>
&gt;<i> +static const char	provname[] = &quot;fbt&quot;;</i>
&gt;<i> +static const char	modname[] = &quot;vmlinux&quot;;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Scan the PROBE_LIST file and add entry and return probes for every function</i>
&gt;<i> + * that is listed.</i>
&gt;<i> + */</i>
&gt;<i> +static int fbt_populate(void)</i>
&gt;<i> +{</i>
&gt;<i> +	FILE			*f;</i>
&gt;<i> +	char			buf[256];</i>
&gt;<i> +	char			*p;</i>
&gt;<i> +</i>
&gt;<i> +	f = fopen(PROBE_LIST, &quot;r&quot;);</i>
&gt;<i> +	if (f == NULL)</i>
&gt;<i> +		return -1;</i>
&gt;<i> +</i>
&gt;<i> +	while (fgets(buf, sizeof(buf), f)) {</i>
&gt;<i> +		/*</i>
&gt;<i> +		 * Here buf is either &quot;funcname\n&quot; or &quot;funcname [modname]\n&quot;.</i>
&gt;<i> +		 */</i>
&gt;<i> +		p = strchr(buf, '\n');</i>
&gt;<i> +		if (p) {</i>
&gt;<i> +			*p = '\0';</i>
&gt;<i> +			if (p &gt; buf &amp;&amp; *(--p) == ']')</i>
&gt;<i> +				*p = '\0';</i>
&gt;<i> +		} else {</i>
&gt;<i> +			/* If we didn't see a newline, the line was too long.</i>
&gt;<i> +			 * Report it, and continue until the end of the line.</i>
&gt;<i> +			 */</i>
&gt;<i> +			fprintf(stderr, &quot;%s: Line too long: %s\n&quot;,</i>
&gt;<i> +				PROBE_LIST, buf);</i>
&gt;<i> +			do</i>
&gt;<i> +				fgets(buf, sizeof(buf), f);</i>
&gt;<i> +			while (strchr(buf, '\n') == NULL);</i>
&gt;<i> +			continue;</i>
&gt;<i> +		}</i>
&gt;<i> +</i>
&gt;<i> +		/*</i>
&gt;<i> +		 * Now buf is either &quot;funcname&quot; or &quot;funcname [modname&quot;.  If</i>
&gt;<i> +		 * there is no module name provided, we will use the default.</i>
&gt;<i> +		 */</i>
&gt;<i> +		p = strchr(buf, ' ');</i>
&gt;<i> +		if (p) {</i>
&gt;<i> +			*p++ = '\0';</i>
&gt;<i> +			if (*p == '[')</i>
&gt;<i> +				p++;</i>
&gt;<i> +		}</i>
&gt;<i> +</i>
&gt;<i> +		dt_probe_new(&amp;dt_fbt, provname, p ? p : modname, buf, &quot;entry&quot;);</i>
&gt;<i> +		dt_probe_new(&amp;dt_fbt, provname, p ? p : modname, buf, &quot;return&quot;);</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	fclose(f);</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +#define ENTRY_PREFIX	&quot;kprobe/&quot;</i>
&gt;<i> +#define EXIT_PREFIX	&quot;kretprobe/&quot;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Perform a probe lookup based on an event name (BPF ELF section name).</i>
&gt;<i> + */</i>
&gt;<i> +static struct dt_probe *fbt_resolve_event(const char *name)</i>
&gt;<i> +{</i>
&gt;<i> +	const char	*prbname;</i>
&gt;<i> +	struct dt_probe	tmpl;</i>
&gt;<i> +	struct dt_probe	*probe;</i>
&gt;<i> +</i>
&gt;<i> +	if (!name)</i>
&gt;<i> +		return NULL;</i>
&gt;<i> +</i>
&gt;<i> +	if (strncmp(name, ENTRY_PREFIX, sizeof(ENTRY_PREFIX) - 1) == 0) {</i>
&gt;<i> +		name += sizeof(ENTRY_PREFIX) - 1;</i>
&gt;<i> +		prbname = &quot;entry&quot;;</i>
&gt;<i> +	} else if (strncmp(name, EXIT_PREFIX, sizeof(EXIT_PREFIX) - 1) == 0) {</i>
&gt;<i> +		name += sizeof(EXIT_PREFIX) - 1;</i>
&gt;<i> +		prbname = &quot;return&quot;;</i>
&gt;<i> +	} else</i>
&gt;<i> +		return NULL;</i>
&gt;<i> +</i>
&gt;<i> +	memset(&amp;tmpl, 0, sizeof(tmpl));</i>
&gt;<i> +	tmpl.prv_name = provname;</i>
&gt;<i> +	tmpl.mod_name = modname;</i>
&gt;<i> +	tmpl.fun_name = name;</i>
&gt;<i> +	tmpl.prb_name = prbname;</i>
&gt;<i> +</i>
&gt;<i> +	probe = dt_probe_by_name(&amp;tmpl);</i>
&gt;<i> +</i>
&gt;<i> +	return probe;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Attach the given BPF program (identified by its file descriptor) to the</i>
&gt;<i> + * kprobe identified by the given section name.</i>
&gt;<i> + */</i>
&gt;<i> +static int fbt_attach(const char *name, int bpf_fd)</i>
&gt;<i> +{</i>
&gt;<i> +	char    efn[256];</i>
&gt;<i> +	char    buf[256];</i>
&gt;<i> +	int	event_id, fd, rc;</i>
&gt;<i> +</i>
&gt;<i> +	name += 7;				/* skip &quot;kprobe/&quot; */</i>
&gt;<i> +	snprintf(buf, sizeof(buf), &quot;p:%s %s\n&quot;, name, name);</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Register the kprobe with the tracing subsystem.  This will create</i>
&gt;<i> +	 * a tracepoint event.</i>
&gt;<i> +	 */</i>
&gt;<i> +	fd = open(KPROBE_EVENTS, O_WRONLY | O_APPEND);</i>
&gt;<i> +	if (fd &lt; 0) {</i>
&gt;<i> +		perror(KPROBE_EVENTS);</i>
&gt;<i> +		return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +	rc = write(fd, buf, strlen(buf));</i>
&gt;<i> +	if (rc &lt; 0) {</i>
&gt;<i> +		perror(KPROBE_EVENTS);</i>
&gt;<i> +		close(fd);</i>
&gt;<i> +		return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +	close(fd);</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Read the tracepoint event id for the kprobe we just registered.</i>
&gt;<i> +	 */</i>
&gt;<i> +	strcpy(efn, EVENTSFS);</i>
&gt;<i> +	strcat(efn, &quot;kprobes/&quot;);</i>
&gt;<i> +	strcat(efn, name);</i>
&gt;<i> +	strcat(efn, &quot;/id&quot;);</i>
&gt;<i> +</i>
&gt;<i> +	fd = open(efn, O_RDONLY);</i>
&gt;<i> +	if (fd &lt; 0) {</i>
&gt;<i> +		perror(efn);</i>
&gt;<i> +		return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +	rc = read(fd, buf, sizeof(buf));</i>
&gt;<i> +	if (rc &lt; 0 || rc &gt;= sizeof(buf)) {</i>
&gt;<i> +		perror(efn);</i>
&gt;<i> +		close(fd);</i>
&gt;<i> +		return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +	close(fd);</i>
&gt;<i> +	buf[rc] = '\0';</i>
&gt;<i> +	event_id = atoi(buf);</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Attaching a BPF program (by file descriptor) to an event (by ID) is</i>
&gt;<i> +	 * a generic operation provided by the BPF interface code.</i>
&gt;<i> +	 */</i>
&gt;<i> +	return dt_bpf_attach(event_id, bpf_fd);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +struct dt_provider	dt_fbt = {</i>
&gt;<i> +	.name		= &quot;fbt&quot;,</i>
&gt;<i> +	.populate	= &amp;fbt_populate,</i>
&gt;<i> +	.resolve_event	= &amp;fbt_resolve_event,</i>
&gt;<i> +	.attach		= &amp;fbt_attach,</i>
&gt;<i> +};</i>
&gt;<i> diff --git a/tools/dtrace/dt_hash.c b/tools/dtrace/dt_hash.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..b1f563bc0773</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dt_hash.c</i>
&gt;<i> @@ -0,0 +1,211 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * This file provides a generic hashtable implementation for probes.</i>
&gt;<i> + *</i>
&gt;<i> + * The hashtable is created with 4 user-provided functions:</i>
&gt;<i> + *	hval(probe)		- calculate a hash value for the given probe</i>
&gt;<i> + *	cmp(probe1, probe2)	- compare two probes</i>
&gt;<i> + *	add(head, probe)	- add a probe to a list of probes</i>
&gt;<i> + *	del(head, probe)	- delete a probe from a list of probes</i>
&gt;<i> + *</i>
&gt;<i> + * Probes are hashed into a hashtable slot based on the return value of</i>
&gt;<i> + * hval(probe).  Each hashtable slot holds a list of buckets, with each</i>
&gt;<i> + * bucket storing probes that are equal under the cmp(probe1, probe2)</i>
&gt;<i> + * function. Probes are added to the list of probes in a bucket using the</i>
&gt;<i> + * add(head, probe) function, and they are deleted using a call to the</i>
&gt;<i> + * del(head, probe) function.</i>
&gt;<i> + *</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;errno.h&gt;</i>
&gt;<i> +#include &lt;stdint.h&gt;</i>
&gt;<i> +#include &lt;stdlib.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace_impl.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Hashtable implementation for probes.</i>
&gt;<i> + */</i>
&gt;<i> +struct dt_hbucket {</i>
&gt;<i> +	u32			hval;</i>
&gt;<i> +	struct dt_hbucket	*next;</i>
&gt;<i> +	struct dt_probe		*head;</i>
&gt;<i> +	int			nprobes;</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +struct dt_htab {</i>
&gt;<i> +	struct dt_hbucket	**tab;</i>
&gt;<i> +	int			size;</i>
&gt;<i> +	int			mask;</i>
&gt;<i> +	int			nbuckets;</i>
&gt;<i> +	dt_hval_fn		hval;		/* calculate hash value */</i>
&gt;<i> +	dt_cmp_fn		cmp;		/* compare 2 probes */</i>
&gt;<i> +	dt_add_fn		add;		/* add probe to list */</i>
&gt;<i> +	dt_del_fn		del;		/* delete probe from list */</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Create a new (empty) hashtable.</i>
&gt;<i> + */</i>
&gt;<i> +struct dt_htab *dt_htab_new(dt_hval_fn hval, dt_cmp_fn cmp, dt_add_fn add,</i>
&gt;<i> +			    dt_del_fn del)</i>
&gt;<i> +{</i>
&gt;<i> +	struct dt_htab	*htab = malloc(sizeof(struct dt_htab));</i>
&gt;<i> +</i>
&gt;<i> +	if (!htab)</i>
&gt;<i> +		return NULL;</i>
&gt;<i> +</i>
&gt;<i> +	htab-&gt;size = 1;</i>
&gt;<i> +	htab-&gt;mask = htab-&gt;size - 1;</i>
&gt;<i> +	htab-&gt;nbuckets = 0;</i>
&gt;<i> +	htab-&gt;hval = hval;</i>
&gt;<i> +	htab-&gt;cmp = cmp;</i>
&gt;<i> +	htab-&gt;add = add;</i>
&gt;<i> +	htab-&gt;del = del;</i>
&gt;<i> +</i>
&gt;<i> +	htab-&gt;tab = calloc(htab-&gt;size, sizeof(struct dt_hbucket *));</i>
&gt;<i> +	if (!htab-&gt;tab) {</i>
&gt;<i> +		free(htab);</i>
&gt;<i> +		return NULL;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return htab;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Resize the hashtable by doubling the number of slots.</i>
&gt;<i> + */</i>
&gt;<i> +static int resize(struct dt_htab *htab)</i>
&gt;<i> +{</i>
&gt;<i> +	int			i;</i>
&gt;<i> +	int			osize = htab-&gt;size;</i>
&gt;<i> +	int			nsize = osize &lt;&lt; 1;</i>
&gt;<i> +	int			nmask = nsize - 1;</i>
&gt;<i> +	struct dt_hbucket	**ntab;</i>
&gt;<i> +</i>
&gt;<i> +	ntab = calloc(nsize, sizeof(struct dt_hbucket *));</i>
&gt;<i> +	if (!ntab)</i>
&gt;<i> +		return -ENOMEM;</i>
&gt;<i> +</i>
&gt;<i> +	for (i = 0; i &lt; osize; i++) {</i>
&gt;<i> +		struct dt_hbucket	*bucket, *next;</i>
&gt;<i> +</i>
&gt;<i> +		for (bucket = htab-&gt;tab[i]; bucket; bucket = next) {</i>
&gt;<i> +			int	idx	= bucket-&gt;hval &amp; nmask;</i>
&gt;<i> +</i>
&gt;<i> +			next = bucket-&gt;next;</i>
&gt;<i> +			bucket-&gt;next = ntab[idx];</i>
&gt;<i> +			ntab[idx] = bucket;</i>
&gt;<i> +		}</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	free(htab-&gt;tab);</i>
&gt;<i> +	htab-&gt;tab = ntab;</i>
&gt;<i> +	htab-&gt;size = nsize;</i>
&gt;<i> +	htab-&gt;mask = nmask;</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Add a probe to the hashtable.  Resize if necessary, and allocate a new</i>
&gt;<i> + * bucket if necessary.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_htab_add(struct dt_htab *htab, struct dt_probe *probe)</i>
&gt;<i> +{</i>
&gt;<i> +	u32			hval = htab-&gt;hval(probe);</i>
&gt;<i> +	int			idx;</i>
&gt;<i> +	struct dt_hbucket	*bucket;</i>
&gt;<i> +</i>
&gt;<i> +retry:</i>
&gt;<i> +	idx = hval &amp; htab-&gt;mask;</i>
&gt;<i> +	for (bucket = htab-&gt;tab[idx]; bucket; bucket = bucket-&gt;next) {</i>
&gt;<i> +		if (htab-&gt;cmp(bucket-&gt;head, probe) == 0)</i>
&gt;<i> +			goto add;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	if ((htab-&gt;nbuckets &gt;&gt; 1) &gt; htab-&gt;size) {</i>
&gt;<i> +		int	err;</i>
&gt;<i> +</i>
&gt;<i> +		err = resize(htab);</i>
&gt;<i> +		if (err)</i>
&gt;<i> +			return err;</i>
&gt;<i> +</i>
&gt;<i> +		goto retry;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	bucket = malloc(sizeof(struct dt_hbucket));</i>
&gt;<i> +	if (!bucket)</i>
&gt;<i> +		return -ENOMEM;</i>
&gt;<i> +</i>
&gt;<i> +	bucket-&gt;hval = hval;</i>
&gt;<i> +	bucket-&gt;next = htab-&gt;tab[idx];</i>
&gt;<i> +	bucket-&gt;head = NULL;</i>
&gt;<i> +	bucket-&gt;nprobes = 0;</i>
&gt;<i> +	htab-&gt;tab[idx] = bucket;</i>
&gt;<i> +	htab-&gt;nbuckets++;</i>
&gt;<i> +</i>
&gt;<i> +add:</i>
&gt;<i> +	bucket-&gt;head = htab-&gt;add(bucket-&gt;head, probe);</i>
&gt;<i> +	bucket-&gt;nprobes++;</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Find a probe in the hashtable.</i>
&gt;<i> + */</i>
&gt;<i> +struct dt_probe *dt_htab_lookup(const struct dt_htab *htab,</i>
&gt;<i> +				const struct dt_probe *probe)</i>
&gt;<i> +{</i>
&gt;<i> +	u32			hval = htab-&gt;hval(probe);</i>
&gt;<i> +	int			idx = hval &amp; htab-&gt;mask;</i>
&gt;<i> +	struct dt_hbucket	*bucket;</i>
&gt;<i> +</i>
&gt;<i> +	for (bucket = htab-&gt;tab[idx]; bucket; bucket = bucket-&gt;next) {</i>
&gt;<i> +		if (htab-&gt;cmp(bucket-&gt;head, probe) == 0)</i>
&gt;<i> +			return bucket-&gt;head;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return NULL;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Remove a probe from the hashtable.  If we are deleting the last probe in a</i>
&gt;<i> + * bucket, get rid of the bucket.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_htab_del(struct dt_htab *htab, struct dt_probe *probe)</i>
&gt;<i> +{</i>
&gt;<i> +	u32			hval = htab-&gt;hval(probe);</i>
&gt;<i> +	int			idx = hval &amp; htab-&gt;mask;</i>
&gt;<i> +	struct dt_hbucket	*bucket;</i>
&gt;<i> +	struct dt_probe		*head;</i>
&gt;<i> +</i>
&gt;<i> +	for (bucket = htab-&gt;tab[idx]; bucket; bucket = bucket-&gt;next) {</i>
&gt;<i> +		if (htab-&gt;cmp(bucket-&gt;head, probe) == 0)</i>
&gt;<i> +			break;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	if (bucket == NULL)</i>
&gt;<i> +		return -ENOENT;</i>
&gt;<i> +</i>
&gt;<i> +	head = htab-&gt;del(bucket-&gt;head, probe);</i>
&gt;<i> +	if (!head) {</i>
&gt;<i> +		struct dt_hbucket	*b = htab-&gt;tab[idx];</i>
&gt;<i> +</i>
&gt;<i> +		if (bucket == b)</i>
&gt;<i> +			htab-&gt;tab[idx] = bucket-&gt;next;</i>
&gt;<i> +		else {</i>
&gt;<i> +			while (b-&gt;next != bucket)</i>
&gt;<i> +				b = b-&gt;next;</i>
&gt;<i> +</i>
&gt;<i> +			b-&gt;next = bucket-&gt;next;</i>
&gt;<i> +		}</i>
&gt;<i> +</i>
&gt;<i> +		htab-&gt;nbuckets--;</i>
&gt;<i> +		free(bucket);</i>
&gt;<i> +	} else</i>
&gt;<i> +		bucket-&gt;head = head;</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> diff --git a/tools/dtrace/dt_probe.c b/tools/dtrace/dt_probe.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..0b6228eaff29</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dt_probe.c</i>
&gt;<i> @@ -0,0 +1,230 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * This file implements the interface to probes grouped by provider.</i>
&gt;<i> + *</i>
&gt;<i> + * Probes are named by a set of 4 identifiers:</i>
&gt;<i> + *	- provider name</i>
&gt;<i> + *	- module name</i>
&gt;<i> + *	- function name</i>
&gt;<i> + *	- probe name</i>
&gt;<i> + *</i>
&gt;<i> + * The Fully Qualified Name (FQN) is &quot;provider:module:function:name&quot;.</i>
&gt;<i> + *</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;errno.h&gt;</i>
&gt;<i> +#include &lt;stdio.h&gt;</i>
&gt;<i> +#include &lt;stdlib.h&gt;</i>
&gt;<i> +#include &lt;string.h&gt;</i>
&gt;<i> +#include &lt;linux/bpf.h&gt;</i>
&gt;<i> +#include &lt;linux/kernel.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace_impl.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +static struct dt_provider      *dt_providers[] = {</i>
&gt;<i> +							&amp;dt_fbt,</i>
&gt;<i> +							&amp;dt_syscall,</i>
&gt;<i> +						 };</i>
&gt;<i> +</i>
&gt;<i> +static struct dt_htab	*ht_byfqn;</i>
&gt;<i> +</i>
&gt;<i> +static u32		next_probe_id;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Calculate a hash value based on a given string and an initial value.  The</i>
&gt;<i> + * initial value is used to calculate compound hash values, e.g.</i>
&gt;<i> + *</i>
&gt;<i> + *	u32	hval;</i>
&gt;<i> + *</i>
&gt;<i> + *	hval = str2hval(str1, 0);</i>
&gt;<i> + *	hval = str2hval(str2, hval);</i>
&gt;<i> + */</i>
&gt;<i> +static u32 str2hval(const char *p, u32 hval)</i>
&gt;<i> +{</i>
&gt;<i> +	u32	g;</i>
&gt;<i> +</i>
&gt;<i> +	if (!p)</i>
&gt;<i> +		return hval;</i>
&gt;<i> +</i>
&gt;<i> +	while (*p) {</i>
&gt;<i> +		hval = (hval &lt;&lt; 4) + *p++;</i>
&gt;<i> +		g = hval &amp; 0xf0000000;</i>
&gt;<i> +		if (g != 0)</i>
&gt;<i> +			hval ^= g &gt;&gt; 24;</i>
&gt;<i> +</i>
&gt;<i> +		hval &amp;= ~g;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return hval;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * String compare function that can handle either or both strings being NULL.</i>
&gt;<i> + */</i>
&gt;<i> +static int safe_strcmp(const char *p, const char *q)</i>
&gt;<i> +{</i>
&gt;<i> +	return (!p) ? (!q) ? 0</i>
&gt;<i> +			   : -1</i>
&gt;<i> +		    : (!q) ? 1</i>
&gt;<i> +			   : strcmp(p, q);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Calculate the hash value of a probe as the cummulative hash value of the</i>
&gt;<i> + * FQN.</i>
&gt;<i> + */</i>
&gt;<i> +static u32 fqn_hval(const struct dt_probe *probe)</i>
&gt;<i> +{</i>
&gt;<i> +	u32	hval = 0;</i>
&gt;<i> +</i>
&gt;<i> +	hval = str2hval(probe-&gt;prv_name, hval);</i>
&gt;<i> +	hval = str2hval(&quot;:&quot;, hval);</i>
&gt;<i> +	hval = str2hval(probe-&gt;mod_name, hval);</i>
&gt;<i> +	hval = str2hval(&quot;:&quot;, hval);</i>
&gt;<i> +	hval = str2hval(probe-&gt;fun_name, hval);</i>
&gt;<i> +	hval = str2hval(&quot;:&quot;, hval);</i>
&gt;<i> +	hval = str2hval(probe-&gt;prb_name, hval);</i>
&gt;<i> +</i>
&gt;<i> +	return hval;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Compare two probes based on the FQN.</i>
&gt;<i> + */</i>
&gt;<i> +static int fqn_cmp(const struct dt_probe *p, const struct dt_probe *q)</i>
&gt;<i> +{</i>
&gt;<i> +	int	rc;</i>
&gt;<i> +</i>
&gt;<i> +	rc = safe_strcmp(p-&gt;prv_name, q-&gt;prv_name);</i>
&gt;<i> +	if (rc)</i>
&gt;<i> +		return rc;</i>
&gt;<i> +	rc = safe_strcmp(p-&gt;mod_name, q-&gt;mod_name);</i>
&gt;<i> +	if (rc)</i>
&gt;<i> +		return rc;</i>
&gt;<i> +	rc = safe_strcmp(p-&gt;fun_name, q-&gt;fun_name);</i>
&gt;<i> +	if (rc)</i>
&gt;<i> +		return rc;</i>
&gt;<i> +	rc = safe_strcmp(p-&gt;prb_name, q-&gt;prb_name);</i>
&gt;<i> +	if (rc)</i>
&gt;<i> +		return rc;</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Add the given probe 'new' to the double-linked probe list 'head'.  Probe</i>
&gt;<i> + * 'new' becomes the new list head.</i>
&gt;<i> + */</i>
&gt;<i> +static struct dt_probe *fqn_add(struct dt_probe *head, struct dt_probe *new)</i>
&gt;<i> +{</i>
&gt;<i> +	if (!head)</i>
&gt;<i> +		return new;</i>
&gt;<i> +</i>
&gt;<i> +	new-&gt;he_fqn.next = head;</i>
&gt;<i> +	head-&gt;he_fqn.prev = new;</i>
&gt;<i> +</i>
&gt;<i> +	return new;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Remove the given probe 'probe' from the double-linked probe list 'head'.</i>
&gt;<i> + * If we are deleting the current head, the next probe in the list is returned</i>
&gt;<i> + * as the new head.  If that value is NULL, the list is now empty.</i>
&gt;<i> + */</i>
&gt;<i> +static struct dt_probe *fqn_del(struct dt_probe *head, struct dt_probe *probe)</i>
&gt;<i> +{</i>
&gt;<i> +	if (head == probe) {</i>
&gt;<i> +		if (!probe-&gt;he_fqn.next)</i>
&gt;<i> +			return NULL;</i>
&gt;<i> +</i>
&gt;<i> +		head = probe-&gt;he_fqn.next;</i>
&gt;<i> +		head-&gt;he_fqn.prev = NULL;</i>
&gt;<i> +		probe-&gt;he_fqn.next = NULL;</i>
&gt;<i> +</i>
&gt;<i> +		return head;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	if (!probe-&gt;he_fqn.next) {</i>
&gt;<i> +		probe-&gt;he_fqn.prev-&gt;he_fqn.next = NULL;</i>
&gt;<i> +		probe-&gt;he_fqn.prev = NULL;</i>
&gt;<i> +</i>
&gt;<i> +		return head;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	probe-&gt;he_fqn.prev-&gt;he_fqn.next = probe-&gt;he_fqn.next;</i>
&gt;<i> +	probe-&gt;he_fqn.next-&gt;he_fqn.prev = probe-&gt;he_fqn.prev;</i>
&gt;<i> +	probe-&gt;he_fqn.prev = probe-&gt;he_fqn.next = NULL;</i>
&gt;<i> +</i>
&gt;<i> +	return head;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Initialize the probe handling by populating the FQN hashtable with probes</i>
&gt;<i> + * from all providers.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_probe_init(void)</i>
&gt;<i> +{</i>
&gt;<i> +	int	i;</i>
&gt;<i> +</i>
&gt;<i> +	ht_byfqn = dt_htab_new(fqn_hval, fqn_cmp, fqn_add, fqn_del);</i>
&gt;<i> +</i>
&gt;<i> +	for (i = 0; i &lt; ARRAY_SIZE(dt_providers); i++) {</i>
&gt;<i> +		if (dt_providers[i]-&gt;populate() &lt; 0)</i>
&gt;<i> +			return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Allocate a new probe and add it to the FQN hashtable.</i>
&gt;<i> + */</i>
&gt;<i> +int dt_probe_new(const struct dt_provider *prov, const char *pname,</i>
&gt;<i> +		 const char *mname, const char *fname, const char *name)</i>
&gt;<i> +{</i>
&gt;<i> +	struct dt_probe	*probe;</i>
&gt;<i> +</i>
&gt;<i> +	probe = malloc(sizeof(struct dt_probe));</i>
&gt;<i> +	if (!probe)</i>
&gt;<i> +		return -ENOMEM;</i>
&gt;<i> +</i>
&gt;<i> +	memset(probe, 0, sizeof(struct dt_probe));</i>
&gt;<i> +	probe-&gt;id = next_probe_id++;</i>
&gt;<i> +	probe-&gt;prov = prov;</i>
&gt;<i> +	probe-&gt;prv_name = pname ? strdup(pname) : NULL;</i>
&gt;<i> +	probe-&gt;mod_name = mname ? strdup(mname) : NULL;</i>
&gt;<i> +	probe-&gt;fun_name = fname ? strdup(fname) : NULL;</i>
&gt;<i> +	probe-&gt;prb_name = name ? strdup(name) : NULL;</i>
&gt;<i> +</i>
&gt;<i> +	dt_htab_add(ht_byfqn, probe);</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Perform a probe lookup based on FQN.</i>
&gt;<i> + */</i>
&gt;<i> +struct dt_probe *dt_probe_by_name(const struct dt_probe *tmpl)</i>
&gt;<i> +{</i>
&gt;<i> +	return dt_htab_lookup(ht_byfqn, tmpl);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Resolve an event name (BPF ELF section name) into a probe.  We query each</i>
&gt;<i> + * provider, and as soon as we get a hit, we return the result.</i>
&gt;<i> + */</i>
&gt;<i> +struct dt_probe *dt_probe_resolve_event(const char *name)</i>
&gt;<i> +{</i>
&gt;<i> +	int		i;</i>
&gt;<i> +	struct dt_probe	*probe;</i>
&gt;<i> +</i>
&gt;<i> +	for (i = 0; i &lt; ARRAY_SIZE(dt_providers); i++) {</i>
&gt;<i> +		if (!dt_providers[i]-&gt;resolve_event)</i>
&gt;<i> +			continue;</i>
&gt;<i> +		probe = dt_providers[i]-&gt;resolve_event(name);</i>
&gt;<i> +		if (probe)</i>
&gt;<i> +			return probe;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	return NULL;</i>
&gt;<i> +}</i>
&gt;<i> diff --git a/tools/dtrace/dt_syscall.c b/tools/dtrace/dt_syscall.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..6695a4a1c701</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dt_syscall.c</i>
&gt;<i> @@ -0,0 +1,179 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * The syscall provider for DTrace.</i>
&gt;<i> + *</i>
&gt;<i> + * System call probes are exposed by the kernel as tracepoint events in the</i>
&gt;<i> + * &quot;syscalls&quot; group.  Entry probe names start with &quot;sys_enter_&quot; and exit probes</i>
&gt;<i> + * start with &quot;sys_exit_&quot;.</i>
&gt;<i> + *</i>
&gt;<i> + * Mapping from event name to DTrace probe name:</i>
&gt;<i> + *</i>
&gt;<i> + *	syscalls:sys_enter_&lt;name&gt;		syscall:vmlinux:&lt;name&gt;:entry</i>
&gt;<i> + *	syscalls:sys_exit_&lt;name&gt;		syscall:vmlinux:&lt;name&gt;:return</i>
&gt;<i> + *</i>
&gt;<i> + * Mapping from BPF section name to DTrace probe name:</i>
&gt;<i> + *</i>
&gt;<i> + *	tracepoint/syscalls/sys_enter_&lt;name&gt;	syscall:vmlinux:&lt;name&gt;:entry</i>
&gt;<i> + *	tracepoint/syscalls/sys_exit_&lt;name&gt;	syscall:vmlinux:&lt;name&gt;:return</i>
&gt;<i> + *</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;ctype.h&gt;</i>
&gt;<i> +#include &lt;fcntl.h&gt;</i>
&gt;<i> +#include &lt;stdio.h&gt;</i>
&gt;<i> +#include &lt;stdlib.h&gt;</i>
&gt;<i> +#include &lt;string.h&gt;</i>
&gt;<i> +#include &lt;unistd.h&gt;</i>
&gt;<i> +#include &lt;linux/bpf.h&gt;</i>
&gt;<i> +#include &lt;sys/stat.h&gt;</i>
&gt;<i> +#include &lt;sys/types.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace_impl.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +static const char	provname[] = &quot;syscall&quot;;</i>
&gt;<i> +static const char	modname[] = &quot;vmlinux&quot;;</i>
&gt;<i> +</i>
&gt;<i> +#define PROBE_LIST	TRACEFS &quot;available_events&quot;</i>
&gt;<i> +</i>
&gt;<i> +#define PROV_PREFIX	&quot;syscalls:&quot;</i>
&gt;<i> +#define ENTRY_PREFIX	&quot;sys_enter_&quot;</i>
&gt;<i> +#define EXIT_PREFIX	&quot;sys_exit_&quot;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Scan the PROBE_LIST file and add probes for any syscalls events.</i>
&gt;<i> + */</i>
&gt;<i> +static int syscall_populate(void)</i>
&gt;<i> +{</i>
&gt;<i> +	FILE			*f;</i>
&gt;<i> +	char			buf[256];</i>
&gt;<i> +</i>
&gt;<i> +	f = fopen(PROBE_LIST, &quot;r&quot;);</i>
&gt;<i> +	if (f == NULL)</i>
&gt;<i> +		return -1;</i>
&gt;<i> +</i>
&gt;<i> +	while (fgets(buf, sizeof(buf), f)) {</i>
&gt;<i> +		char	*p;</i>
&gt;<i> +</i>
&gt;<i> +		/* * Here buf is &quot;group:event&quot;.  */</i>
&gt;<i> +		p = strchr(buf, '\n');</i>
&gt;<i> +		if (p)</i>
&gt;<i> +			*p = '\0';</i>
&gt;<i> +		else {</i>
&gt;<i> +			/*</i>
&gt;<i> +			 * If we didn't see a newline, the line was too long.</i>
&gt;<i> +			 * Report it, and continue until the end of the line.</i>
&gt;<i> +			 */</i>
&gt;<i> +			fprintf(stderr, &quot;%s: Line too long: %s\n&quot;,</i>
&gt;<i> +				PROBE_LIST, buf);</i>
&gt;<i> +			do</i>
&gt;<i> +				fgets(buf, sizeof(buf), f);</i>
&gt;<i> +			while (strchr(buf, '\n') == NULL);</i>
&gt;<i> +			continue;</i>
&gt;<i> +		}</i>
&gt;<i> +</i>
&gt;<i> +		/* We need &quot;group:&quot; to match &quot;syscalls:&quot;. */</i>
&gt;<i> +		p = buf;</i>
&gt;<i> +		if (memcmp(p, PROV_PREFIX, sizeof(PROV_PREFIX) - 1) != 0)</i>
&gt;<i> +			continue;</i>
&gt;<i> +</i>
&gt;<i> +		p += sizeof(PROV_PREFIX) - 1;</i>
&gt;<i> +		/*</i>
&gt;<i> +		 * Now p will be just &quot;event&quot;, and we are only interested in</i>
&gt;<i> +		 * events that match &quot;sys_enter_*&quot; or &quot;sys_exit_*&quot;.</i>
&gt;<i> +		 */</i>
&gt;<i> +		if (!memcmp(p, ENTRY_PREFIX, sizeof(ENTRY_PREFIX) - 1)) {</i>
&gt;<i> +			p += sizeof(ENTRY_PREFIX) - 1;</i>
&gt;<i> +			dt_probe_new(&amp;dt_syscall, provname, modname, p,</i>
&gt;<i> +				     &quot;entry&quot;);</i>
&gt;<i> +		} else if (!memcmp(p, EXIT_PREFIX, sizeof(EXIT_PREFIX) - 1)) {</i>
&gt;<i> +			p += sizeof(EXIT_PREFIX) - 1;</i>
&gt;<i> +			dt_probe_new(&amp;dt_syscall, provname, modname, p,</i>
&gt;<i> +				     &quot;return&quot;);</i>
&gt;<i> +		}</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	fclose(f);</i>
&gt;<i> +</i>
&gt;<i> +	return 0;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +#define EVENT_PREFIX	&quot;tracepoint/syscalls/&quot;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Perform a probe lookup based on an event name (BPF ELF section name).</i>
&gt;<i> + */</i>
&gt;<i> +static struct dt_probe *systrace_resolve_event(const char *name)</i>
&gt;<i> +{</i>
&gt;<i> +	const char	*prbname;</i>
&gt;<i> +	struct dt_probe	tmpl;</i>
&gt;<i> +	struct dt_probe	*probe;</i>
&gt;<i> +</i>
&gt;<i> +	if (!name)</i>
&gt;<i> +		return NULL;</i>
&gt;<i> +</i>
&gt;<i> +	/* Exclude anything that is not a syscalls tracepoint */</i>
&gt;<i> +	if (strncmp(name, EVENT_PREFIX, sizeof(EVENT_PREFIX) - 1) != 0)</i>
&gt;<i> +		return NULL;</i>
&gt;<i> +	name += sizeof(EVENT_PREFIX) - 1;</i>
&gt;<i> +</i>
&gt;<i> +	if (strncmp(name, ENTRY_PREFIX, sizeof(ENTRY_PREFIX) - 1) == 0) {</i>
&gt;<i> +		name += sizeof(ENTRY_PREFIX) - 1;</i>
&gt;<i> +		prbname = &quot;entry&quot;;</i>
&gt;<i> +	} else if (strncmp(name, EXIT_PREFIX, sizeof(EXIT_PREFIX) - 1) == 0) {</i>
&gt;<i> +		name += sizeof(EXIT_PREFIX) - 1;</i>
&gt;<i> +		prbname = &quot;return&quot;;</i>
&gt;<i> +	} else</i>
&gt;<i> +		return NULL;</i>
&gt;<i> +</i>
&gt;<i> +	memset(&amp;tmpl, 0, sizeof(tmpl));</i>
&gt;<i> +	tmpl.prv_name = provname;</i>
&gt;<i> +	tmpl.mod_name = modname;</i>
&gt;<i> +	tmpl.fun_name = name;</i>
&gt;<i> +	tmpl.prb_name = prbname;</i>
&gt;<i> +</i>
&gt;<i> +	probe = dt_probe_by_name(&amp;tmpl);</i>
&gt;<i> +</i>
&gt;<i> +	return probe;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +#define SYSCALLSFS	EVENTSFS &quot;syscalls/&quot;</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Attach the given BPF program (identified by its file descriptor) to the</i>
&gt;<i> + * event identified by the given section name.</i>
&gt;<i> + */</i>
&gt;<i> +static int syscall_attach(const char *name, int bpf_fd)</i>
&gt;<i> +{</i>
&gt;<i> +	char    efn[256];</i>
&gt;<i> +	char    buf[256];</i>
&gt;<i> +	int	event_id, fd, rc;</i>
&gt;<i> +</i>
&gt;<i> +	name += sizeof(EVENT_PREFIX) - 1;</i>
&gt;<i> +	strcpy(efn, SYSCALLSFS);</i>
&gt;<i> +	strcat(efn, name);</i>
&gt;<i> +	strcat(efn, &quot;/id&quot;);</i>
&gt;<i> +</i>
&gt;<i> +	fd = open(efn, O_RDONLY);</i>
&gt;<i> +	if (fd &lt; 0) {</i>
&gt;<i> +		perror(efn);</i>
&gt;<i> +		return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +	rc = read(fd, buf, sizeof(buf));</i>
&gt;<i> +	if (rc &lt; 0 || rc &gt;= sizeof(buf)) {</i>
&gt;<i> +		perror(efn);</i>
&gt;<i> +		close(fd);</i>
&gt;<i> +		return -1;</i>
&gt;<i> +	}</i>
&gt;<i> +	close(fd);</i>
&gt;<i> +	buf[rc] = '\0';</i>
&gt;<i> +	event_id = atoi(buf);</i>
&gt;<i> +</i>
&gt;<i> +	return dt_bpf_attach(event_id, bpf_fd);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +struct dt_provider	dt_syscall = {</i>
&gt;<i> +	.name		= &quot;syscall&quot;,</i>
&gt;<i> +	.populate	= &amp;syscall_populate,</i>
&gt;<i> +	.resolve_event	= &amp;systrace_resolve_event,</i>
&gt;<i> +	.attach		= &amp;syscall_attach,</i>
&gt;<i> +};</i>
&gt;<i> diff --git a/tools/dtrace/dt_utils.c b/tools/dtrace/dt_utils.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..55d51bae1d97</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dt_utils.c</i>
&gt;<i> @@ -0,0 +1,132 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;sys/types.h&gt;</i>
&gt;<i> +#include &lt;sys/stat.h&gt;</i>
&gt;<i> +#include &lt;fcntl.h&gt;</i>
&gt;<i> +#include &lt;stdlib.h&gt;</i>
&gt;<i> +#include &lt;string.h&gt;</i>
&gt;<i> +#include &lt;unistd.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace_impl.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +#define BUF_SIZE	1024		/* max size for online cpu data */</i>
&gt;<i> +</i>
&gt;<i> +int	dt_numcpus;			/* number of online CPUs */</i>
&gt;<i> +int	dt_maxcpuid;			/* highest CPU id */</i>
&gt;<i> +int	*dt_cpuids;			/* list of CPU ids */</i>
&gt;<i> +</i>
&gt;<i> +/*</i>
&gt;<i> + * Populate the online CPU id information from sysfs data.  We only do this</i>
&gt;<i> + * once because we do not care about CPUs coming online after we started</i>
&gt;<i> + * tracing.  If a CPU goes offline during tracing, we do not care either</i>
&gt;<i> + * because that simply means that it won't be writing any new probe data into</i>
&gt;<i> + * its buffer.</i>
&gt;<i> + */</i>
&gt;<i> +void cpu_list_populate(void)</i>
&gt;<i> +{</i>
&gt;<i> +	char buf[BUF_SIZE];</i>
&gt;<i> +	int fd, cnt, start, end, i;</i>
&gt;<i> +	int *cpu;</i>
&gt;<i> +	char *p, *q;</i>
&gt;<i> +</i>
&gt;<i> +	fd = open(&quot;/sys/devices/system/cpu/online&quot;, O_RDONLY);</i>
&gt;<i> +	if (fd &lt; 0)</i>
&gt;<i> +		goto fail;</i>
&gt;<i> +	cnt = read(fd, buf, sizeof(buf));</i>
&gt;<i> +	close(fd);</i>
&gt;<i> +	if (cnt &lt;= 0)</i>
&gt;<i> +		goto fail;</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * The string should always end with a newline, but let's make sure.</i>
&gt;<i> +	 */</i>
&gt;<i> +	if (buf[cnt - 1] == '\n')</i>
&gt;<i> +		buf[--cnt] = 0;</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Count how many CPUs we have.</i>
&gt;<i> +	 */</i>
&gt;<i> +	dt_numcpus = 0;</i>
&gt;<i> +	p = buf;</i>
&gt;<i> +	do {</i>
&gt;<i> +		start = (int)strtol(p, &amp;q, 10);</i>
&gt;<i> +		switch (*q) {</i>
&gt;<i> +		case '-':		/* range */</i>
&gt;<i> +			p = q + 1;</i>
&gt;<i> +			end = (int)strtol(p, &amp;q, 10);</i>
&gt;<i> +			dt_numcpus += end - start + 1;</i>
&gt;<i> +			if (*q == 0) {	/* end of string */</i>
&gt;<i> +				p = q;</i>
&gt;<i> +				break;</i>
&gt;<i> +			}</i>
&gt;<i> +			if (*q != ',')</i>
&gt;<i> +				goto fail;</i>
&gt;<i> +			p = q + 1;</i>
&gt;<i> +			break;</i>
&gt;<i> +		case 0:			/* end of string */</i>
&gt;<i> +			dt_numcpus++;</i>
&gt;<i> +			p = q;</i>
&gt;<i> +			break;</i>
&gt;<i> +		case ',':	/* gap  */</i>
&gt;<i> +			dt_numcpus++;</i>
&gt;<i> +			p = q + 1;</i>
&gt;<i> +			break;</i>
&gt;<i> +		}</i>
&gt;<i> +	} while (*p != 0);</i>
&gt;<i> +</i>
&gt;<i> +	dt_cpuids = calloc(dt_numcpus,  sizeof(int));</i>
&gt;<i> +	cpu = dt_cpuids;</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * Fill in the CPU ids.</i>
&gt;<i> +	 */</i>
&gt;<i> +	p = buf;</i>
&gt;<i> +	do {</i>
&gt;<i> +		start = (int)strtol(p, &amp;q, 10);</i>
&gt;<i> +		switch (*q) {</i>
&gt;<i> +		case '-':		/* range */</i>
&gt;<i> +			p = q + 1;</i>
&gt;<i> +			end = (int)strtol(p, &amp;q, 10);</i>
&gt;<i> +			for (i = start; i &lt;= end; i++)</i>
&gt;<i> +				*cpu++ = i;</i>
&gt;<i> +			if (*q == 0) {	/* end of string */</i>
&gt;<i> +				p = q;</i>
&gt;<i> +				break;</i>
&gt;<i> +			}</i>
&gt;<i> +			if (*q != ',')</i>
&gt;<i> +				goto fail;</i>
&gt;<i> +			p = q + 1;</i>
&gt;<i> +			break;</i>
&gt;<i> +		case 0:			/* end of string */</i>
&gt;<i> +			*cpu = start;</i>
&gt;<i> +			p = q;</i>
&gt;<i> +			break;</i>
&gt;<i> +		case ',':	/* gap  */</i>
&gt;<i> +			*cpu++ = start;</i>
&gt;<i> +			p = q + 1;</i>
&gt;<i> +			break;</i>
&gt;<i> +		}</i>
&gt;<i> +	} while (*p != 0);</i>
&gt;<i> +</i>
&gt;<i> +	/* Record the highest CPU id of the set of online CPUs. */</i>
&gt;<i> +	dt_maxcpuid = *(cpu - 1);</i>
&gt;<i> +</i>
&gt;<i> +	return;</i>
&gt;<i> +fail:</i>
&gt;<i> +	if (dt_cpuids)</i>
&gt;<i> +		free(dt_cpuids);</i>
&gt;<i> +</i>
&gt;<i> +	dt_numcpus = 0;</i>
&gt;<i> +	dt_maxcpuid = 0;</i>
&gt;<i> +	dt_cpuids = NULL;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +void cpu_list_free(void)</i>
&gt;<i> +{</i>
&gt;<i> +	free(dt_cpuids);</i>
&gt;<i> +	dt_numcpus = 0;</i>
&gt;<i> +	dt_maxcpuid = 0;</i>
&gt;<i> +	dt_cpuids = NULL;</i>
&gt;<i> +}</i>
&gt;<i> diff --git a/tools/dtrace/dtrace.c b/tools/dtrace/dtrace.c</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..36ad526c1cd4</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dtrace.c</i>
&gt;<i> @@ -0,0 +1,249 @@</i>
&gt;<i> +// SPDX-License-Identifier: GPL-2.0</i>
&gt;<i> +/*</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#include &lt;errno.h&gt;</i>
&gt;<i> +#include &lt;libgen.h&gt;</i>
&gt;<i> +#include &lt;stdarg.h&gt;</i>
&gt;<i> +#include &lt;stdio.h&gt;</i>
&gt;<i> +#include &lt;stdlib.h&gt;</i>
&gt;<i> +#include &lt;string.h&gt;</i>
&gt;<i> +#include &lt;unistd.h&gt;</i>
&gt;<i> +#include &lt;linux/log2.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace_impl.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +#define DTRACE_BUFSIZE	32		/* default buffer size (in pages) */</i>
&gt;<i> +</i>
&gt;<i> +#define DMODE_VERS	0		/* display version information (-V) */</i>
&gt;<i> +#define DMODE_LIST	1		/* list probes (-l) */</i>
&gt;<i> +#define DMODE_EXEC	2		/* compile program and start tracing */</i>
&gt;<i> +</i>
&gt;<i> +#define E_SUCCESS	0</i>
&gt;<i> +#define E_ERROR		1</i>
&gt;<i> +#define E_USAGE		2</i>
&gt;<i> +</i>
&gt;<i> +#define NUM_PAGES(sz)	(((sz) + getpagesize() - 1) / getpagesize())</i>
&gt;<i> +</i>
&gt;<i> +static const char		*dtrace_options = &quot;+b:ls:V&quot;;</i>
&gt;<i> +</i>
&gt;<i> +static char			*g_pname;</i>
&gt;<i> +static int			g_mode = DMODE_EXEC;</i>
&gt;<i> +</i>
&gt;<i> +static int usage(void)</i>
&gt;<i> +{</i>
&gt;<i> +	fprintf(stderr, &quot;Usage: %s [-lV] [-b bufsz] -s script\n&quot;, g_pname);</i>
&gt;<i> +	fprintf(stderr,</i>
&gt;<i> +	&quot;\t-b  set trace buffer size\n&quot;</i>
&gt;<i> +	&quot;\t-l  list probes matching specified criteria\n&quot;</i>
&gt;<i> +	&quot;\t-s  enable or list probes for the specified BPF program\n&quot;</i>
&gt;<i> +	&quot;\t-V  report DTrace API version\n&quot;);</i>
&gt;<i> +</i>
&gt;<i> +	return E_USAGE;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +static u64 parse_size(const char *arg)</i>
&gt;<i> +{</i>
&gt;<i> +	long long	mul = 1;</i>
&gt;<i> +	long long	neg, val;</i>
&gt;<i> +	size_t		len;</i>
&gt;<i> +	char		*end;</i>
&gt;<i> +</i>
&gt;<i> +	if (!arg)</i>
&gt;<i> +		return -1;</i>
&gt;<i> +</i>
&gt;<i> +	len = strlen(arg);</i>
&gt;<i> +	if (!len)</i>
&gt;<i> +		return -1;</i>
&gt;<i> +</i>
&gt;<i> +	switch (arg[len - 1]) {</i>
&gt;<i> +	case 't':</i>
&gt;<i> +	case 'T':</i>
&gt;<i> +		mul *= 1024;</i>
&gt;<i> +		/* fall-through */</i>
&gt;<i> +	case 'g':</i>
&gt;<i> +	case 'G':</i>
&gt;<i> +		mul *= 1024;</i>
&gt;<i> +		/* fall-through */</i>
&gt;<i> +	case 'm':</i>
&gt;<i> +	case 'M':</i>
&gt;<i> +		mul *= 1024;</i>
&gt;<i> +		/* fall-through */</i>
&gt;<i> +	case 'k':</i>
&gt;<i> +	case 'K':</i>
&gt;<i> +		mul *= 1024;</i>
&gt;<i> +		/* fall-through */</i>
&gt;<i> +	default:</i>
&gt;<i> +		break;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	neg = strtoll(arg, NULL, 0);</i>
&gt;<i> +	errno = 0;</i>
&gt;<i> +	val = strtoull(arg, &amp;end, 0) * mul;</i>
&gt;<i> +</i>
&gt;<i> +	if ((mul &gt; 1 &amp;&amp; end != &amp;arg[len - 1]) || (mul == 1 &amp;&amp; *end != '\0') ||</i>
&gt;<i> +	    val &lt; 0 || neg &lt; 0 || errno != 0)</i>
&gt;<i> +		return -1;</i>
&gt;<i> +</i>
&gt;<i> +	return val;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +int main(int argc, char *argv[])</i>
&gt;<i> +{</i>
&gt;<i> +	int	i;</i>
&gt;<i> +	int	modec = 0;</i>
&gt;<i> +	int	bufsize = DTRACE_BUFSIZE;</i>
&gt;<i> +	int	epoll_fd;</i>
&gt;<i> +	int	cnt;</i>
&gt;<i> +	char	**prgv;</i>
&gt;<i> +	int	prgc;</i>
&gt;<i> +</i>
&gt;<i> +	g_pname = basename(argv[0]);</i>
&gt;<i> +</i>
&gt;<i> +	if (argc == 1)</i>
&gt;<i> +		return usage();</i>
&gt;<i> +</i>
&gt;<i> +	prgc = 0;</i>
&gt;<i> +	prgv = calloc(argc, sizeof(char *));</i>
&gt;<i> +	if (!prgv) {</i>
&gt;<i> +		fprintf(stderr, &quot;failed to allocate memory for arguments: %s\n&quot;,</i>
&gt;<i> +			strerror(errno));</i>
&gt;<i> +		return E_ERROR;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	argv[0] = g_pname;			/* argv[0] for getopt errors */</i>
&gt;<i> +</i>
&gt;<i> +	for (optind = 1; optind &lt; argc; optind++) {</i>
&gt;<i> +		int	opt;</i>
&gt;<i> +</i>
&gt;<i> +		while ((opt = getopt(argc, argv, dtrace_options)) != EOF) {</i>
&gt;<i> +			u64			val;</i>
&gt;<i> +</i>
&gt;<i> +			switch (opt) {</i>
&gt;<i> +			case 'b':</i>
&gt;<i> +				val = parse_size(optarg);</i>
&gt;<i> +				if (val &lt; 0) {</i>
&gt;<i> +					fprintf(stderr, &quot;invalid: -b %s\n&quot;,</i>
&gt;<i> +						optarg);</i>
&gt;<i> +					return E_ERROR;</i>
&gt;<i> +				}</i>
&gt;<i> +</i>
&gt;<i> +				/*</i>
&gt;<i> +				 * Bufsize needs to be a number of pages, and</i>
&gt;<i> +				 * must be a power of 2.  This is required by</i>
&gt;<i> +				 * the perf event buffer code.</i>
&gt;<i> +				 */</i>
&gt;<i> +				bufsize = roundup_pow_of_two(NUM_PAGES(val));</i>
&gt;<i> +				if ((u64)bufsize * getpagesize() &gt; val)</i>
&gt;<i> +					fprintf(stderr,</i>
&gt;<i> +						&quot;bufsize increased to %ld\n&quot;,</i>
&gt;<i> +						(u64)bufsize * getpagesize());</i>
&gt;<i> +</i>
&gt;<i> +				break;</i>
&gt;<i> +			case 'l':</i>
&gt;<i> +				g_mode = DMODE_LIST;</i>
&gt;<i> +				modec++;</i>
&gt;<i> +				break;</i>
&gt;<i> +			case 's':</i>
&gt;<i> +				prgv[prgc++] = optarg;</i>
&gt;<i> +				break;</i>
&gt;<i> +			case 'V':</i>
&gt;<i> +				g_mode = DMODE_VERS;</i>
&gt;<i> +				modec++;</i>
&gt;<i> +				break;</i>
&gt;<i> +			default:</i>
&gt;<i> +				if (strchr(dtrace_options, opt) == NULL)</i>
&gt;<i> +					return usage();</i>
&gt;<i> +			}</i>
&gt;<i> +		}</i>
&gt;<i> +</i>
&gt;<i> +		if (optind &lt; argc) {</i>
&gt;<i> +			fprintf(stderr, &quot;unknown option '%s'\n&quot;, argv[optind]);</i>
&gt;<i> +			return E_ERROR;</i>
&gt;<i> +		}</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	if (modec &gt; 1) {</i>
&gt;<i> +		fprintf(stderr,</i>
&gt;<i> +			&quot;only one of [-lV] can be specified at a time\n&quot;);</i>
&gt;<i> +		return E_USAGE;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * We handle requests for version information first because we do not</i>
&gt;<i> +	 * need probe information for it.</i>
&gt;<i> +	 */</i>
&gt;<i> +	if (g_mode == DMODE_VERS) {</i>
&gt;<i> +		printf(&quot;%s\n&quot;</i>
&gt;<i> +		       &quot;This is DTrace %s\n&quot;</i>
&gt;<i> +		       &quot;dtrace(1) version-control ID: %s\n&quot;,</i>
&gt;<i> +		       DT_VERS_STRING, DT_VERSION, DT_GIT_VERSION);</i>
&gt;<i> +</i>
&gt;<i> +		return E_SUCCESS;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/* Initialize probes. */</i>
&gt;<i> +	if (dt_probe_init() &lt; 0) {</i>
&gt;<i> +		fprintf(stderr, &quot;failed to initialize probes: %s\n&quot;,</i>
&gt;<i> +			strerror(errno));</i>
&gt;<i> +		return E_ERROR;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/*</i>
&gt;<i> +	 * We handle requests to list probes next.</i>
&gt;<i> +	 */</i>
&gt;<i> +	if (g_mode == DMODE_LIST) {</i>
&gt;<i> +		int	rc = 0;</i>
&gt;<i> +</i>
&gt;<i> +		printf(&quot;%5s %10s %17s %33s %s\n&quot;,</i>
&gt;<i> +		       &quot;ID&quot;, &quot;PROVIDER&quot;, &quot;MODULE&quot;, &quot;FUNCTION&quot;, &quot;NAME&quot;);</i>
&gt;<i> +		for (i = 0; i &lt; prgc; i++) {</i>
&gt;<i> +			rc = dt_bpf_list_probes(prgv[i]);</i>
&gt;<i> +			if (rc &lt; 0)</i>
&gt;<i> +				fprintf(stderr, &quot;failed to load %s: %s\n&quot;,</i>
&gt;<i> +					prgv[i], strerror(errno));</i>
&gt;<i> +		}</i>
&gt;<i> +</i>
&gt;<i> +		return rc ? E_ERROR : E_SUCCESS;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	if (!prgc) {</i>
&gt;<i> +		fprintf(stderr, &quot;missing BPF program(s)\n&quot;);</i>
&gt;<i> +		return E_ERROR;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/* Process the BPF program. */</i>
&gt;<i> +	for (i = 0; i &lt; prgc; i++) {</i>
&gt;<i> +		int	err;</i>
&gt;<i> +</i>
&gt;<i> +		err = dt_bpf_load_file(prgv[i]);</i>
&gt;<i> +		if (err) {</i>
&gt;<i> +			errno = -err;</i>
&gt;<i> +			fprintf(stderr, &quot;failed to load %s: %s\n&quot;,</i>
&gt;<i> +				prgv[i], strerror(errno));</i>
&gt;<i> +			return E_ERROR;</i>
&gt;<i> +		}</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/* Get the list of online CPUs. */</i>
&gt;<i> +	cpu_list_populate();</i>
&gt;<i> +</i>
&gt;<i> +	/* Initialize buffers. */</i>
&gt;<i> +	epoll_fd = dt_buffer_init(bufsize);</i>
&gt;<i> +	if (epoll_fd &lt; 0) {</i>
&gt;<i> +		errno = -epoll_fd;</i>
&gt;<i> +		fprintf(stderr, &quot;failed to allocate buffers: %s\n&quot;,</i>
&gt;<i> +			strerror(errno));</i>
&gt;<i> +		return E_ERROR;</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/* Process probe data. */</i>
&gt;<i> +	printf(&quot;%3s %6s\n&quot;, &quot;CPU&quot;, &quot;ID&quot;);</i>
&gt;<i> +	do {</i>
&gt;<i> +		cnt = dt_buffer_poll(epoll_fd, 100);</i>
&gt;<i> +	} while (cnt &gt;= 0);</i>
&gt;<i> +</i>
&gt;<i> +	dt_buffer_exit(epoll_fd);</i>
&gt;<i> +</i>
&gt;<i> +	return E_SUCCESS;</i>
&gt;<i> +}</i>
&gt;<i> diff --git a/tools/dtrace/dtrace.h b/tools/dtrace/dtrace.h</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..c79398432d17</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dtrace.h</i>
&gt;<i> @@ -0,0 +1,13 @@</i>
&gt;<i> +/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</i>
&gt;<i> +/*</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#ifndef _UAPI_LINUX_DTRACE_H</i>
&gt;<i> +#define _UAPI_LINUX_DTRACE_H</i>
&gt;<i> +</i>
&gt;<i> +struct dt_bpf_context {</i>
&gt;<i> +	u32		probe_id;</i>
&gt;<i> +	u64		argv[10];</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +#endif /* _UAPI_LINUX_DTRACE_H */</i>
&gt;<i> diff --git a/tools/dtrace/dtrace_impl.h b/tools/dtrace/dtrace_impl.h</i>
&gt;<i> new file mode 100644</i>
&gt;<i> index 000000000000..9aa51b4c4aee</i>
&gt;<i> --- /dev/null</i>
&gt;<i> +++ b/tools/dtrace/dtrace_impl.h</i>
&gt;<i> @@ -0,0 +1,101 @@</i>
&gt;<i> +/* SPDX-License-Identifier: GPL-2.0 */</i>
&gt;<i> +/*</i>
&gt;<i> + * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</i>
&gt;<i> + */</i>
&gt;<i> +#ifndef _DTRACE_H</i>
&gt;<i> +#define _DTRACE_H</i>
&gt;<i> +</i>
&gt;<i> +#include &lt;unistd.h&gt;</i>
&gt;<i> +#include &lt;bpf/libbpf.h&gt;</i>
&gt;<i> +#include &lt;linux/types.h&gt;</i>
&gt;<i> +#include &lt;linux/ptrace.h&gt;</i>
&gt;<i> +#include &lt;linux/perf_event.h&gt;</i>
&gt;<i> +#include &lt;sys/syscall.h&gt;</i>
&gt;<i> +</i>
&gt;<i> +#include &quot;dtrace.h&quot;</i>
&gt;<i> +</i>
&gt;<i> +#define DT_DEBUG</i>
&gt;<i> +</i>
&gt;<i> +#define DT_VERS_STRING	&quot;Oracle D 2.0.0&quot;</i>
&gt;<i> +</i>
&gt;<i> +#define TRACEFS		&quot;/sys/kernel/debug/tracing/&quot;</i>
&gt;<i> +#define EVENTSFS	TRACEFS &quot;events/&quot;</i>
&gt;<i> +</i>
&gt;<i> +extern int	dt_numcpus;</i>
&gt;<i> +extern int	dt_maxcpuid;</i>
&gt;<i> +extern int	*dt_cpuids;</i>
&gt;<i> +</i>
&gt;<i> +extern void cpu_list_populate(void);</i>
&gt;<i> +extern void cpu_list_free(void);</i>
&gt;<i> +</i>
&gt;<i> +struct dt_provider {</i>
&gt;<i> +	char		*name;</i>
&gt;<i> +	int		(*populate)(void);</i>
&gt;<i> +	struct dt_probe *(*resolve_event)(const char *name);</i>
&gt;<i> +	int		(*attach)(const char *name, int bpf_fd);</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +extern struct dt_provider	dt_fbt;</i>
&gt;<i> +extern struct dt_provider	dt_syscall;</i>
&gt;<i> +</i>
&gt;<i> +struct dt_hentry {</i>
&gt;<i> +	struct dt_probe		*next;</i>
&gt;<i> +	struct dt_probe		*prev;</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +struct dt_htab;</i>
&gt;<i> +</i>
&gt;<i> +typedef u32 (*dt_hval_fn)(const struct dt_probe *);</i>
&gt;<i> +typedef int (*dt_cmp_fn)(const struct dt_probe *, const struct dt_probe *);</i>
&gt;<i> +typedef struct dt_probe *(*dt_add_fn)(struct dt_probe *, struct dt_probe *);</i>
&gt;<i> +typedef struct dt_probe *(*dt_del_fn)(struct dt_probe *, struct dt_probe *);</i>
&gt;<i> +</i>
&gt;<i> +extern struct dt_htab *dt_htab_new(dt_hval_fn hval, dt_cmp_fn cmp,</i>
&gt;<i> +				   dt_add_fn add, dt_del_fn del);</i>
&gt;<i> +extern int dt_htab_add(struct dt_htab *htab, struct dt_probe *probe);</i>
&gt;<i> +extern struct dt_probe *dt_htab_lookup(const struct dt_htab *htab,</i>
&gt;<i> +				       const struct dt_probe *probe);</i>
&gt;<i> +extern int dt_htab_del(struct dt_htab *htab, struct dt_probe *probe);</i>
&gt;<i> +</i>
&gt;<i> +struct dt_probe {</i>
&gt;<i> +	u32				id;</i>
&gt;<i> +	int				event_fd;</i>
&gt;<i> +	const struct dt_provider	*prov;</i>
&gt;<i> +	const char			*prv_name;	/* provider name */</i>
&gt;<i> +	const char			*mod_name;	/* module name */</i>
&gt;<i> +	const char			*fun_name;	/* function name */</i>
&gt;<i> +	const char			*prb_name;	/* probe name */</i>
&gt;<i> +	struct dt_hentry		he_fqn;</i>
&gt;<i> +};</i>
&gt;<i> +</i>
&gt;<i> +typedef void (*dt_probe_fn)(const struct dt_probe *probe);</i>
&gt;<i> +</i>
&gt;<i> +extern int dt_probe_init(void);</i>
&gt;<i> +extern int dt_probe_new(const struct dt_provider *prov, const char *pname,</i>
&gt;<i> +			const char *mname, const char *fname, const char *name);</i>
&gt;<i> +extern struct dt_probe *dt_probe_by_name(const struct dt_probe *tmpl);</i>
&gt;<i> +extern struct dt_probe *dt_probe_resolve_event(const char *name);</i>
&gt;<i> +</i>
&gt;<i> +extern int dt_bpf_list_probes(const char *fn);</i>
&gt;<i> +extern int dt_bpf_load_file(const char *fn);</i>
&gt;<i> +extern int dt_bpf_map_update(int fd, const void *key, const void *val);</i>
&gt;<i> +extern int dt_bpf_attach(int event_id, int bpf_fd);</i>
&gt;<i> +</i>
&gt;<i> +extern int dt_bufmap_fd;</i>
&gt;<i> +</i>
&gt;<i> +extern int dt_buffer_init(int num_pages);</i>
&gt;<i> +extern int dt_buffer_poll(int epoll_fd, int timeout);</i>
&gt;<i> +extern void dt_buffer_exit(int epoll_fd);</i>
&gt;<i> +</i>
&gt;<i> +static inline int perf_event_open(struct perf_event_attr *attr, pid_t pid,</i>
&gt;<i> +				  int cpu, int group_fd, unsigned long flags)</i>
&gt;<i> +{</i>
&gt;<i> +	return syscall(__NR_perf_event_open, attr, pid, cpu, group_fd, flags);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +extern inline int bpf(enum bpf_cmd cmd, union bpf_attr *attr)</i>
&gt;<i> +{</i>
&gt;<i> +	return syscall(__NR_bpf, cmd, attr, sizeof(union bpf_attr));</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +#endif /* _DTRACE_H */</i>
&gt;<i> -- </i>
&gt;<i> 2.20.1</i>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="05190" href="msg05190.html">Re: [PATCH V2 1/1 (was 0/1 by accident)] tools/dtrace: initial implementation of DTrace</a></strong>
<ul><li><em>From:</em> Daniel Borkmann</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="05175" href="msg05175.html">[PATCH V2 0/1] tools/dtrace: initial implementation of DTrace</a></strong>
<ul><li><em>From:</em> Kris Van Hees</li></ul></li>
<li><strong><a name="05176" href="msg05176.html">[PATCH V2 0/1] tools/dtrace: initial implementation of DTrace</a></strong>
<ul><li><em>From:</em> Kris Van Hees</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg05183.html">Re: [PATCH bpf-next v8 0/2] bpf: Allow bpf_skb_event_output for more prog types</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg05185.html">[PATCH bpf-next v9 0/2] bpf: Allow bpf_skb_event_output for more prog types</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg05176.html">[PATCH V2 0/1] tools/dtrace: initial implementation of DTrace</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg05190.html">Re: [PATCH V2 1/1 (was 0/1 by accident)] tools/dtrace: initial implementation of DTrace</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#05184"><strong>Date</strong></a></li>
<li><a href="index.html#05184"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-samsung-soc/>[Linux&nbsp;Samsung&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-rockchip/>[Linux&nbsp;Rockchip&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-actions/>[Linux&nbsp;Actions&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-snps-arc/>[Linux&nbsp;for&nbsp;Synopsys&nbsp;ARC&nbsp;Processors]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-nfs/>[Linux&nbsp;NFS]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-nilfs/>[Linux&nbsp;NILFS]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-usb/>[Linux&nbsp;USB&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/vfl/>[Video&nbsp;for&nbsp;Linux]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info/>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kernel/>[Linux&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-scsi/>[Linux&nbsp;SCSI]</a>
</font>
</center>
<p>
<hr>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
