<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re:  [PATCH] crash: dis: introduce count in reverse and forward mode -->
<!--X-From-R13: Rnir Oaqrefba &#60;naqrefbaNerqung.pbz> -->
<!--X-Date: Tue, 18 Jun 2019 13:28:02 &#45;0700 -->
<!--X-Message-Id: 11799803.30190110.1560889633654.JavaMail.zimbra@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190618162753.29621&#45;1&#45;atomlin@redhat.com -->
<!--X-Reference: 177457179.30177028.1560884512252.JavaMail.zimbra@redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Re:  [PATCH] crash: dis: introduce count in reverse and forward mode &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  Re:  [PATCH] crash: dis: introduce count in reverse and forward mode</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re:  [PATCH] crash: dis: introduce count in reverse and forward mode</h1>
[<a href="msg07777.html">Date Prev</a>][<a href="msg07779.html">Date Next</a>][<a href="msg07777.html">Thread Prev</a>][<a href="msg07779.html">Thread Next</a>][<a href="maillist.html#07778">Date Index</a>][<a href="index.html#07778">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re:  [PATCH] crash: dis: introduce count in reverse and forward mode</li>
<li><em>From</em>: Dave Anderson &lt;anderson@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Tue, 18 Jun 2019 16:27:13 -0400 (EDT)</li>
<li><em>In-reply-to</em>: &lt;<a href="msg07777.html">177457179.30177028.1560884512252.JavaMail.zimbra@redhat.com</a>&gt;</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>
----- Original Message -----
&gt;<i> </i>
&gt;<i> ----- Original Message -----</i>
&gt;<i> &gt; The purpose of this patch is to add support for a count value in reverse</i>
&gt;<i> &gt; or forward mode, during disassembly:</i>
&gt;<i> &gt; </i>
&gt;<i> &gt; 	'dis [-r|-f] [symbol|address] [count]'</i>
&gt;<i> &gt; </i>
&gt;<i> &gt; For example:</i>
&gt;<i> &gt; </i>
&gt;<i> &gt;   crash&gt; dis -f list_del+0x16 4</i>
&gt;<i> &gt;   0xffffffff812b3346 &lt;list_del+22&gt;:       jne    0xffffffff812b3381</i>
&gt;<i> &gt;   &lt;list_del+81&gt;</i>
&gt;<i> &gt;   0xffffffff812b3348 &lt;list_del+24&gt;:       mov    (%rbx),%rax</i>
&gt;<i> &gt;   0xffffffff812b334b &lt;list_del+27&gt;:       mov    0x8(%rax),%r8</i>
&gt;<i> &gt;   0xffffffff812b334f &lt;list_del+31&gt;:       cmp    %r8,%rbx</i>
&gt;<i> &gt; </i>
&gt;<i> &gt;   crash&gt; dis -r list_del+0x16 4</i>
&gt;<i> &gt;   0xffffffff812b333c &lt;list_del+12&gt;:       mov    0x8(%rdi),%rax</i>
&gt;<i> &gt;   0xffffffff812b3340 &lt;list_del+16&gt;:       mov    (%rax),%r8</i>
&gt;<i> &gt;   0xffffffff812b3343 &lt;list_del+19&gt;:       cmp    %r8,%rdi</i>
&gt;<i> &gt;   0xffffffff812b3346 &lt;list_del+22&gt;:       jne    0xffffffff812b3381</i>
&gt;<i> &gt;   &lt;list_del+81&gt;</i>
&gt;<i> &gt; </i>
&gt;<i> &gt; To support this feature, I have essentially incorported GDB commit</i>
&gt;<i> &gt; bb556f1facb (&quot;Add negative repeat count to 'x' command&quot;), with some</i>
&gt;<i> &gt; additional changes to maintain default behaviour i.e. always display the</i>
&gt;<i> &gt; target instruction with the examine command.</i>
&gt;<i> </i>
&gt;<i> Hi Aaron,</i>
&gt;<i> </i>
&gt;<i> The concept looks good, but the printcmd.c part of the patch doesn't apply</i>
&gt;<i> cleanly:</i>
&gt;<i> </i>
&gt;<i> $ make warn</i>
&gt;<i> TARGET: PPC64</i>
&gt;<i>  CRASH: 7.2.6++</i>
&gt;<i>    GDB: 7.6</i>
&gt;<i> </i>
&gt;<i> ... [ cut ] ...</i>
&gt;<i> patching file gdb-7.6/gdb/printcmd.c</i>
&gt;<i> Hunk #2 FAILED at 800.</i>
&gt;<i> Hunk #5 FAILED at 966.</i>
&gt;<i> Hunk #6 succeeded at 2579 (offset 1 line).</i>
&gt;<i> 2 out of 6 hunks FAILED</i>
&gt;<i> ... [ cut ] ...</i>
&gt;<i> gcc -g -O2 -m64 -fPIC -mminimal-toc  -I. -I. -I./common -I./config</i>
&gt;<i> -DLOCALEDIR=&quot;\&quot;/usr/local/share/locale\&quot;&quot; -DCRASH_MERGE -DHAVE_CONFIG_H</i>
&gt;<i> -I./../include/opcode -I./../opcodes/.. -I./../readline/.. -I../bfd</i>
&gt;<i> -I./../bfd -I./../include -I../libdecnumber -I./../libdecnumber</i>
&gt;<i> -I./gnulib/import -Ibuild-gnulib/import   -DTUI=1  -Wall</i>
&gt;<i> -Wdeclaration-after-statement -Wpointer-arith -Wformat-nonliteral</i>
&gt;<i> -Wno-pointer-sign -Wno-unused -Wunused-value -Wunused-function -Wno-switch</i>
&gt;<i> -Wno-char-subscripts -Wmissing-prototypes -Wdeclaration-after-statement</i>
&gt;<i> -Wempty-body  `echo &quot; -Wall -Wdeclaration-after-statement -Wpointer-arith</i>
&gt;<i> -Wformat-nonliteral -Wno-pointer-sign -Wno-unused -Wunused-value</i>
&gt;<i> -Wunused-function -Wno-switch -Wno-char-subscripts -Wmissing-prototypes</i>
&gt;<i> -Wdeclaration-after-statement -Wempty-body &quot; | sed &quot;s/ -Wformat-nonliteral /</i>
&gt;<i> -Wno-format-nonliteral /g&quot;` \</i>
&gt;<i> 	-c -o printcmd.o -MT printcmd.o -MMD -MP -MF .deps/printcmd.Tpo ./printcmd.c</i>
&gt;<i> ./printcmd.c: In function &#x2018;do_examine&#x2019;:</i>
&gt;<i> ./printcmd.c:899:26: warning: implicit declaration of function</i>
&gt;<i> &#x2018;find_instruction_backward&#x2019;; did you mean &#x2018;generic_instruction_nullified&#x2019;?</i>
&gt;<i> [-Wimplicit-function-declaration]</i>
&gt;<i>            next_address = find_instruction_backward (gdbarch, addr, count,</i>
&gt;<i>                           ^~~~~~~~~~~~~~~~~~~~~~~~~</i>
&gt;<i>                           generic_instruction_nullified</i>
&gt;<i> ./printcmd.c:904:26: warning: implicit declaration of function</i>
&gt;<i> &#x2018;find_string_backward&#x2019; [-Wimplicit-function-declaration]</i>
&gt;<i>            next_address = find_string_backward (gdbarch, addr, count,</i>
&gt;<i>                           ^~~~~~~~~~~~~~~~~~~~</i>
&gt;<i> Making init.c</i>
&gt;<i> ... [ cut ] ...</i>
&gt;<i> gcc -g -O2 -m64 -fPIC -mminimal-toc     \</i>
&gt;<i> 	-o ../../crash ../../crashlib.a rs6000-tdep.o ppc-linux-tdep.o</i>
&gt;<i> 	ppc-sysv-tdep.o ppc64-tdep.o solib-svr4.o solib-spu.o spu-multiarch.o</i>
&gt;<i> 	glibc-tdep.o symfile-mem.o linux-tdep.o ravenscar-thread.o</i>
&gt;<i> 	ppc-ravenscar-thread.o ser-base.o ser-unix.o ser-pipe.o ser-tcp.o</i>
&gt;<i> 	inf-ptrace.o fork-child.o ppc-linux-nat.o proc-service.o linux-thread-db.o</i>
&gt;<i> 	linux-nat.o linux-osdata.o linux-fork.o linux-procfs.o linux-ptrace.o</i>
&gt;<i> 	remote.o dcache.o tracepoint.o ax-general.o ax-gdb.o remote-fileio.o</i>
&gt;<i> 	remote-notif.o  cli-dump.o cli-decode.o cli-script.o cli-cmds.o</i>
&gt;<i> 	cli-setshow.o cli-logging.o cli-interp.o cli-utils.o mi-out.o mi-console.o</i>
&gt;<i> 	mi-cmds.o mi-cmd-catch.o mi-cmd-env.o mi-cmd-var.o mi-cmd-break.o</i>
&gt;<i> 	mi-cmd-stack.o mi-cmd-file.o mi-cmd-disas.o mi-symbol-cmds.o</i>
&gt;<i> 	mi-cmd-target.o mi-cmd-info.o mi-interp.o mi-main.o mi-parse.o mi-getopt.o</i>
&gt;<i> 	tui-command.o tui-data.o tui-disasm.o tui-file.o tui-hooks.o tui-interp.o</i>
&gt;<i> 	tui-io.o tui-layout.o tui-out.o tui-regs.o tui-source.o tui-stack.o</i>
&gt;<i> 	tui-win.o tui-windata.o tui-wingeneral.o tui-winsource.o tui.o python.o</i>
&gt;<i> 	py-value.o py-prettyprint.o py-auto-load.o elfread.o stap-probe.o</i>
&gt;<i> 	posix-hdep.o c-exp.o cp-name-parser.o ada-exp.o jv-exp.o f-exp.o go-exp.o</i>
&gt;<i> 	m2-exp.o p-exp.o version.o annotate.o addrmap.o auto-load.o auxv.o agent.o</i>
&gt;<i> 	bfd-target.o blockframe.o breakpoint.o break-catch-sig.o findvar.o</i>
&gt;<i> 	regcache.o cleanups.o charset.o continuations.o corelow.o disasm.o</i>
&gt;<i> 	dummy-frame.o dfp.o source.o value.o eval.o valops.o valarith.o valprint.o</i>
&gt;<i> 	printcmd.o block.o symtab.o psymtab.o symfile.o symmisc.o linespec.o</i>
&gt;<i> 	dictionary.o infcall.o infcmd.o infrun.o expprint.o environ.o stack.o</i>
&gt;<i> 	thread.o exceptions.o filesystem.o inf-child.o interps.o minidebug.o main.o</i>
&gt;<i> 	macrotab.o macrocmd.o macroexp.o macroscope.o mi-common.o event-loop.o</i>
&gt;<i> 	event-top.o inf-loop.o completer.o gdbarch.o arch-utils.o gdbtypes.o</i>
&gt;<i> 	gdb_bfd.o gdb_obstack.o osabi.o copying.o memattr.o mem-break.o target.o</i>
&gt;<i> 	parse.o language.o buildsym.o findcmd.o std-regs.o signals.o exec.o</i>
&gt;<i> 	reverse.o bcache.o objfiles.o observer.o minsyms.o maint.o demangle.o</i>
&gt;<i> 	dbxread.o coffread.o coff-pe-read.o dwarf2read.o mipsread.o stabsread.o</i>
&gt;<i> 	corefile.o dwarf2expr.o dwarf2loc.o dwarf2-frame.o dwarf2-frame-tailcall.o</i>
&gt;<i> 	ada-lang.o c-lang.o d-lang.o f-lang.o objc-lang.o ada-tasks.o ada-varobj.o</i>
&gt;<i> 	ui-out.o cli-out.o varobj.o vec.o go-lang.o go-valprint.o go-typeprint.o</i>
&gt;<i> 	jv-lang.o jv-valprint.o jv-typeprint.o m2-lang.o opencl-lang.o p-lang.o</i>
&gt;<i> 	p-typeprint.o p-valprint.o sentinel-frame.o complaints.o typeprint.o</i>
&gt;<i> 	ada-typeprint.o c-typeprint.o f-typeprint.o m2-typeprint.o ada-valprint.o</i>
&gt;<i> 	c-valprint.o cp-valprint.o d-valprint.o f-valprint.o m2-valprint.o serial.o</i>
&gt;<i> 	mdebugread.o top.o utils.o ui-file.o user-regs.o frame.o frame-unwind.o</i>
&gt;<i> 	doublest.o frame-base.o inline-frame.o gnu-v2-abi.o gnu-v3-abi.o cp-abi.o</i>
&gt;<i> 	cp-support.o cp-namespace.o reggroups.o regset.o trad-frame.o tramp-frame.o</i>
&gt;<i> 	solib.o solib-target.o prologue-value.o memory-map.o memrange.o</i>
&gt;<i> 	xml-support.o xml-syscall.o xml-utils.o target-descriptions.o</i>
&gt;<i> 	target-memory.o xml-tdesc.o xml-builtin.o inferior.o osdata.o gdb_usleep.o</i>
&gt;<i> 	record.o record-full.o gcore.o gdb_vecs.o jit.o progspace.o skip.o probe.o</i>
&gt;<i> 	common-utils.o buffer.o ptid.o gdb-dlfcn.o common-agent.o format.o</i>
&gt;<i> 	registry.o btrace.o record-btrace.o inflow.o    init.o \</i>
&gt;<i> 	   ../readline/libreadline.a ../opcodes/libopcodes.a ../bfd/libbfd.a</i>
&gt;<i> 	   ../libiberty/libiberty.a ../libdecnumber/libdecnumber.a    -ldl</i>
&gt;<i> 	   -lncurses -lz -lm   ../libiberty/libiberty.a</i>
&gt;<i> 	   build-gnulib/import/libgnu.a -ldl</i>
&gt;<i> 	   -Wl,--dynamic-list=./proc-service.list  -lz -ldl -rdynamic</i>
&gt;<i> printcmd.o: In function `do_examine':</i>
&gt;<i> /root/crash.git/gdb-7.6/gdb/./printcmd.c:899: undefined reference to</i>
&gt;<i> `find_instruction_backward'</i>
&gt;<i> /root/crash.git/gdb-7.6/gdb/./printcmd.c:904: undefined reference to</i>
&gt;<i> `find_string_backward'</i>
&gt;<i> collect2: error: ld returned 1 exit status</i>
&gt;<i> make[5]: *** [Makefile:1195: gdb] Error 1</i>
&gt;<i> make[4]: *** [Makefile:8265: all-gdb] Error 2</i>
&gt;<i> make[3]: *** [Makefile:835: all] Error 2</i>
&gt;<i> make[2]: *** [Makefile:245: rebuild] Error 2</i>
&gt;<i> make[1]: *** [Makefile:233: gdb_merge] Error 2</i>
&gt;<i> make: *** [Makefile:314: warn] Error 2</i>
&gt;<i> $</i>
&gt;<i> </i>
&gt;<i> It will need some additions to help.c as well.</i>
&gt;<i> </i>
&gt;<i> Thanks,</i>
&gt;<i>   Dave</i>


This seems to have uncovered a problem with the gdb-7.6.patch scheme,
where if the top-level Makefile sees that it has been modified, it re-applies
it using -N and -r- here:

  patch -N -p0 -r- --fuzz=0 &lt; ${GDB}.patch

It's currently attempting to re-apply a previously-applied printcmd.c patch 
(i.e., not recognizing that the patch had been applied), and it is failing
that attempt, and so the build process continues on.  Theoretically
that should still work, but it's somehow affecting the application of your
patch.  I'm not exactly sure why?  If you build with &quot;make &gt; log 2&gt;&amp;1&quot;, you'll see
what I mean w/respect to the subsequent re-application of the updated gdb-7.6.patch.
Presumably it has something to do with patching the same area of a file more
than once.  

Dave


&gt;<i> </i>
&gt;<i> </i>
&gt;<i> &gt; </i>
&gt;<i> &gt; Signed-off-by: Aaron Tomlin &lt;atomlin@xxxxxxxxxx&gt;</i>
&gt;<i> &gt; ---</i>
&gt;<i> &gt;  gdb-7.6.patch | 331 ++++++++++++++++++++++++++++++++++++++++++++++++++</i>
&gt;<i> &gt;  kernel.c      |  33 ++---</i>
&gt;<i> &gt;  2 files changed, 349 insertions(+), 15 deletions(-)</i>
&gt;<i> &gt; </i>
&gt;<i> &gt; diff --git a/gdb-7.6.patch b/gdb-7.6.patch</i>
&gt;<i> &gt; index cd75dcf..96cdef4 100644</i>
&gt;<i> &gt; --- a/gdb-7.6.patch</i>
&gt;<i> &gt; +++ b/gdb-7.6.patch</i>
&gt;<i> &gt; @@ -2447,3 +2447,334 @@ diff -up gdb-7.6/opcodes/configure.orig</i>
&gt;<i> &gt; gdb-7.6/opcodes/configure</i>
&gt;<i> &gt;   #else</i>
&gt;<i> &gt;   # error &quot;!__i386__ &amp;&amp; !__x86_64__&quot;</i>
&gt;<i> &gt;   #endif</i>
&gt;<i> &gt; +--- gdb-7.6/gdb/printcmd.c.orig</i>
&gt;<i> &gt; ++++ gdb-7.6/gdb/printcmd.c</i>
&gt;<i> &gt; +@@ -201,8 +201,13 @@ decode_format (char **string_ptr, int oformat, int</i>
&gt;<i> &gt; osize)</i>
&gt;<i> &gt; +   val.count = 1;</i>
&gt;<i> &gt; +   val.raw = 0;</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; ++  if (*p == '-')</i>
&gt;<i> &gt; ++    {</i>
&gt;<i> &gt; ++      val.count = -1;</i>
&gt;<i> &gt; ++      p++;</i>
&gt;<i> &gt; ++    }</i>
&gt;<i> &gt; +   if (*p &gt;= '0' &amp;&amp; *p &lt;= '9')</i>
&gt;<i> &gt; +-    val.count = atoi (p);</i>
&gt;<i> &gt; ++    val.count *= atoi (p);</i>
&gt;<i> &gt; +   while (*p &gt;= '0' &amp;&amp; *p &lt;= '9')</i>
&gt;<i> &gt; +     p++;</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; +@@ -795,6 +800,232 @@ print_address_demangle (const struct</i>
&gt;<i> &gt; value_print_options *opts,</i>
&gt;<i> &gt; + }</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; ++/* Find the address of the instruction that is INST_COUNT instructions</i>
&gt;<i> &gt; before</i>
&gt;<i> &gt; ++   the instruction at ADDR.</i>
&gt;<i> &gt; ++   Since some architectures have variable-length instructions, we can't</i>
&gt;<i> &gt; just</i>
&gt;<i> &gt; ++   simply subtract INST_COUNT * INSN_LEN from ADDR.  Instead, we use line</i>
&gt;<i> &gt; ++   number information to locate the nearest known instruction boundary,</i>
&gt;<i> &gt; ++   and disassemble forward from there.  If we go out of the symbol range</i>
&gt;<i> &gt; ++   during disassembling, we return the lowest address we've got so far</i>
&gt;<i> &gt; and</i>
&gt;<i> &gt; ++   set the number of instructions read to INST_READ.  */</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++static CORE_ADDR</i>
&gt;<i> &gt; ++find_instruction_backward (struct gdbarch *gdbarch, CORE_ADDR addr,</i>
&gt;<i> &gt; ++                           int inst_count, int *inst_read)</i>
&gt;<i> &gt; ++{</i>
&gt;<i> &gt; ++  /* The vector PCS is used to store instruction addresses within</i>
&gt;<i> &gt; ++     a pc range.  */</i>
&gt;<i> &gt; ++  CORE_ADDR loop_start, loop_end, p, func_addr;</i>
&gt;<i> &gt; ++  VEC (CORE_ADDR) *pcs = NULL;</i>
&gt;<i> &gt; ++  struct symtab_and_line sal;</i>
&gt;<i> &gt; ++  struct cleanup *cleanup = make_cleanup (VEC_cleanup (CORE_ADDR), &amp;pcs);</i>
&gt;<i> &gt; ++  int actual_count = 0;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  *inst_read = 0;</i>
&gt;<i> &gt; ++  inst_count--;</i>
&gt;<i> &gt; ++  loop_start = loop_end = addr;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  find_pc_partial_function (addr, NULL, &amp;func_addr, NULL);</i>
&gt;<i> &gt; ++  for (p = func_addr; p != addr;)</i>
&gt;<i> &gt; ++    {</i>
&gt;<i> &gt; ++      p += gdb_insn_length (gdbarch, p);</i>
&gt;<i> &gt; ++      actual_count++;</i>
&gt;<i> &gt; ++    }</i>
&gt;<i> &gt; ++  if (inst_count &gt; actual_count)</i>
&gt;<i> &gt; ++     inst_count = actual_count;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  /* In each iteration of the outer loop, we get a pc range that ends</i>
&gt;<i> &gt; before</i>
&gt;<i> &gt; ++     LOOP_START, then we count and store every instruction address of the</i>
&gt;<i> &gt; range</i>
&gt;<i> &gt; ++     iterated in the loop.</i>
&gt;<i> &gt; ++     If the number of instructions counted reaches INST_COUNT, return the</i>
&gt;<i> &gt; ++     stored address that is located INST_COUNT instructions back from</i>
&gt;<i> &gt; ADDR.</i>
&gt;<i> &gt; ++     If INST_COUNT is not reached, we subtract the number of counted</i>
&gt;<i> &gt; ++     instructions from INST_COUNT, and go to the next iteration.  */</i>
&gt;<i> &gt; ++  do</i>
&gt;<i> &gt; ++    {</i>
&gt;<i> &gt; ++      VEC_truncate (CORE_ADDR, pcs, 0);</i>
&gt;<i> &gt; ++      sal = find_pc_sect_line (loop_start, NULL, 1);</i>
&gt;<i> &gt; ++      if (sal.line &lt;= 0)</i>
&gt;<i> &gt; ++        {</i>
&gt;<i> &gt; ++          /* We reach here when line info is not available.  In this</i>
&gt;<i> &gt; case,</i>
&gt;<i> &gt; ++             we print a message and just exit the loop.  The return value</i>
&gt;<i> &gt; ++             is calculated after the loop.  */</i>
&gt;<i> &gt; ++          printf_filtered (_(&quot;No line number information available &quot;</i>
&gt;<i> &gt; ++                             &quot;for address &quot;));</i>
&gt;<i> &gt; ++          wrap_here (&quot;  &quot;);</i>
&gt;<i> &gt; ++          print_address (gdbarch, loop_start - 1, gdb_stdout);</i>
&gt;<i> &gt; ++          printf_filtered (&quot;\n&quot;);</i>
&gt;<i> &gt; ++          break;</i>
&gt;<i> &gt; ++        }</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++      loop_end = loop_start;</i>
&gt;<i> &gt; ++      loop_start = sal.pc;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++      /* This loop pushes instruction addresses in the range from</i>
&gt;<i> &gt; ++         LOOP_START to LOOP_END.  */</i>
&gt;<i> &gt; ++      for (p = loop_start; p &lt; loop_end;)</i>
&gt;<i> &gt; ++        {</i>
&gt;<i> &gt; ++          VEC_safe_push (CORE_ADDR, pcs, p);</i>
&gt;<i> &gt; ++          p += gdb_insn_length (gdbarch, p);</i>
&gt;<i> &gt; ++        }</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++      inst_count -= VEC_length (CORE_ADDR, pcs);</i>
&gt;<i> &gt; ++      *inst_read += VEC_length (CORE_ADDR, pcs);</i>
&gt;<i> &gt; ++    }</i>
&gt;<i> &gt; ++  while (inst_count &gt; 0);</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  /* After the loop, the vector PCS has instruction addresses of the last</i>
&gt;<i> &gt; ++     source line we processed, and INST_COUNT has a negative value.</i>
&gt;<i> &gt; ++     We return the address at the index of -INST_COUNT in the vector for</i>
&gt;<i> &gt; ++     the reason below.</i>
&gt;<i> &gt; ++     Let's assume the following instruction addresses and run 'x/-4i</i>
&gt;<i> &gt; 0x400e'.</i>
&gt;<i> &gt; ++       Line X of File</i>
&gt;<i> &gt; ++          0x4000</i>
&gt;<i> &gt; ++          0x4001</i>
&gt;<i> &gt; ++          0x4005</i>
&gt;<i> &gt; ++       Line Y of File</i>
&gt;<i> &gt; ++          0x4009</i>
&gt;<i> &gt; ++          0x400c</i>
&gt;<i> &gt; ++       =&gt; 0x400e</i>
&gt;<i> &gt; ++          0x4011</i>
&gt;<i> &gt; ++     find_instruction_backward is called with INST_COUNT = 4 and expected</i>
&gt;<i> &gt; to</i>
&gt;<i> &gt; ++     return 0x4001.  When we reach here, INST_COUNT is set to -1 because</i>
&gt;<i> &gt; ++     it was subtracted by 2 (from Line Y) and 3 (from Line X).  The value</i>
&gt;<i> &gt; ++     4001 is located at the index 1 of the last iterated line (= Line X),</i>
&gt;<i> &gt; ++     which is simply calculated by -INST_COUNT.</i>
&gt;<i> &gt; ++     The case when the length of PCS is 0 means that we reached an area</i>
&gt;<i> &gt; for</i>
&gt;<i> &gt; ++     which line info is not available.  In such case, we return</i>
&gt;<i> &gt; LOOP_START,</i>
&gt;<i> &gt; ++     which was the lowest instruction address that had line info.  */</i>
&gt;<i> &gt; ++  p = VEC_length (CORE_ADDR, pcs) &gt; 0</i>
&gt;<i> &gt; ++    ? VEC_index (CORE_ADDR, pcs, -inst_count)</i>
&gt;<i> &gt; ++    : loop_start;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  /* INST_READ includes all instruction addresses in a pc range.  Need to</i>
&gt;<i> &gt; ++     exclude the beginning part up to the address we're returning.  That</i>
&gt;<i> &gt; ++     is, exclude {0x4000} in the example above.  */</i>
&gt;<i> &gt; ++  if (inst_count &lt; 0)</i>
&gt;<i> &gt; ++    *inst_read += inst_count;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  do_cleanups (cleanup);</i>
&gt;<i> &gt; ++  return p;</i>
&gt;<i> &gt; ++}</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++/* Backward read LEN bytes of target memory from address MEMADDR + LEN,</i>
&gt;<i> &gt; ++   placing the results in GDB's memory from MYADDR + LEN.  Returns</i>
&gt;<i> &gt; ++   a count of the bytes actually read.  */</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++static int</i>
&gt;<i> &gt; ++read_memory_backward (struct gdbarch *gdbarch,</i>
&gt;<i> &gt; ++                      CORE_ADDR memaddr, gdb_byte *myaddr, int len)</i>
&gt;<i> &gt; ++{</i>
&gt;<i> &gt; ++  int errcode;</i>
&gt;<i> &gt; ++  int nread;      /* Number of bytes actually read.  */</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  /* First try a complete read.  */</i>
&gt;<i> &gt; ++  errcode = target_read_memory (memaddr, myaddr, len);</i>
&gt;<i> &gt; ++  if (errcode == 0)</i>
&gt;<i> &gt; ++    {</i>
&gt;<i> &gt; ++      /* Got it all.  */</i>
&gt;<i> &gt; ++      nread = len;</i>
&gt;<i> &gt; ++    }</i>
&gt;<i> &gt; ++  else</i>
&gt;<i> &gt; ++    {</i>
&gt;<i> &gt; ++      /* Loop, reading one byte at a time until we get as much as we can.</i>
&gt;<i> &gt; */</i>
&gt;<i> &gt; ++      memaddr += len;</i>
&gt;<i> &gt; ++      myaddr += len;</i>
&gt;<i> &gt; ++      for (nread = 0; nread &lt; len; ++nread)</i>
&gt;<i> &gt; ++        {</i>
&gt;<i> &gt; ++          errcode = target_read_memory (--memaddr, --myaddr, 1);</i>
&gt;<i> &gt; ++          if (errcode != 0)</i>
&gt;<i> &gt; ++            {</i>
&gt;<i> &gt; ++              /* The read was unsuccessful, so exit the loop.  */</i>
&gt;<i> &gt; ++              printf_filtered (_(&quot;Cannot access memory at address %s\n&quot;),</i>
&gt;<i> &gt; ++                               paddress (gdbarch, memaddr));</i>
&gt;<i> &gt; ++              break;</i>
&gt;<i> &gt; ++            }</i>
&gt;<i> &gt; ++        }</i>
&gt;<i> &gt; ++    }</i>
&gt;<i> &gt; ++  return nread;</i>
&gt;<i> &gt; ++}</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++/* Returns true if X (which is LEN bytes wide) is the number zero.  */</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++static int</i>
&gt;<i> &gt; ++integer_is_zero (const gdb_byte *x, int len)</i>
&gt;<i> &gt; ++{</i>
&gt;<i> &gt; ++  int i = 0;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  while (i &lt; len &amp;&amp; x[i] == 0)</i>
&gt;<i> &gt; ++    ++i;</i>
&gt;<i> &gt; ++  return (i == len);</i>
&gt;<i> &gt; ++}</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++/* Find the start address of a string in which ADDR is included.</i>
&gt;<i> &gt; ++   Basically we search for '\0' and return the next address,</i>
&gt;<i> &gt; ++   but if OPTIONS-&gt;PRINT_MAX is smaller than the length of a string,</i>
&gt;<i> &gt; ++   we stop searching and return the address to print characters as many</i>
&gt;<i> &gt; as</i>
&gt;<i> &gt; ++   PRINT_MAX from the string.  */</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++static CORE_ADDR</i>
&gt;<i> &gt; ++find_string_backward (struct gdbarch *gdbarch,</i>
&gt;<i> &gt; ++                      CORE_ADDR addr, int count, int char_size,</i>
&gt;<i> &gt; ++                      const struct value_print_options *options,</i>
&gt;<i> &gt; ++                      int *strings_counted)</i>
&gt;<i> &gt; ++{</i>
&gt;<i> &gt; ++  const int chunk_size = 0x20;</i>
&gt;<i> &gt; ++  gdb_byte *buffer = NULL;</i>
&gt;<i> &gt; ++  struct cleanup *cleanup = NULL;</i>
&gt;<i> &gt; ++  int read_error = 0;</i>
&gt;<i> &gt; ++  int chars_read = 0;</i>
&gt;<i> &gt; ++  int chars_to_read = chunk_size;</i>
&gt;<i> &gt; ++  int chars_counted = 0;</i>
&gt;<i> &gt; ++  int count_original = count;</i>
&gt;<i> &gt; ++  CORE_ADDR string_start_addr = addr;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  gdb_assert (char_size == 1 || char_size == 2 || char_size == 4);</i>
&gt;<i> &gt; ++  buffer = (gdb_byte *) xmalloc (chars_to_read * char_size);</i>
&gt;<i> &gt; ++  cleanup = make_cleanup (xfree, buffer);</i>
&gt;<i> &gt; ++  while (count &gt; 0 &amp;&amp; read_error == 0)</i>
&gt;<i> &gt; ++    {</i>
&gt;<i> &gt; ++      int i;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++      addr -= chars_to_read * char_size;</i>
&gt;<i> &gt; ++      chars_read = read_memory_backward (gdbarch, addr, buffer,</i>
&gt;<i> &gt; ++                                         chars_to_read * char_size);</i>
&gt;<i> &gt; ++      chars_read /= char_size;</i>
&gt;<i> &gt; ++      read_error = (chars_read == chars_to_read) ? 0 : 1;</i>
&gt;<i> &gt; ++      /* Searching for '\0' from the end of buffer in backward direction.</i>
&gt;<i> &gt; */</i>
&gt;<i> &gt; ++      for (i = 0; i &lt; chars_read &amp;&amp; count &gt; 0 ; ++i, ++chars_counted)</i>
&gt;<i> &gt; ++        {</i>
&gt;<i> &gt; ++          int offset = (chars_to_read - i - 1) * char_size;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++          if (integer_is_zero (buffer + offset, char_size)</i>
&gt;<i> &gt; ++              || chars_counted == options-&gt;print_max)</i>
&gt;<i> &gt; ++            {</i>
&gt;<i> &gt; ++              /* Found '\0' or reached print_max.  As OFFSET is the</i>
&gt;<i> &gt; offset</i>
&gt;<i> &gt; to</i>
&gt;<i> &gt; ++                 '\0', we add CHAR_SIZE to return the start address of</i>
&gt;<i> &gt; ++                 a string.  */</i>
&gt;<i> &gt; ++              --count;</i>
&gt;<i> &gt; ++              string_start_addr = addr + offset + char_size;</i>
&gt;<i> &gt; ++              chars_counted = 0;</i>
&gt;<i> &gt; ++            }</i>
&gt;<i> &gt; ++        }</i>
&gt;<i> &gt; ++    }</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  /* Update STRINGS_COUNTED with the actual number of loaded strings.  */</i>
&gt;<i> &gt; ++  *strings_counted = count_original - count;</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  if (read_error != 0)</i>
&gt;<i> &gt; ++    {</i>
&gt;<i> &gt; ++      /* In error case, STRING_START_ADDR is pointing to the string that</i>
&gt;<i> &gt; ++         was last successfully loaded.  Rewind the partially loaded</i>
&gt;<i> &gt; string.</i>
&gt;<i> &gt; */</i>
&gt;<i> &gt; ++      string_start_addr -= chars_counted * char_size;</i>
&gt;<i> &gt; ++    }</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  do_cleanups (cleanup);</i>
&gt;<i> &gt; ++  return string_start_addr;</i>
&gt;<i> &gt; ++}</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; + /* Examine data at address ADDR in format FMT.</i>
&gt;<i> &gt; +    Fetch it from memory and print on gdb_stdout.  */</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; +@@ -808,12 +1039,16 @@ do_examine (struct format_data fmt, struct gdbarch</i>
&gt;<i> &gt; *gdbarch, CORE_ADDR addr)</i>
&gt;<i> &gt; +   int i;</i>
&gt;<i> &gt; +   int maxelts;</i>
&gt;<i> &gt; +   struct value_print_options opts;</i>
&gt;<i> &gt; ++  int need_to_update_next_address = 0;</i>
&gt;<i> &gt; ++  CORE_ADDR addr_rewound = 0;</i>
&gt;<i> &gt; ++  int is_backward;</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; +   format = fmt.format;</i>
&gt;<i> &gt; +   size = fmt.size;</i>
&gt;<i> &gt; +   count = fmt.count;</i>
&gt;<i> &gt; +   next_gdbarch = gdbarch;</i>
&gt;<i> &gt; +   next_address = addr;</i>
&gt;<i> &gt; ++  is_backward = count &lt; 0;</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; +   /* Instruction format implies fetch single bytes</i>
&gt;<i> &gt; +      regardless of the specified size.</i>
&gt;<i> &gt; +@@ -878,9 +1113,43 @@ do_examine (struct format_data fmt, struct gdbarch</i>
&gt;<i> &gt; *gdbarch, CORE_ADDR addr)</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; +   get_formatted_print_options (&amp;opts, format);</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; ++  if (is_backward)</i>
&gt;<i> &gt; ++    {</i>
&gt;<i> &gt; ++      /* This is the negative repeat count case.</i>
&gt;<i> &gt; ++         We rewind the address based on the given repeat count and</i>
&gt;<i> &gt; format,</i>
&gt;<i> &gt; ++         then examine memory from there in forward direction.  */</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++      count = -count;</i>
&gt;<i> &gt; ++      if (format == 'i')</i>
&gt;<i> &gt; ++        {</i>
&gt;<i> &gt; ++          next_address = find_instruction_backward (gdbarch, addr, count,</i>
&gt;<i> &gt; ++                                                    &amp;count);</i>
&gt;<i> &gt; ++        }</i>
&gt;<i> &gt; ++      else if (format == 's')</i>
&gt;<i> &gt; ++        {</i>
&gt;<i> &gt; ++          next_address = find_string_backward (gdbarch, addr, count,</i>
&gt;<i> &gt; ++                                               TYPE_LENGTH (val_type),</i>
&gt;<i> &gt; ++                                               &amp;opts, &amp;count);</i>
&gt;<i> &gt; ++        }</i>
&gt;<i> &gt; ++      else</i>
&gt;<i> &gt; ++        {</i>
&gt;<i> &gt; ++          next_address = addr - count * TYPE_LENGTH (val_type);</i>
&gt;<i> &gt; ++        }</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++      /* The following call to print_formatted updates next_address in</i>
&gt;<i> &gt; every</i>
&gt;<i> &gt; ++         iteration.  In backward case, we store the start address here</i>
&gt;<i> &gt; ++         and update next_address with it before exiting the function.  */</i>
&gt;<i> &gt; ++      addr_rewound = (format == 's'</i>
&gt;<i> &gt; ++                      ? next_address - TYPE_LENGTH (val_type)</i>
&gt;<i> &gt; ++                      : next_address);</i>
&gt;<i> &gt; ++      need_to_update_next_address = 1;</i>
&gt;<i> &gt; ++    }</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; +   /* Print as many objects as specified in COUNT, at most maxelts per</i>
&gt;<i> &gt; line,</i>
&gt;<i> &gt; +      with the address of the next one at the start of each line.  */</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; ++  if (is_backward)</i>
&gt;<i> &gt; ++    count++;</i>
&gt;<i> &gt; +   while (count &gt; 0)</i>
&gt;<i> &gt; +     {</i>
&gt;<i> &gt; +       QUIT;</i>
&gt;<i> &gt; +@@ -923,6 +1192,9 @@ do_examine (struct format_data fmt, struct gdbarch</i>
&gt;<i> &gt; *gdbarch, CORE_ADDR addr)</i>
&gt;<i> &gt; +       printf_filtered (&quot;\n&quot;);</i>
&gt;<i> &gt; +       gdb_flush (gdb_stdout);</i>
&gt;<i> &gt; +     }</i>
&gt;<i> &gt; ++</i>
&gt;<i> &gt; ++  if (need_to_update_next_address)</i>
&gt;<i> &gt; ++    next_address = addr_rewound;</i>
&gt;<i> &gt; + }</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt; + static void</i>
&gt;<i> &gt; +@@ -2535,7 +2807,8 @@ Format letters are o(octal), x(hex), d(decimal),</i>
&gt;<i> &gt; u(unsigned decimal),\n\</i>
&gt;<i> &gt; +   t(binary), f(float), a(address), i(instruction), c(char) and</i>
&gt;<i> &gt; s(string).\n\</i>
&gt;<i> &gt; + Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).\n\</i>
&gt;<i> &gt; + The specified number of objects of the specified size are printed\n\</i>
&gt;<i> &gt; +-according to the format.\n\n\</i>
&gt;<i> &gt; ++according to the format.  If a negative number is specified, memory is\n\</i>
&gt;<i> &gt; ++examined backward from the address.\n\n\</i>
&gt;<i> &gt; + Defaults for format and size letters are those previously used.\n\</i>
&gt;<i> &gt; + Default count is 1.  Default address is following last thing printed\n\</i>
&gt;<i> &gt; + with this command or \&quot;print\&quot;.&quot;));</i>
&gt;<i> &gt; diff --git a/kernel.c b/kernel.c</i>
&gt;<i> &gt; index 22909d2..f5960fc 100644</i>
&gt;<i> &gt; --- a/kernel.c</i>
&gt;<i> &gt; +++ b/kernel.c</i>
&gt;<i> &gt; @@ -1931,16 +1931,10 @@ cmd_dis(void)</i>
&gt;<i> &gt;                  }</i>
&gt;<i> &gt;  </i>
&gt;<i> &gt;                  if (args[++optind]) {</i>
&gt;<i> &gt; -			if (reverse || forward) {</i>
&gt;<i> &gt; -				error(INFO,</i>
&gt;<i> &gt; -			            &quot;count argument ignored with -%s option\n&quot;,</i>
&gt;<i> &gt; -				    	reverse ? &quot;r&quot; : &quot;f&quot;);</i>
&gt;<i> &gt; -			} else {</i>
&gt;<i> &gt; -                        	req-&gt;count = stol(args[optind],</i>
&gt;<i> &gt; +			req-&gt;count = stol(args[optind],</i>
&gt;<i> &gt;  					FAULT_ON_ERROR, NULL);</i>
&gt;<i> &gt; -				req-&gt;flags &amp;= ~GNU_FUNCTION_ONLY;</i>
&gt;<i> &gt; -				count_entered++;</i>
&gt;<i> &gt; -			}</i>
&gt;<i> &gt; +			req-&gt;flags &amp;= ~GNU_FUNCTION_ONLY;</i>
&gt;<i> &gt; +			count_entered++;</i>
&gt;<i> &gt;  		}</i>
&gt;<i> &gt;  </i>
&gt;<i> &gt;  		if (sources) {</i>
&gt;<i> &gt; @@ -1992,6 +1986,10 @@ cmd_dis(void)</i>
&gt;<i> &gt;  			}</i>
&gt;<i> &gt;  		}</i>
&gt;<i> &gt;  </i>
&gt;<i> &gt; +		if (reverse || forward)</i>
&gt;<i> &gt; +			if (count_entered &amp;&amp; req-&gt;count == 1)</i>
&gt;<i> &gt; +				reverse = forward = 0;</i>
&gt;<i> &gt; +</i>
&gt;<i> &gt;  		if (reverse || forward) {</i>
&gt;<i> &gt;  			target = req-&gt;addr;</i>
&gt;<i> &gt;  			if ((sp = value_search(target, NULL)) == NULL)</i>
&gt;<i> &gt; @@ -2006,14 +2004,19 @@ cmd_dis(void)</i>
&gt;<i> &gt;  		do_machdep_filter = machdep-&gt;dis_filter(req-&gt;addr, NULL, radix);</i>
&gt;<i> &gt;  		open_tmpfile();</i>
&gt;<i> &gt;  </i>
&gt;<i> &gt; -		if (reverse)</i>
&gt;<i> &gt; -			sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,</i>
&gt;<i> &gt; -				(target - req-&gt;addr) ? target - req-&gt;addr : 1,</i>
&gt;<i> &gt; -				req-&gt;addr);</i>
&gt;<i> &gt; -		else</i>
&gt;<i> &gt; +		if (reverse || forward) {</i>
&gt;<i> &gt; +			if (count_entered &amp;&amp; req-&gt;count)</i>
&gt;<i> &gt; +				sprintf(buf5, &quot;x/%s%ldi 0x%lx&quot;, reverse ? &quot;-&quot; : &quot;&quot;,</i>
&gt;<i> &gt; +					req-&gt;count, target);</i>
&gt;<i> &gt; +			else</i>
&gt;<i> &gt; +				sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,</i>
&gt;<i> &gt; +					forward ?  req-&gt;addr2 - req-&gt;addr :</i>
&gt;<i> &gt; +					(target - req-&gt;addr) ? target - req-&gt;addr : 1,</i>
&gt;<i> &gt; +					forward ? target : req-&gt;addr);</i>
&gt;<i> &gt; +		} else</i>
&gt;<i> &gt;  			sprintf(buf5, &quot;x/%ldi 0x%lx&quot;,</i>
&gt;<i> &gt;  				count_entered &amp;&amp; req-&gt;count ? req-&gt;count :</i>
&gt;<i> &gt; -				forward || req-&gt;flags &amp; GNU_FUNCTION_ONLY ?</i>
&gt;<i> &gt; +				req-&gt;flags &amp; GNU_FUNCTION_ONLY ?</i>
&gt;<i> &gt;  				req-&gt;addr2 - req-&gt;addr : 1,</i>
&gt;<i> &gt;  				req-&gt;addr);</i>
&gt;<i> &gt;  		gdb_pass_through(buf5, NULL, GNU_RETURN_ON_ERROR);</i>
&gt;<i> &gt; --</i>
&gt;<i> &gt; 2.20.1</i>
&gt;<i> &gt; </i>
&gt;<i> &gt; --</i>
&gt;<i> &gt; Crash-utility mailing list</i>
&gt;<i> &gt; Crash-utility@xxxxxxxxxx</i>
&gt;<i> &gt; <a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a></i>
&gt;<i> &gt; </i>
&gt;<i> </i>
&gt;<i> --</i>
&gt;<i> Crash-utility mailing list</i>
&gt;<i> Crash-utility@xxxxxxxxxx</i>
&gt;<i> <a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a></i>

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="07779" href="msg07779.html">Re:  [PATCH] crash: dis: introduce count in reverse and forward mode</a></strong>
<ul><li><em>From:</em> Aaron Tomlin</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="07776" href="msg07776.html">[PATCH] crash: dis: introduce count in reverse and	forward mode</a></strong>
<ul><li><em>From:</em> Aaron Tomlin</li></ul></li>
<li><strong><a name="07777" href="msg07777.html">Re:  [PATCH] crash: dis: introduce count in reverse and	forward mode</a></strong>
<ul><li><em>From:</em> Dave Anderson</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07777.html">Re:  [PATCH] crash: dis: introduce count in reverse and	forward mode</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07779.html">Re:  [PATCH] crash: dis: introduce count in reverse and forward mode</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07777.html">Re:  [PATCH] crash: dis: introduce count in reverse and	forward mode</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07779.html">Re:  [PATCH] crash: dis: introduce count in reverse and forward mode</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07778"><strong>Date</strong></a></li>
<li><a href="index.html#07778"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
