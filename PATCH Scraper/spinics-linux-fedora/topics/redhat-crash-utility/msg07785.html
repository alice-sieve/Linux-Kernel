<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re:  [PATCH] timers: add option to show expired	timers only -->
<!--X-From-R13: Rnir Oaqrefba &#60;naqrefbaNerqung.pbz> -->
<!--X-Date: Wed, 19 Jun 2019 12:39:42 &#45;0700 -->
<!--X-Message-Id: 352113869.30392849.1560973158331.JavaMail.zimbra@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190619131128.4234&#45;1&#45;oleksandr@redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Re:  [PATCH] timers: add option to show expired	timers only &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  Re:  [PATCH] timers: add option to show expired	timers only</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re:  [PATCH] timers: add option to show expired	timers only</h1>
[<a href="msg07784.html">Date Prev</a>][<a href="msg07786.html">Date Next</a>][<a href="msg07782.html">Thread Prev</a>][<a href="msg07788.html">Thread Next</a>][<a href="maillist.html#07785">Date Index</a>][<a href="index.html#07785">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re:  [PATCH] timers: add option to show expired	timers only</li>
<li><em>From</em>: Dave Anderson &lt;anderson@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Wed, 19 Jun 2019 15:39:18 -0400 (EDT)</li>
<li><em>Cc</em>: crash-utility@xxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg07782.html">20190619131128.4234-1-oleksandr@redhat.com</a>&gt;</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>

----- Original Message -----
&gt;<i> Implement `timer` command option (namely, `-e`) that allows filtering</i>
&gt;<i> out all the non-expired timers.</i>
&gt;<i> </i>
&gt;<i> This is useful to verify what CPU is blocked due to looping with</i>
&gt;<i> interrupts disabled or due to lack of resources to run the vCPU on a</i>
&gt;<i> hypervisor side.</i>

Hi Oleksandr,

This makes the output somewhat sparse, ugly, and hard to read, no?

I'm wondering if it would be more readable if you just recognize the 
expired entries, and maybe display something like &quot;[EXPIRED]&quot; at the
end of the expired entry's line?  It wouldn't even require the &quot;-e&quot;, 
but just have it do it all the time.

What do you think?

Dave

&gt;<i> </i>
&gt;<i> Signed-off-by: Oleksandr Natalenko &lt;oleksandr@xxxxxxxxxx&gt;</i>
&gt;<i> ---</i>
&gt;<i>  help.c   |   1 +</i>
&gt;<i>  kernel.c | 213 ++++++++++++++++++++++++++++++++-----------------------</i>
&gt;<i>  2 files changed, 125 insertions(+), 89 deletions(-)</i>
&gt;<i> </i>
&gt;<i> diff --git a/help.c b/help.c</i>
&gt;<i> index c0c750f..fa856d1 100644</i>
&gt;<i> --- a/help.c</i>
&gt;<i> +++ b/help.c</i>
&gt;<i> @@ -2886,6 +2886,7 @@ char *help_timer[] = {</i>
&gt;<i>  &quot;        chronological order.  In the case of the old-style hrtimers, the&quot;,</i>
&gt;<i>  &quot;        expiration time is a single value; in the new-style hrtimers, the&quot;,</i>
&gt;<i>  &quot;        expiration time is a range.&quot;,</i>
&gt;<i> +&quot;    -e  Display expired timers only.&quot;,</i>
&gt;<i>  &quot; -C cpu Restrict the output to one or more CPUs, where multiple cpu[s]</i>
&gt;<i>  can&quot;,</i>
&gt;<i>  &quot;        be specified, for example, as \&quot;1,3,5\&quot;, \&quot;1-3\&quot;, or</i>
&gt;<i>  \&quot;1,3,5-7,10\&quot;.&quot;,</i>
&gt;<i>  &quot;\nEXAMPLES&quot;,</i>
&gt;<i> diff --git a/kernel.c b/kernel.c</i>
&gt;<i> index 22909d2..afc66da 100644</i>
&gt;<i> --- a/kernel.c</i>
&gt;<i> +++ b/kernel.c</i>
&gt;<i> @@ -38,24 +38,24 @@ static void display_bh_1(void);</i>
&gt;<i>  static void display_bh_2(void);</i>
&gt;<i>  static void display_bh_3(void);</i>
&gt;<i>  static void display_bh_4(void);</i>
&gt;<i> -static void dump_hrtimer_data(const ulong *cpus);</i>
&gt;<i> -static void dump_hrtimer_clock_base(const void *, const int);</i>
&gt;<i> -static void dump_hrtimer_base(const void *, const int);</i>
&gt;<i> -static void dump_active_timers(const void *, ulonglong);</i>
&gt;<i> +static void dump_hrtimer_data(const ulong *, int);</i>
&gt;<i> +static void dump_hrtimer_clock_base(const void *, const int, int);</i>
&gt;<i> +static void dump_hrtimer_base(const void *, const int, int);</i>
&gt;<i> +static void dump_active_timers(const void *, ulonglong, int);</i>
&gt;<i>  static int get_expires_len(const int, const ulong *, const int);</i>
&gt;<i> -static void print_timer(const void *);</i>
&gt;<i> +static void print_timer(const void *, ulonglong, int);</i>
&gt;<i>  static ulonglong ktime_to_ns(const void *);</i>
&gt;<i> -static void dump_timer_data(const ulong *cpus);</i>
&gt;<i> -static void dump_timer_data_tvec_bases_v1(const ulong *cpus);</i>
&gt;<i> -static void dump_timer_data_tvec_bases_v2(const ulong *cpus);</i>
&gt;<i> -static void dump_timer_data_tvec_bases_v3(const ulong *cpus);</i>
&gt;<i> -static void dump_timer_data_timer_bases(const ulong *cpus);</i>
&gt;<i> +static void dump_timer_data(const ulong *, int);</i>
&gt;<i> +static void dump_timer_data_tvec_bases_v1(const ulong *, int);</i>
&gt;<i> +static void dump_timer_data_tvec_bases_v2(const ulong *, int);</i>
&gt;<i> +static void dump_timer_data_tvec_bases_v3(const ulong *, int);</i>
&gt;<i> +static void dump_timer_data_timer_bases(const ulong *, int);</i>
&gt;<i>  struct tv_range;</i>
&gt;<i>  static void init_tv_ranges(struct tv_range *, int, int, int);</i>
&gt;<i> -static int do_timer_list(ulong,int, ulong *, void *,ulong *,struct tv_range</i>
&gt;<i> *);</i>
&gt;<i> -static int do_timer_list_v3(ulong, int, ulong *, void *,ulong *);</i>
&gt;<i> +static int do_timer_list(ulong,int, ulong *, void *,ulong *,struct tv_range</i>
&gt;<i> *, ulong, int);</i>
&gt;<i> +static int do_timer_list_v3(ulong, int, ulong *, void *,ulong *, ulong,</i>
&gt;<i> int);</i>
&gt;<i>  struct timer_bases_data;</i>
&gt;<i> -static int do_timer_list_v4(struct timer_bases_data *);</i>
&gt;<i> +static int do_timer_list_v4(struct timer_bases_data *, ulong, int);</i>
&gt;<i>  static int compare_timer_data(const void *, const void *);</i>
&gt;<i>  static void panic_this_kernel(void);</i>
&gt;<i>  static void dump_waitq(ulong, char *);</i>
&gt;<i> @@ -7402,18 +7402,24 @@ cmd_timer(void)</i>
&gt;<i>  {</i>
&gt;<i>          int c;</i>
&gt;<i>  	int rflag;</i>
&gt;<i> +	int eflag;</i>
&gt;<i>  	char *cpuspec;</i>
&gt;<i>  	ulong *cpus = NULL;</i>
&gt;<i>  </i>
&gt;<i>  	rflag = 0;</i>
&gt;<i> +	eflag = 0;</i>
&gt;<i>  </i>
&gt;<i> -        while ((c = getopt(argcnt, args, &quot;rC:&quot;)) != EOF) {</i>
&gt;<i> +        while ((c = getopt(argcnt, args, &quot;reC:&quot;)) != EOF) {</i>
&gt;<i>                  switch(c)</i>
&gt;<i>                  {</i>
&gt;<i>  		case 'r':</i>
&gt;<i>  			rflag = 1;</i>
&gt;<i>  			break;</i>
&gt;<i>  </i>
&gt;<i> +		case 'e':</i>
&gt;<i> +			eflag = 1;</i>
&gt;<i> +			break;</i>
&gt;<i> +</i>
&gt;<i>  		case 'C':</i>
&gt;<i>  			cpuspec = optarg;</i>
&gt;<i>  			cpus = get_cpumask_buf();</i>
&gt;<i> @@ -7430,16 +7436,16 @@ cmd_timer(void)</i>
&gt;<i>                  cmd_usage(pc-&gt;curcmd, SYNOPSIS);</i>
&gt;<i>  </i>
&gt;<i>  	if (rflag)</i>
&gt;<i> -		dump_hrtimer_data(cpus);</i>
&gt;<i> +		dump_hrtimer_data(cpus, eflag);</i>
&gt;<i>  	else</i>
&gt;<i> -		dump_timer_data(cpus);</i>
&gt;<i> +		dump_timer_data(cpus, eflag);</i>
&gt;<i>  </i>
&gt;<i>  	if (cpus)</i>
&gt;<i>  		FREEBUF(cpus);</i>
&gt;<i>  }</i>
&gt;<i>  </i>
&gt;<i>  static void</i>
&gt;<i> -dump_hrtimer_data(const ulong *cpus)</i>
&gt;<i> +dump_hrtimer_data(const ulong *cpus, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, j, k = 0;</i>
&gt;<i>  	int hrtimer_max_clock_bases, max_hrtimer_bases;</i>
&gt;<i> @@ -7487,7 +7493,7 @@ dump_hrtimer_data(const ulong *cpus)</i>
&gt;<i>  					fprintf(fp, &quot;\n&quot;);</i>
&gt;<i>  				dump_hrtimer_clock_base(</i>
&gt;<i>  					(void *)(hrtimer_bases-&gt;value) +</i>
&gt;<i> -					kt-&gt;__per_cpu_offset[i], j);</i>
&gt;<i> +					kt-&gt;__per_cpu_offset[i], j, eflag);</i>
&gt;<i>  			}</i>
&gt;<i>  		} else {</i>
&gt;<i>  			fprintf(fp, &quot;\n&quot;);</i>
&gt;<i> @@ -7496,7 +7502,7 @@ dump_hrtimer_data(const ulong *cpus)</i>
&gt;<i>  					fprintf(fp, &quot;\n&quot;);</i>
&gt;<i>  				dump_hrtimer_base(</i>
&gt;<i>  					(void *)(hrtimer_bases-&gt;value) +</i>
&gt;<i> -					kt-&gt;__per_cpu_offset[i], j);</i>
&gt;<i> +					kt-&gt;__per_cpu_offset[i], j, eflag);</i>
&gt;<i>  			}</i>
&gt;<i>  		}</i>
&gt;<i>  	}</i>
&gt;<i> @@ -7506,7 +7512,7 @@ static int expires_len = -1;</i>
&gt;<i>  static int softexpires_len = -1;</i>
&gt;<i>  </i>
&gt;<i>  static void</i>
&gt;<i> -dump_hrtimer_clock_base(const void *hrtimer_bases, const int num)</i>
&gt;<i> +dump_hrtimer_clock_base(const void *hrtimer_bases, const int num, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	void *base;</i>
&gt;<i>  	ulonglong current_time, now;</i>
&gt;<i> @@ -7530,11 +7536,11 @@ dump_hrtimer_clock_base(const void *hrtimer_bases,</i>
&gt;<i> const int num)</i>
&gt;<i>  		offset = ktime_to_ns(base + OFFSET(hrtimer_clock_base_offset));</i>
&gt;<i>  	now = current_time * (1000000000LL / machdep-&gt;hz) + offset;</i>
&gt;<i>  </i>
&gt;<i> -	dump_active_timers(base, now);</i>
&gt;<i> +	dump_active_timers(base, now, eflag);</i>
&gt;<i>  }</i>
&gt;<i>  </i>
&gt;<i>  static void</i>
&gt;<i> -dump_hrtimer_base(const void *hrtimer_bases, const int num)</i>
&gt;<i> +dump_hrtimer_base(const void *hrtimer_bases, const int num, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	void *base;</i>
&gt;<i>  	ulonglong current_time, now;</i>
&gt;<i> @@ -7552,11 +7558,11 @@ dump_hrtimer_base(const void *hrtimer_bases, const</i>
&gt;<i> int num)</i>
&gt;<i>  	get_uptime(NULL, &amp;current_time);</i>
&gt;<i>  	now = current_time * (1000000000LL / machdep-&gt;hz);</i>
&gt;<i>  </i>
&gt;<i> -	dump_active_timers(base, now);</i>
&gt;<i> +	dump_active_timers(base, now, eflag);</i>
&gt;<i>  }</i>
&gt;<i>  </i>
&gt;<i>  static void</i>
&gt;<i> -dump_active_timers(const void *base, ulonglong now)</i>
&gt;<i> +dump_active_timers(const void *base, ulonglong now, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int next, i, t;</i>
&gt;<i>  	struct rb_node *curr;</i>
&gt;<i> @@ -7664,7 +7670,7 @@ next_one:</i>
&gt;<i>  		else</i>
&gt;<i>  			timer = (void *)(timer_list[t] - OFFSET(hrtimer_node));</i>
&gt;<i>  </i>
&gt;<i> -		print_timer(timer);</i>
&gt;<i> +		print_timer(timer, now, eflag);</i>
&gt;<i>  	}</i>
&gt;<i>  }</i>
&gt;<i>  </i>
&gt;<i> @@ -7715,7 +7721,7 @@ get_expires_len(const int timer_cnt, const ulong</i>
&gt;<i> *timer_list, const int getsoft)</i>
&gt;<i>   * print hrtimer and its related information</i>
&gt;<i>   */</i>
&gt;<i>  static void</i>
&gt;<i> -print_timer(const void *timer)</i>
&gt;<i> +print_timer(const void *timer, ulonglong now, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	ulonglong softexpires, expires;</i>
&gt;<i>  	</i>
&gt;<i> @@ -7724,6 +7730,15 @@ print_timer(const void *timer)</i>
&gt;<i>  	char buf2[BUFSIZE];</i>
&gt;<i>  	char buf3[BUFSIZE];</i>
&gt;<i>  </i>
&gt;<i> +	if (VALID_MEMBER(hrtimer_expires))</i>
&gt;<i> +		expires = ktime_to_ns(timer + OFFSET(hrtimer_expires));</i>
&gt;<i> +	else</i>
&gt;<i> +		expires = ktime_to_ns(timer + OFFSET(hrtimer_node) +</i>
&gt;<i> +			OFFSET(timerqueue_node_expires));</i>
&gt;<i> +</i>
&gt;<i> +	if (eflag &amp;&amp; expires &gt;= now)</i>
&gt;<i> +		return;</i>
&gt;<i> +</i>
&gt;<i>  	/* align information */</i>
&gt;<i>  	fprintf(fp, &quot;  &quot;);</i>
&gt;<i>  </i>
&gt;<i> @@ -7732,11 +7747,6 @@ print_timer(const void *timer)</i>
&gt;<i>  		return;</i>
&gt;<i>  	}</i>
&gt;<i>  </i>
&gt;<i> -	if (VALID_MEMBER(hrtimer_expires))</i>
&gt;<i> -		expires = ktime_to_ns(timer + OFFSET(hrtimer_expires));</i>
&gt;<i> -	else</i>
&gt;<i> -		expires = ktime_to_ns(timer + OFFSET(hrtimer_node) +</i>
&gt;<i> -			OFFSET(timerqueue_node_expires));</i>
&gt;<i>  </i>
&gt;<i>  	if (VALID_MEMBER(hrtimer_softexpires)) {</i>
&gt;<i>  		softexpires = ktime_to_ns(timer + OFFSET(hrtimer_softexpires));</i>
&gt;<i> @@ -7818,7 +7828,7 @@ struct tv_range {</i>
&gt;<i>  #define TVN (6)</i>
&gt;<i>  </i>
&gt;<i>  static void</i>
&gt;<i> -dump_timer_data(const ulong *cpus)</i>
&gt;<i> +dump_timer_data(const ulong *cpus, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i;</i>
&gt;<i>  	ulong timer_active;</i>
&gt;<i> @@ -7839,16 +7849,16 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>          struct tv_range tv[TVN];</i>
&gt;<i>  </i>
&gt;<i>  	if (kt-&gt;flags2 &amp; TIMER_BASES) {</i>
&gt;<i> -		dump_timer_data_timer_bases(cpus);</i>
&gt;<i> +		dump_timer_data_timer_bases(cpus, eflag);</i>
&gt;<i>  		return;</i>
&gt;<i>  	} else if (kt-&gt;flags2 &amp; TVEC_BASES_V3) {</i>
&gt;<i> -		dump_timer_data_tvec_bases_v3(cpus);</i>
&gt;<i> +		dump_timer_data_tvec_bases_v3(cpus, eflag);</i>
&gt;<i>  		return;</i>
&gt;<i>  	} else if (kt-&gt;flags &amp; TVEC_BASES_V2) {</i>
&gt;<i> -		dump_timer_data_tvec_bases_v2(cpus);</i>
&gt;<i> +		dump_timer_data_tvec_bases_v2(cpus, eflag);</i>
&gt;<i>  		return;</i>
&gt;<i>  	} else if (kt-&gt;flags &amp; TVEC_BASES_V1) {</i>
&gt;<i> -		dump_timer_data_tvec_bases_v1(cpus);</i>
&gt;<i> +		dump_timer_data_tvec_bases_v1(cpus, eflag);</i>
&gt;<i>  		return;</i>
&gt;<i>  	}</i>
&gt;<i>  		</i>
&gt;<i> @@ -7888,23 +7898,24 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  </i>
&gt;<i>  	init_tv_ranges(tv, vec_root_size, vec_size, 0);</i>
&gt;<i>  </i>
&gt;<i> +	get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i> +	get_symbol_data(&quot;timer_jiffies&quot;, sizeof(ulong), &amp;timer_jiffies);</i>
&gt;<i> +</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv1&quot;) +</i>
&gt;<i>          OFFSET(timer_vec_root_vec),</i>
&gt;<i> -		vec_root_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_root_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv2&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv3&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv4&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv4&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>  </i>
&gt;<i>  	td = (struct timer_data *)</i>
&gt;<i>  		GETBUF((count*2) * sizeof(struct timer_data));</i>
&gt;<i>  	tdx = 0;</i>
&gt;<i>  </i>
&gt;<i> -	get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i> -	get_symbol_data(&quot;timer_jiffies&quot;, sizeof(ulong), &amp;timer_jiffies);</i>
&gt;<i>  	if (old_timers_exist)</i>
&gt;<i>  		get_symbol_data(&quot;timer_active&quot;, sizeof(ulong), &amp;timer_active);</i>
&gt;<i>  </i>
&gt;<i> @@ -7916,6 +7927,8 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  </i>
&gt;<i>                  if (!(mask &amp; timer_active))</i>
&gt;<i>                          continue;</i>
&gt;<i> +		if (eflag &amp;&amp; tp-&gt;expires &gt;= jiffies)</i>
&gt;<i> +			continue;</i>
&gt;<i>  </i>
&gt;<i>  		td[tdx].address = i;</i>
&gt;<i>  		td[tdx].expires = tp-&gt;expires;</i>
&gt;<i> @@ -7926,15 +7939,15 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>          }</i>
&gt;<i>  </i>
&gt;<i>  	do_timer_list(symbol_value(&quot;tv1&quot;) + OFFSET(timer_vec_root_vec),</i>
&gt;<i> -		vec_root_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_root_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>  	do_timer_list(symbol_value(&quot;tv2&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>  	do_timer_list(symbol_value(&quot;tv3&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>  	do_timer_list(symbol_value(&quot;tv4&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>  	tdx = do_timer_list(symbol_value(&quot;tv5&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>  </i>
&gt;<i>          qsort(td, tdx, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> @@ -7951,6 +7964,9 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  		mkstring(buf, flen, CENTER|LJUST, &quot;EXPIRES&quot;));</i>
&gt;<i>  </i>
&gt;<i>          for (i = 0; i &lt; tdx; i++) {</i>
&gt;<i> +		if (eflag &amp;&amp; td[i].expires &gt;= jiffies)</i>
&gt;<i> +			continue;</i>
&gt;<i> +</i>
&gt;<i>          	fprintf(fp, &quot;%s&quot;,</i>
&gt;<i>  		    mkstring(buf, flen, RJUST|LONG_DEC, MKSTR(td[i].expires)));</i>
&gt;<i>  </i>
&gt;<i> @@ -7990,7 +8006,7 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>   */</i>
&gt;<i>  </i>
&gt;<i>  static void</i>
&gt;<i> -dump_timer_data_tvec_bases_v1(const ulong *cpus)</i>
&gt;<i> +dump_timer_data_tvec_bases_v1(const ulong *cpus, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, cpu, tdx, flen;</i>
&gt;<i>          struct timer_data *td;</i>
&gt;<i> @@ -8026,34 +8042,35 @@ next_cpu:</i>
&gt;<i>  </i>
&gt;<i>          init_tv_ranges(tv, vec_root_size, vec_size, cpu);</i>
&gt;<i>  </i>
&gt;<i> +	get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i> +</i>
&gt;<i>          count += do_timer_list(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -                vec_root_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_root_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>  </i>
&gt;<i>  	if (count)</i>
&gt;<i>          	td = (struct timer_data *)</i>
&gt;<i>                  	GETBUF((count*2) * sizeof(struct timer_data));</i>
&gt;<i>          tdx = 0;</i>
&gt;<i>  	highest = 0;</i>
&gt;<i> -        get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i>  </i>
&gt;<i>          do_timer_list(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -                vec_root_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_root_size, vec, (void *)td, &amp;highest, tv, jiffies,</i>
&gt;<i> eflag);</i>
&gt;<i>          do_timer_list(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>          do_timer_list(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>          do_timer_list(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>          tdx = do_timer_list(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>  </i>
&gt;<i>          qsort(td, tdx, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> @@ -8110,7 +8127,7 @@ next_cpu:</i>
&gt;<i>   */</i>
&gt;<i>  </i>
&gt;<i>  static void</i>
&gt;<i> -dump_timer_data_tvec_bases_v2(const ulong *cpus)</i>
&gt;<i> +dump_timer_data_tvec_bases_v2(const ulong *cpus, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, cpu, tdx, flen;</i>
&gt;<i>          struct timer_data *td;</i>
&gt;<i> @@ -8168,34 +8185,35 @@ next_cpu:</i>
&gt;<i>  </i>
&gt;<i>          init_tv_ranges(tv, vec_root_size, vec_size, cpu);</i>
&gt;<i>  </i>
&gt;<i> +	get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i> +</i>
&gt;<i>          count += do_timer_list(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -                vec_root_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_root_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>          count += do_timer_list(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, tv, jiffies, eflag);</i>
&gt;<i>  </i>
&gt;<i>  	if (count)</i>
&gt;<i>          	td = (struct timer_data *)</i>
&gt;<i>                  	GETBUF((count*2) * sizeof(struct timer_data));</i>
&gt;<i>          tdx = 0;</i>
&gt;<i>  	highest = 0;</i>
&gt;<i> -        get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i>  </i>
&gt;<i>          do_timer_list(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -                vec_root_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_root_size, vec, (void *)td, &amp;highest, tv, jiffies,</i>
&gt;<i> eflag);</i>
&gt;<i>          do_timer_list(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>          do_timer_list(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>          do_timer_list(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>          tdx = do_timer_list(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, tv, jiffies, eflag);</i>
&gt;<i>  </i>
&gt;<i>          qsort(td, tdx, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> @@ -8261,7 +8279,7 @@ next_cpu:</i>
&gt;<i>   *  Linux 4.2 timers use new tvec_root, tvec and timer_list structures</i>
&gt;<i>   */</i>
&gt;<i>  static void</i>
&gt;<i> -dump_timer_data_tvec_bases_v3(const ulong *cpus)</i>
&gt;<i> +dump_timer_data_tvec_bases_v3(const ulong *cpus, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, cpu, tdx, flen;</i>
&gt;<i>  	struct timer_data *td;</i>
&gt;<i> @@ -8313,34 +8331,35 @@ next_cpu:</i>
&gt;<i>  	BZERO(tv, sizeof(struct tv_range) * TVN);</i>
&gt;<i>  	init_tv_ranges(tv, vec_root_size, vec_size, cpu);</i>
&gt;<i>  </i>
&gt;<i> +	get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i> +</i>
&gt;<i>  	count += do_timer_list_v3(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -		vec_root_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_root_size, vec, NULL, NULL, jiffies, eflag);</i>
&gt;<i>  	count += do_timer_list_v3(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, jiffies, eflag);</i>
&gt;<i>  	count += do_timer_list_v3(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, jiffies, eflag);</i>
&gt;<i>  	count += do_timer_list_v3(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, jiffies, eflag);</i>
&gt;<i>  	count += do_timer_list_v3(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, jiffies, eflag);</i>
&gt;<i>  </i>
&gt;<i>  	if (count)</i>
&gt;<i>  		td = (struct timer_data *)</i>
&gt;<i>  			GETBUF((count*2) * sizeof(struct timer_data));</i>
&gt;<i>  	tdx = 0;</i>
&gt;<i>  	highest = 0;</i>
&gt;<i> -	get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i>  </i>
&gt;<i>  	do_timer_list_v3(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -		vec_root_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_root_size, vec, (void *)td, &amp;highest, jiffies, eflag);</i>
&gt;<i>  	do_timer_list_v3(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, jiffies, eflag);</i>
&gt;<i>  	do_timer_list_v3(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, jiffies, eflag);</i>
&gt;<i>  	do_timer_list_v3(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, jiffies, eflag);</i>
&gt;<i>  	tdx = do_timer_list_v3(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, jiffies, eflag);</i>
&gt;<i>  </i>
&gt;<i>  	qsort(td, tdx, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> @@ -8506,7 +8525,9 @@ do_timer_list(ulong vec_kvaddr,</i>
&gt;<i>  	      ulong *vec,</i>
&gt;<i>  	      void *option,</i>
&gt;<i>  	      ulong *highest,</i>
&gt;<i> -	      struct tv_range *tv)</i>
&gt;<i> +	      struct tv_range *tv,</i>
&gt;<i> +	      ulong jiffies,</i>
&gt;<i> +	      int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, t;</i>
&gt;<i>  	int count, tdx;</i>
&gt;<i> @@ -8577,6 +8598,9 @@ do_timer_list(ulong vec_kvaddr,</i>
&gt;<i>  </i>
&gt;<i>                                  expires = ULONG(timer_list_buf +</i>
&gt;<i>                                          OFFSET(timer_list_expires));</i>
&gt;<i> +				if (eflag &amp;&amp; expires &gt;= jiffies)</i>
&gt;<i> +					continue;</i>
&gt;<i> +</i>
&gt;<i>                                  function = ULONG(timer_list_buf +</i>
&gt;<i>                                          OFFSET(timer_list_function));</i>
&gt;<i>  </i>
&gt;<i> @@ -8641,6 +8665,9 @@ new_timer_list_format:</i>
&gt;<i>  </i>
&gt;<i>                          expires = ULONG(timer_list_buf +</i>
&gt;<i>  				OFFSET(timer_list_expires));</i>
&gt;<i> +			if (eflag &amp;&amp; expires &gt;= jiffies)</i>
&gt;<i> +				continue;</i>
&gt;<i> +</i>
&gt;<i>                          function = ULONG(timer_list_buf +</i>
&gt;<i>                          	OFFSET(timer_list_function));</i>
&gt;<i>  </i>
&gt;<i> @@ -8666,7 +8693,9 @@ do_timer_list_v3(ulong vec_kvaddr,</i>
&gt;<i>  	      int size,</i>
&gt;<i>  	      ulong *vec,</i>
&gt;<i>  	      void *option,</i>
&gt;<i> -	      ulong *highest)</i>
&gt;<i> +	      ulong *highest,</i>
&gt;<i> +	      ulong jiffies,</i>
&gt;<i> +	      int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, t;</i>
&gt;<i>  	int count, tdx;</i>
&gt;<i> @@ -8725,6 +8754,9 @@ do_timer_list_v3(ulong vec_kvaddr,</i>
&gt;<i>  </i>
&gt;<i>  			expires = ULONG(timer_list_buf +</i>
&gt;<i>  				OFFSET(timer_list_expires));</i>
&gt;<i> +			if (eflag &amp;&amp; expires &gt;= jiffies)</i>
&gt;<i> +				continue;</i>
&gt;<i> +</i>
&gt;<i>  			function = ULONG(timer_list_buf +</i>
&gt;<i>  				OFFSET(timer_list_function));</i>
&gt;<i>  </i>
&gt;<i> @@ -8755,7 +8787,7 @@ struct timer_bases_data {</i>
&gt;<i>  };</i>
&gt;<i>  </i>
&gt;<i>  static int</i>
&gt;<i> -do_timer_list_v4(struct timer_bases_data *data)</i>
&gt;<i> +do_timer_list_v4(struct timer_bases_data *data, ulong jiffies, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, t, timer_cnt, found;</i>
&gt;<i>  	struct list_data list_data, *ld;</i>
&gt;<i> @@ -8810,6 +8842,9 @@ do_timer_list_v4(struct timer_bases_data *data)</i>
&gt;<i>  				continue;</i>
&gt;<i>  </i>
&gt;<i>  			expires = ULONG(timer_list_buf + OFFSET(timer_list_expires));</i>
&gt;<i> +			if (eflag &amp;&amp; expires &gt;= jiffies)</i>
&gt;<i> +				continue;</i>
&gt;<i> +</i>
&gt;<i>  			function = ULONG(timer_list_buf + OFFSET(timer_list_function));</i>
&gt;<i>  </i>
&gt;<i>  			data-&gt;timers[data-&gt;cnt].address = timer_list[t];</i>
&gt;<i> @@ -8839,7 +8874,7 @@ do_timer_list_v4(struct timer_bases_data *data)</i>
&gt;<i>   *  Linux 4.8 timers use new timer_bases[][]</i>
&gt;<i>   */</i>
&gt;<i>  static void</i>
&gt;<i> -dump_timer_data_timer_bases(const ulong *cpus)</i>
&gt;<i> +dump_timer_data_timer_bases(const ulong *cpus, int eflag)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, cpu, flen, base, nr_bases, found, display, j = 0;</i>
&gt;<i>  	struct syment *sp;</i>
&gt;<i> @@ -8901,7 +8936,7 @@ next_base:</i>
&gt;<i>  	data.cnt = 0;</i>
&gt;<i>  	data.timer_base = timer_base;</i>
&gt;<i>  </i>
&gt;<i> -	found = do_timer_list_v4(&amp;data);</i>
&gt;<i> +	found = do_timer_list_v4(&amp;data, jiffies, eflag);</i>
&gt;<i>  	</i>
&gt;<i>  	qsort(data.timers, found, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> --</i>
&gt;<i> 2.22.0</i>
&gt;<i> </i>
&gt;<i> </i>

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="07788" href="msg07788.html">Re:  [PATCH] timers: add option to show expired	timers only</a></strong>
<ul><li><em>From:</em> Oleksandr Natalenko</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="07782" href="msg07782.html">[PATCH] timers: add option to show expired timers	only</a></strong>
<ul><li><em>From:</em> Oleksandr Natalenko</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07784.html">Re:  [PATCH] crash: bt: Introduce -p option</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07786.html">Re:  [PATCH] crash: dis: introduce count in reverse and forward mode</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07782.html">[PATCH] timers: add option to show expired timers	only</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07788.html">Re:  [PATCH] timers: add option to show expired	timers only</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07785"><strong>Date</strong></a></li>
<li><a href="index.html#07785"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
