<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re:  [PATCH v2] kernel/timers: show time to expire	for each timer -->
<!--X-From-R13: Rnir Oaqrefba &#60;naqrefbaNerqung.pbz> -->
<!--X-Date: Wed, 26 Jun 2019 11:59:52 &#45;0700 -->
<!--X-Message-Id: 143174013.31621923.1561575564062.JavaMail.zimbra@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190625113641.21291&#45;1&#45;oleksandr@redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Re:  [PATCH v2] kernel/timers: show time to expire	for each timer &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  Re:  [PATCH v2] kernel/timers: show time to expire	for each timer</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re:  [PATCH v2] kernel/timers: show time to expire	for each timer</h1>
[<a href="msg07806.html">Date Prev</a>][<a href="msg07808.html">Date Next</a>][<a href="msg07802.html">Thread Prev</a>][<a href="msg07803.html">Thread Next</a>][<a href="maillist.html#07807">Date Index</a>][<a href="index.html#07807">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re:  [PATCH v2] kernel/timers: show time to expire	for each timer</li>
<li><em>From</em>: Dave Anderson &lt;anderson@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Wed, 26 Jun 2019 14:59:24 -0400 (EDT)</li>
<li><em>Cc</em>: crash-utility@xxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg07802.html">20190625113641.21291-1-oleksandr@redhat.com</a>&gt;</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>
Hi Oleksandr,

Looks good -- queued for crash-7.2.7:

  <a  rel="nofollow" href="https://github.com/crash-utility/crash/commit/496d503e84147a24bdaf86782ab1d8af2fd76c9e">https://github.com/crash-utility/crash/commit/496d503e84147a24bdaf86782ab1d8af2fd76c9e</a>

Thanks,
  Dave


----- Original Message -----
&gt;<i> Extend `timer` command to show time to expire (TTE) for each timer.</i>
&gt;<i> </i>
&gt;<i> This is useful to verify what CPU is blocked due to looping with</i>
&gt;<i> interrupts disabled or due to lack of resources to run the vCPU on a</i>
&gt;<i> hypervisor side.</i>
&gt;<i> </i>
&gt;<i> `help` output is amended accordingly. Old examples are replaced with two</i>
&gt;<i> new ones, both are for the vmcore from the modern RHEL8 system.</i>
&gt;<i> </i>
&gt;<i> The commit was tested on the vmcores with the following kernel versions:</i>
&gt;<i> </i>
&gt;<i> * 2.6.18-436.el5</i>
&gt;<i> * 2.6.32-431.el6.x86_64</i>
&gt;<i> * 3.10.0-693.11.6.el7.x86_64</i>
&gt;<i> * 4.18.0-80.1.2.el8_0.x86_64</i>
&gt;<i> </i>
&gt;<i> Signed-off-by: Oleksandr Natalenko &lt;oleksandr@xxxxxxxxxx&gt;</i>
&gt;<i> ---</i>
&gt;<i>  defs.h   |   1 +</i>
&gt;<i>  help.c   | 167 ++++++++++++------------------------</i>
&gt;<i>  kernel.c | 255 ++++++++++++++++++++++++++++++++++++++-----------------</i>
&gt;<i>  tools.c  |   5 +-</i>
&gt;<i>  4 files changed, 236 insertions(+), 192 deletions(-)</i>
&gt;<i> </i>
&gt;<i> diff --git a/defs.h b/defs.h</i>
&gt;<i> index ccffe58..ceb6eb7 100644</i>
&gt;<i> --- a/defs.h</i>
&gt;<i> +++ b/defs.h</i>
&gt;<i> @@ -4387,6 +4387,7 @@ struct machine_specific {</i>
&gt;<i>  #define INT_HEX      (0x40)</i>
&gt;<i>  #define LONGLONG_HEX (0x80)</i>
&gt;<i>  #define ZERO_FILL   (0x100)</i>
&gt;<i> +#define SLONG_DEC   (0x200)</i>
&gt;<i>  </i>
&gt;<i>  #define INIT_TIME (1)</i>
&gt;<i>  #define RUN_TIME  (2)</i>
&gt;<i> diff --git a/help.c b/help.c</i>
&gt;<i> index 581e616..4f67ccf 100644</i>
&gt;<i> --- a/help.c</i>
&gt;<i> +++ b/help.c</i>
&gt;<i> @@ -2891,128 +2891,65 @@ char *help_timer[] = {</i>
&gt;<i>  &quot; -C cpu Restrict the output to one or more CPUs, where multiple cpu[s]</i>
&gt;<i>  can&quot;,</i>
&gt;<i>  &quot;        be specified, for example, as \&quot;1,3,5\&quot;, \&quot;1-3\&quot;, or</i>
&gt;<i>  \&quot;1,3,5-7,10\&quot;.&quot;,</i>
&gt;<i>  &quot;\nEXAMPLES&quot;,</i>
&gt;<i> +&quot; Display the timer queue on an SMP system:\n&quot;,</i>
&gt;<i>  &quot;    %s&gt; timer&quot;,</i>
&gt;<i>  &quot;    JIFFIES&quot;,</i>
&gt;<i> -&quot;      68102&quot;,</i>
&gt;<i> -&quot;    EXPIRES  TIMER_LIST/TABLE  FUNCTION&quot;,</i>
&gt;<i> -&quot;      68346      c0241934      c01775d4  &lt;tcp_sltimer_handler&gt;&quot;,</i>
&gt;<i> -&quot;      68379      c0241204      c01696d8  &lt;dev_do_watchdog&gt;&quot;,</i>
&gt;<i> -&quot;      68523      c7fcdfc0      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;      68718      c7fd8edc      c018719c  &lt;irlmp_discovery_timer_expired&gt;&quot;,</i>
&gt;<i> -&quot;      68723   timer_table[2]   c01c707c  &lt;rs_timer&gt;&quot;,</i>
&gt;<i> -&quot;      68742      c20c1f7c      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;      68742      c20c1f7c      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;      68742      c20c1f7c      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;      68752      c7fd1fc4      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;      68752      c7fd1fc4      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;      68989      c0241d40      c0168060  &lt;neigh_periodic_timer&gt;&quot;,</i>
&gt;<i> -&quot;      69028      c2533f7c      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;      69134      c22dd868      c0181948  &lt;unix_destroy_timer&gt;&quot;,</i>
&gt;<i> -&quot;      71574      c0241430      c0169ea4  &lt;rt_check_expire&gt;&quot;,</i>
&gt;<i> -&quot;      72179      c7fb1c48      c01cb9a0  &lt;vortex_timer&gt;&quot;,</i>
&gt;<i> -&quot;      73144      c1b17f10      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;      73259      c17a5f10      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;     112929      c203ff10      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;     372010      c2323f7c      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;     372138      c2191f10      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;    8653052      c1f13f10      c0112d6c  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot; &quot;,</i>
&gt;<i> -&quot;  Display the timer queue on a 2-cpu system:\n&quot;,</i>
&gt;<i> -&quot;    %s&gt; timer&quot;,</i>
&gt;<i> -&quot;    TVEC_BASES[0]: c1299be0&quot;,</i>
&gt;<i> -&quot;     JIFFIES&quot;,</i>
&gt;<i> -&quot;    18256298&quot;,</i>
&gt;<i> -&quot;     EXPIRES  TIMER_LIST  FUNCTION&quot;,</i>
&gt;<i> -&quot;    18256406   cd5ddec0   c01232bb  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;    18256677   ceea93e0   c011e3cc  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;    18256850   ceea7f64   c01232bb  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;    18258751   cd1d4f64   c01232bb  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;    18258792   cf5782f0   c011e3cc  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;    18261266   c03c9f80   c022fad5  &lt;rt_check_expire&gt;&quot;,</i>
&gt;<i> -&quot;    18262196   c02dc2e0   c0233329  &lt;peer_check_expire&gt;&quot;,</i>
&gt;<i> -&quot;    18270518   ceb8bf1c   c01232bb  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;    18271327   c03c9120   c0222074  &lt;flow_cache_new_hashrnd&gt;&quot;,</i>
&gt;<i> -&quot;    18271327   c03ca580   c0233ace  &lt;ipfrag_secret_rebuild&gt;&quot;,</i>
&gt;<i> -&quot;    18272532   c02d1e18   c0129946  &lt;delayed_work_timer_fn&gt;&quot;,</i>
&gt;<i> -&quot;    18276518   c03c9fc0   c022fd40  &lt;rt_secret_rebuild&gt;&quot;,</i>
&gt;<i> -&quot;    18332334   ceea9970   c011e3cc  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;    18332334   cfb6a840   c011e3cc  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;    18665378   cec25ec0   c01232bb  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;    TVEC_BASES[1]: c12a1be0&quot;,</i>
&gt;<i> -&quot;     JIFFIES&quot;,</i>
&gt;<i> -&quot;    18256298&quot;,</i>
&gt;<i> -&quot;     EXPIRES  TIMER_LIST  FUNCTION&quot;,</i>
&gt;<i> -&quot;    18256493   c02c7d00   c013dad5  &lt;wb_timer_fn&gt;&quot;,</i>
&gt;<i> -&quot;    18256499   c12a2db8   c0129946  &lt;delayed_work_timer_fn&gt;&quot;,</i>
&gt;<i> -&quot;    18277900   ceebaec0   c01232bb  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;    18283769   cf739f64   c01232bb  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> -&quot;    18331902   cee8af64   c01232bb  &lt;process_timeout&gt;&quot;,</i>
&gt;<i> +&quot;    4296291038&quot;,</i>
&gt;<i> +&quot;    ...&quot;,</i>
&gt;<i> +&quot;    TIMER_BASES[1][BASE_STD]: ffff9801aba5aa00&quot;,</i>
&gt;<i> +&quot;      EXPIRES        TTE         TIMER_LIST     FUNCTION&quot;,</i>
&gt;<i> +&quot;      4296282997    -8041  ffff9801aba55ce0  ffffffff83a3bda0</i>
&gt;<i> &lt;mce_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot;      4296283104    -7934  ffff97fd84bd35e0  ffffffff83ac6b70</i>
&gt;<i> &lt;delayed_work_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot;      4296291061       23  ffffa6b283967de0  ffffffff83b29880</i>
&gt;<i> &lt;process_timeout&gt;&quot;,</i>
&gt;<i> +&quot;      4296291112       74  ffff9800c9b62ad8  ffffffff83e6b550</i>
&gt;<i> &lt;cursor_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296291345      307  ffff980186d5ef88  ffffffff84146b80</i>
&gt;<i> &lt;tcp_keepalive_timer&gt;&quot;,</i>
&gt;<i> +&quot;      4296291484      446  ffff9801a7c54740  ffffffff84147f50</i>
&gt;<i> &lt;tcp_write_timer&gt;&quot;,</i>
&gt;<i> +&quot;      4296291997      959  ffffffffc073f880  ffffffff83ac6b70</i>
&gt;<i> &lt;delayed_work_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot;      4296296213     5175  ffffa6b28339be18  ffffffff83b29880</i>
&gt;<i> &lt;process_timeout&gt;&quot;,</i>
&gt;<i> +&quot;      4296304383    13345  ffff980194ca72a8  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296305724    14686  ffff980194ca6918  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296306036    14998  ffff980194ca6d58  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296306883    15845  ffff980194ca7e58  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296307588    16550  ffff9801aaa27e58  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296307625    16587  ffff980194ca6a28  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296313542    22504  ffff980194ca7c38  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296317680    26642  ffff9800c9149c58  ffffffff840da870</i>
&gt;<i> &lt;neigh_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296317744    26706  ffff9801a5354468  ffffffff83ac6b70</i>
&gt;<i> &lt;delayed_work_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot;      4296343322    52284  ffff980194ca63c8  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296343581    52543  ffff980194ca7088  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296343597    52559  ffff9801aaa274c8  ffffffff8412e4e0</i>
&gt;<i> &lt;tw_timer_handler&gt;&quot;,</i>
&gt;<i> +&quot;      4296714205   423167  ffffffff84caf3c0  ffffffff83ac6b70</i>
&gt;<i> &lt;delayed_work_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot;    TIMER_BASES[1][BASE_DEF]: ffff9801aba5bc80&quot;,</i>
&gt;<i> +&quot;      EXPIRES        TTE         TIMER_LIST     FUNCTION&quot;,</i>
&gt;<i> +&quot;      4296291264      226  ffffffff855eb238  ffffffff83c08fb0</i>
&gt;<i> &lt;writeout_period&gt;&quot;,</i>
&gt;<i> +&quot;      4296319997    28959  ffffffffc06ede40  ffffffff83ac6b70</i>
&gt;<i> &lt;delayed_work_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot;      4296506084   215046  ffff9801aba629c8  ffffffff83ac5ea0</i>
&gt;<i> &lt;idle_worker_timeout&gt;&quot;,</i>
&gt;<i> +&quot;    ...&quot;,</i>
&gt;<i>  &quot; &quot;,</i>
&gt;<i>  &quot;  Display a new-style hrtimer queue:\n&quot;,</i>
&gt;<i>  &quot;    %s&gt; timer -r&quot;,</i>
&gt;<i> -&quot;    CPU: 0  HRTIMER_CPU_BASE: c1e03fc0&quot;,</i>
&gt;<i> -&quot;      CLOCK: 0  HRTIMER_CLOCK_BASE: c1e03fc4  [ktime_get_real]&quot;,</i>
&gt;<i> -&quot;      (empty)&quot;,</i>
&gt;<i> -&quot;    &quot;,</i>
&gt;<i> -&quot;      CLOCK: 1  HRTIMER_CLOCK_BASE: c1e03ff0  [ktime_get]&quot;,</i>
&gt;<i> -&quot;         CURRENT&quot;,</i>
&gt;<i> -&quot;      322894000000&quot;,</i>
&gt;<i> -&quot;       SOFTEXPIRES     EXPIRES    HRTIMER   FUNCTION&quot;,</i>
&gt;<i> -&quot;      322895000000  322895000000  c1e04080  c04833e0  &lt;tick_sched_timer&gt;&quot;,</i>
&gt;<i> -&quot;      324022213609  324022213609  c1e041c0  c04b17d0  &lt;watchdog_timer_fn&gt;&quot;,</i>
&gt;<i> -&quot;      326766922781  326766972781  f3a45f44  c0477ed0  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> -&quot;      364516801997  364516851997  f43bbf44  c0477ed0  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> -&quot; &quot;,</i>
&gt;<i> -&quot;      CLOCK: 2  HRTIMER_CLOCK_BASE: c1e0401c  [ktime_get_boottime]&quot;,</i>
&gt;<i> -&quot;      (empty)&quot;,</i>
&gt;<i> -&quot;    &quot;,</i>
&gt;<i> -&quot;    CPU: 1  HRTIMER_CPU_BASE: c1e43fc0&quot;,</i>
&gt;<i> -&quot;      CLOCK: 0  HRTIMER_CLOCK_BASE: c1e43fc4  [ktime_get_real]&quot;,</i>
&gt;<i> -&quot;      (empty)&quot;,</i>
&gt;<i> -&quot;    &quot;,</i>
&gt;<i> -&quot;      CLOCK: 1  HRTIMER_CLOCK_BASE: c1e43ff0  [ktime_get]&quot;,</i>
&gt;<i> -&quot;         CURRENT&quot;,</i>
&gt;<i> -&quot;      322894000000&quot;,</i>
&gt;<i> -&quot;       SOFTEXPIRES     EXPIRES    HRTIMER   FUNCTION&quot;,</i>
&gt;<i> -&quot;      322895062500  322895062500  c1e44080  c04833e0  &lt;tick_sched_timer&gt;&quot;,</i>
&gt;<i> -&quot;      324087213609  324087213609  c1e441c0  c04b17d0  &lt;watchdog_timer_fn&gt;&quot;,</i>
&gt;<i> -&quot;      381034500892  381034550892  f3a1bea0  c0477ed0  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> -&quot; &quot;,</i>
&gt;<i> -&quot;      CLOCK: 2  HRTIMER_CLOCK_BASE: c1e4401c  [ktime_get_boottime]&quot;,</i>
&gt;<i> -&quot;      (empty)&quot;,</i>
&gt;<i>  &quot;    ...&quot;,</i>
&gt;<i> -&quot; &quot;,</i>
&gt;<i> -&quot;  Display an old-style hrtimer queue:\n&quot;,</i>
&gt;<i> -&quot;    %s&gt; timer -r&quot;,</i>
&gt;<i> -&quot;    CPU: 0&quot;,</i>
&gt;<i> -&quot;      CLOCK: 0  HRTIMER_BASE: ca00dae0  [ktime_get_real]&quot;,</i>
&gt;<i> -&quot;      (empty)&quot;,</i>
&gt;<i> -&quot;    &quot;,</i>
&gt;<i> -&quot;      CLOCK: 1  HRTIMER_BASE: ca00db0c  [ktime_get]&quot;,</i>
&gt;<i> -&quot;           CURRENT&quot;,</i>
&gt;<i> -&quot;      1480537567000000&quot;,</i>
&gt;<i> -&quot;           EXPIRES      HRTIMER   FUNCTION&quot;,</i>
&gt;<i> -&quot;      1480997557052703  f79c4944  c0427d18  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;      1481009329944302  cdcbaf6c  c0436a1e  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> -&quot;      1481026181758643  ea01cf6c  c0436a1e  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> -&quot;      1481497068511094  f79a6244  c0427d18  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;      1481589831928489  f7af6944  c0427d18  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;      1481592731187337  f64ed784  c0427d18  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;    &quot;,</i>
&gt;<i> -&quot;    CPU: 1&quot;,</i>
&gt;<i> -&quot;      CLOCK: 0  HRTIMER_BASE: ca0148c4  [ktime_get_real]&quot;,</i>
&gt;<i> +&quot;    CPU: 2  HRTIMER_CPU_BASE: ffff9801aba9cf00&quot;,</i>
&gt;<i> +&quot;      CLOCK: 0  HRTIMER_CLOCK_BASE: ffff9801aba9cf40  [ktime_get]&quot;,</i>
&gt;<i> +&quot;         CURRENT&quot;,</i>
&gt;<i> +&quot;      1623742000000&quot;,</i>
&gt;<i> +&quot;       SOFTEXPIRES      EXPIRES         TTE         HRTIMER</i>
&gt;<i> FUNCTION&quot;,</i>
&gt;<i> +&quot;      1623741000000  1623741000000    -1000000  ffff9801aba9d540</i>
&gt;<i> ffffffff83b3c8e0  &lt;tick_sched_timer&gt;&quot;,</i>
&gt;<i> +&quot;      1624024000000  1624024000000   282000000  ffff9801aba9d720</i>
&gt;<i> ffffffff83b7e7a0  &lt;watchdog_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot;      1626000939806  1626010929804  2268929804  ffffa6b28399fa40</i>
&gt;<i> ffffffff83b2c1e0  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> +&quot;      1627576915615  1627576915615  3834915615  ffff9801a5727978</i>
&gt;<i> ffffffff83b365c0  &lt;posix_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot;      1627637194488  1627647194487  3905194487  ffffa6b283977db0</i>
&gt;<i> ffffffff83b2c1e0  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> +&quot;      1629937423000  1629937423000  6195423000  ffff9801a9af2900</i>
&gt;<i> ffffffff83cf3d30  &lt;timerfd_tmrproc&gt;&quot;,</i>
&gt;<i> +&quot; &quot;,</i>
&gt;<i> +&quot;      CLOCK: 1  HRTIMER_CLOCK_BASE: ffff9801aba9cf80  [ktime_get_real]&quot;,</i>
&gt;<i> +&quot;            CURRENT&quot;,</i>
&gt;<i> +&quot;      1558362388334558243&quot;,</i>
&gt;<i> +&quot;          SOFTEXPIRES            EXPIRES             TTE           HRTIMER</i>
&gt;<i> FUNCTION&quot;,</i>
&gt;<i> +&quot;      1558362389331238000  1558362389331288000      996729757</i>
&gt;<i> ffffa6b28574bcf0  ffffffff83b2c1e0  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> +&quot;      1558364372000000000  1558364372000000000  1983665441757</i>
&gt;<i> ffff9801a3513278  ffffffff83b365c0  &lt;posix_timer_fn&gt;&quot;,</i>
&gt;<i> +&quot; &quot;,</i>
&gt;<i> +&quot;      CLOCK: 2  HRTIMER_CLOCK_BASE: ffff9801aba9cfc0</i>
&gt;<i> [ktime_get_boottime]&quot;,</i>
&gt;<i>  &quot;      (empty)&quot;,</i>
&gt;<i> -&quot;    &quot;,</i>
&gt;<i> -&quot;      CLOCK: 1  HRTIMER_BASE: ca0148f0  [ktime_get]&quot;,</i>
&gt;<i> -&quot;           CURRENT&quot;,</i>
&gt;<i> -&quot;      1480537567000000&quot;,</i>
&gt;<i> -&quot;           EXPIRES      HRTIMER   FUNCTION&quot;,</i>
&gt;<i> -&quot;      1481017523822478  ca3b15c4  c0427d18  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;      1481238077723188  f5f35f6c  c0436a1e  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> -&quot;      1481492107740948  f5dadf6c  c0436a1e  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i> -&quot;      1482936527251241  ca1becc4  c0427d18  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;      1482936545249010  f7d42e84  c0427d18  &lt;it_real_fn&gt;&quot;,</i>
&gt;<i> -&quot;      1492850155229325  ea01ef6c  c0436a1e  &lt;hrtimer_wakeup&gt;&quot;,</i>
&gt;<i>  &quot;    ...&quot;,</i>
&gt;<i>  &quot; &quot;,</i>
&gt;<i>  NULL</i>
&gt;<i> diff --git a/kernel.c b/kernel.c</i>
&gt;<i> index f01dc2e..818c29a 100644</i>
&gt;<i> --- a/kernel.c</i>
&gt;<i> +++ b/kernel.c</i>
&gt;<i> @@ -42,8 +42,8 @@ static void dump_hrtimer_data(const ulong *cpus);</i>
&gt;<i>  static void dump_hrtimer_clock_base(const void *, const int);</i>
&gt;<i>  static void dump_hrtimer_base(const void *, const int);</i>
&gt;<i>  static void dump_active_timers(const void *, ulonglong);</i>
&gt;<i> -static int get_expires_len(const int, const ulong *, const int);</i>
&gt;<i> -static void print_timer(const void *);</i>
&gt;<i> +static int get_expires_len(const int, const ulong *, ulonglong, const int);</i>
&gt;<i> +static void print_timer(const void *, ulonglong);</i>
&gt;<i>  static ulonglong ktime_to_ns(const void *);</i>
&gt;<i>  static void dump_timer_data(const ulong *cpus);</i>
&gt;<i>  static void dump_timer_data_tvec_bases_v1(const ulong *cpus);</i>
&gt;<i> @@ -52,10 +52,10 @@ static void dump_timer_data_tvec_bases_v3(const ulong</i>
&gt;<i> *cpus);</i>
&gt;<i>  static void dump_timer_data_timer_bases(const ulong *cpus);</i>
&gt;<i>  struct tv_range;</i>
&gt;<i>  static void init_tv_ranges(struct tv_range *, int, int, int);</i>
&gt;<i> -static int do_timer_list(ulong,int, ulong *, void *,ulong *,struct tv_range</i>
&gt;<i> *);</i>
&gt;<i> -static int do_timer_list_v3(ulong, int, ulong *, void *,ulong *);</i>
&gt;<i> +static int do_timer_list(ulong,int, ulong *, void *,ulong *, ulong *, struct</i>
&gt;<i> tv_range *, ulong);</i>
&gt;<i> +static int do_timer_list_v3(ulong, int, ulong *, void *,ulong *, ulong *,</i>
&gt;<i> ulong);</i>
&gt;<i>  struct timer_bases_data;</i>
&gt;<i> -static int do_timer_list_v4(struct timer_bases_data *);</i>
&gt;<i> +static int do_timer_list_v4(struct timer_bases_data *, ulong);</i>
&gt;<i>  static int compare_timer_data(const void *, const void *);</i>
&gt;<i>  static void panic_this_kernel(void);</i>
&gt;<i>  static void dump_waitq(ulong, char *);</i>
&gt;<i> @@ -7515,6 +7515,7 @@ dump_hrtimer_data(const ulong *cpus)</i>
&gt;<i>  </i>
&gt;<i>  static int expires_len = -1;</i>
&gt;<i>  static int softexpires_len = -1;</i>
&gt;<i> +static int tte_len = -1;</i>
&gt;<i>  </i>
&gt;<i>  static void</i>
&gt;<i>  dump_hrtimer_clock_base(const void *hrtimer_bases, const int num)</i>
&gt;<i> @@ -7578,6 +7579,7 @@ dump_active_timers(const void *base, ulonglong now)</i>
&gt;<i>  	char buf2[BUFSIZE];</i>
&gt;<i>  	char buf3[BUFSIZE];</i>
&gt;<i>  	char buf4[BUFSIZE];</i>
&gt;<i> +	char buf5[BUFSIZE];</i>
&gt;<i>  </i>
&gt;<i>  	next = 0;</i>
&gt;<i>  	timer_list = 0;</i>
&gt;<i> @@ -7637,10 +7639,11 @@ next_one:</i>
&gt;<i>  </i>
&gt;<i>  	/* dump hrtimers */</i>
&gt;<i>  	/* print header */</i>
&gt;<i> -	expires_len = get_expires_len(timer_cnt, timer_list, 0);</i>
&gt;<i> +	expires_len = get_expires_len(timer_cnt, timer_list, 0, 0);</i>
&gt;<i>  	if (expires_len &lt; 7)</i>
&gt;<i>  		expires_len = 7;</i>
&gt;<i> -	softexpires_len = get_expires_len(timer_cnt, timer_list, 1);</i>
&gt;<i> +	softexpires_len = get_expires_len(timer_cnt, timer_list, 0, 1);</i>
&gt;<i> +	tte_len = get_expires_len(timer_cnt, timer_list, now, 2);</i>
&gt;<i>  </i>
&gt;<i>  	if (softexpires_len &gt; -1) {</i>
&gt;<i>  		if (softexpires_len &lt; 11)</i>
&gt;<i> @@ -7650,9 +7653,10 @@ next_one:</i>
&gt;<i>  		sprintf(buf1, &quot;%lld&quot;, now);</i>
&gt;<i>  		fprintf(fp, &quot;  %s\n&quot;, mkstring(buf1, softexpires_len,</i>
&gt;<i>  			CENTER|RJUST, NULL));</i>
&gt;<i> -		fprintf(fp, &quot;  %s  %s  %s  %s\n&quot;,</i>
&gt;<i> +		fprintf(fp, &quot;  %s  %s  %s  %s  %s\n&quot;,</i>
&gt;<i>  			mkstring(buf1, softexpires_len, CENTER|RJUST, &quot;SOFTEXPIRES&quot;),</i>
&gt;<i>  			mkstring(buf2, expires_len, CENTER|RJUST, &quot;EXPIRES&quot;),</i>
&gt;<i> +			mkstring(buf5, tte_len, CENTER|RJUST, &quot;TTE&quot;),</i>
&gt;<i>  			mkstring(buf3, VADDR_PRLEN, CENTER|LJUST, &quot;HRTIMER&quot;),</i>
&gt;<i>  			mkstring(buf4, VADDR_PRLEN, CENTER|LJUST, &quot;FUNCTION&quot;));</i>
&gt;<i>  	} else {</i>
&gt;<i> @@ -7660,8 +7664,9 @@ next_one:</i>
&gt;<i>  			&quot;CURRENT&quot;));</i>
&gt;<i>  		sprintf(buf1, &quot;%lld&quot;, now);</i>
&gt;<i>  		fprintf(fp, &quot;  %s\n&quot;, mkstring(buf1, expires_len, CENTER|RJUST, NULL));</i>
&gt;<i> -		fprintf(fp, &quot;  %s  %s  %s\n&quot;,</i>
&gt;<i> +		fprintf(fp, &quot;  %s  %s  %s  %s\n&quot;,</i>
&gt;<i>  			mkstring(buf1, expires_len, CENTER|RJUST, &quot;EXPIRES&quot;),</i>
&gt;<i> +			mkstring(buf5, tte_len, CENTER|RJUST, &quot;TTE&quot;),</i>
&gt;<i>  			mkstring(buf2, VADDR_PRLEN, CENTER|LJUST, &quot;HRTIMER&quot;),</i>
&gt;<i>  			mkstring(buf3, VADDR_PRLEN, CENTER|LJUST, &quot;FUNCTION&quot;));</i>
&gt;<i>  	}</i>
&gt;<i> @@ -7675,12 +7680,12 @@ next_one:</i>
&gt;<i>  		else</i>
&gt;<i>  			timer = (void *)(timer_list[t] - OFFSET(hrtimer_node));</i>
&gt;<i>  </i>
&gt;<i> -		print_timer(timer);</i>
&gt;<i> +		print_timer(timer, now);</i>
&gt;<i>  	}</i>
&gt;<i>  }</i>
&gt;<i>  </i>
&gt;<i>  static int</i>
&gt;<i> -get_expires_len(const int timer_cnt, const ulong *timer_list, const int</i>
&gt;<i> getsoft)</i>
&gt;<i> +get_expires_len(const int timer_cnt, const ulong *timer_list, ulonglong now,</i>
&gt;<i> const int getsoft)</i>
&gt;<i>  {</i>
&gt;<i>  	void *last_timer;</i>
&gt;<i>  	char buf[BUFSIZE];</i>
&gt;<i> @@ -7700,7 +7705,7 @@ get_expires_len(const int timer_cnt, const ulong</i>
&gt;<i> *timer_list, const int getsoft)</i>
&gt;<i>  		last_timer = (void *)(timer_list[timer_cnt -1] -</i>
&gt;<i>  			OFFSET(hrtimer_node));</i>
&gt;<i>  </i>
&gt;<i> -	if (getsoft) {</i>
&gt;<i> +	if (getsoft == 1) {</i>
&gt;<i>  		/* soft expires exist*/</i>
&gt;<i>  		if (VALID_MEMBER(hrtimer_softexpires)) {</i>
&gt;<i>  			softexpires = ktime_to_ns(last_timer +</i>
&gt;<i> @@ -7715,7 +7720,7 @@ get_expires_len(const int timer_cnt, const ulong</i>
&gt;<i> *timer_list, const int getsoft)</i>
&gt;<i>  			expires = ktime_to_ns(last_timer + OFFSET(hrtimer_node) +</i>
&gt;<i>  				OFFSET(timerqueue_node_expires));</i>
&gt;<i>  </i>
&gt;<i> -		sprintf(buf, &quot;%lld&quot;, expires);</i>
&gt;<i> +		sprintf(buf, &quot;%lld&quot;, getsoft ? expires - now : expires);</i>
&gt;<i>  		len = strlen(buf);</i>
&gt;<i>  	}</i>
&gt;<i>  </i>
&gt;<i> @@ -7726,14 +7731,15 @@ get_expires_len(const int timer_cnt, const ulong</i>
&gt;<i> *timer_list, const int getsoft)</i>
&gt;<i>   * print hrtimer and its related information</i>
&gt;<i>   */</i>
&gt;<i>  static void</i>
&gt;<i> -print_timer(const void *timer)</i>
&gt;<i> +print_timer(const void *timer, ulonglong now)</i>
&gt;<i>  {</i>
&gt;<i> -	ulonglong softexpires, expires;</i>
&gt;<i> +	ulonglong softexpires, expires, tte;</i>
&gt;<i>  	</i>
&gt;<i>  	ulong function;</i>
&gt;<i>  	char buf1[BUFSIZE];</i>
&gt;<i>  	char buf2[BUFSIZE];</i>
&gt;<i>  	char buf3[BUFSIZE];</i>
&gt;<i> +	char buf4[BUFSIZE];</i>
&gt;<i>  </i>
&gt;<i>  	/* align information */</i>
&gt;<i>  	fprintf(fp, &quot;  &quot;);</i>
&gt;<i> @@ -7764,6 +7770,9 @@ print_timer(const void *timer)</i>
&gt;<i>  	sprintf(buf1, &quot;%lld&quot;, expires);</i>
&gt;<i>  	fprintf(fp, &quot;%s  &quot;, mkstring(buf2, expires_len, CENTER|RJUST, buf1));</i>
&gt;<i>  </i>
&gt;<i> +	tte = expires - now;</i>
&gt;<i> +	fprintf(fp, &quot;%s  &quot;, mkstring(buf4, tte_len, SLONG_DEC|RJUST, MKSTR(tte)));</i>
&gt;<i> +</i>
&gt;<i>  	fprintf(fp, &quot;%lx  &quot;, (ulong)timer);</i>
&gt;<i>  </i>
&gt;<i>  	if (readmem((ulong)(timer + OFFSET(hrtimer_function)), KVADDR, &amp;function,</i>
&gt;<i> @@ -7819,6 +7828,7 @@ struct timer_data {</i>
&gt;<i>  	ulong address;</i>
&gt;<i>  	ulong expires;</i>
&gt;<i>  	ulong function;</i>
&gt;<i> +	long tte;</i>
&gt;<i>  };</i>
&gt;<i>  </i>
&gt;<i>  struct tv_range {</i>
&gt;<i> @@ -7839,14 +7849,15 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  	} timer_table[32];</i>
&gt;<i>  	char buf[BUFSIZE];</i>
&gt;<i>  	char buf1[BUFSIZE];</i>
&gt;<i> +	char buf4[BUFSIZE];</i>
&gt;<i>          struct timer_struct *tp;</i>
&gt;<i> -        ulong mask, highest, function;</i>
&gt;<i> +        ulong mask, highest, highest_tte, function;</i>
&gt;<i>  	ulong jiffies, timer_jiffies;</i>
&gt;<i>  	ulong *vec;</i>
&gt;<i>  	long count;</i>
&gt;<i>          int vec_root_size, vec_size;</i>
&gt;<i>  	struct timer_data *td;</i>
&gt;<i> -	int flen, tdx, old_timers_exist;</i>
&gt;<i> +	int flen, tlen, tdx, old_timers_exist;</i>
&gt;<i>          struct tv_range tv[TVN];</i>
&gt;<i>  </i>
&gt;<i>  	if (kt-&gt;flags2 &amp; TIMER_BASES) {</i>
&gt;<i> @@ -7900,15 +7911,15 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  	init_tv_ranges(tv, vec_root_size, vec_size, 0);</i>
&gt;<i>  </i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv1&quot;) +</i>
&gt;<i>          OFFSET(timer_vec_root_vec),</i>
&gt;<i> -		vec_root_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_root_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv2&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv3&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv4&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(symbol_value(&quot;tv4&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>  </i>
&gt;<i>  	td = (struct timer_data *)</i>
&gt;<i>  		GETBUF((count*2) * sizeof(struct timer_data));</i>
&gt;<i> @@ -7920,6 +7931,7 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  		get_symbol_data(&quot;timer_active&quot;, sizeof(ulong), &amp;timer_active);</i>
&gt;<i>  </i>
&gt;<i>  	highest = 0;</i>
&gt;<i> +	highest_tte = 0;</i>
&gt;<i>          for (i = 0, mask = 1, tp = timer_table+0; old_timers_exist &amp;&amp; mask;</i>
&gt;<i>  	     i++, tp++, mask += mask) {</i>
&gt;<i>                  if (mask &gt; timer_active)</i>
&gt;<i> @@ -7931,21 +7943,24 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  		td[tdx].address = i;</i>
&gt;<i>  		td[tdx].expires = tp-&gt;expires;</i>
&gt;<i>  		td[tdx].function = (ulong)tp-&gt;fn;</i>
&gt;<i> +		td[tdx].tte = tp-&gt;expires - jiffies;</i>
&gt;<i>  		if (td[tdx].expires &gt; highest)</i>
&gt;<i>  			highest = td[tdx].expires;</i>
&gt;<i> +		if (abs(td[tdx].tte) &gt; highest_tte)</i>
&gt;<i> +			highest_tte = abs(td[tdx].tte);</i>
&gt;<i>  		tdx++;</i>
&gt;<i>          }</i>
&gt;<i>  </i>
&gt;<i>  	do_timer_list(symbol_value(&quot;tv1&quot;) + OFFSET(timer_vec_root_vec),</i>
&gt;<i> -		vec_root_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_root_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv, jiffies);</i>
&gt;<i>  	do_timer_list(symbol_value(&quot;tv2&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv, jiffies);</i>
&gt;<i>  	do_timer_list(symbol_value(&quot;tv3&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv, jiffies);</i>
&gt;<i>  	do_timer_list(symbol_value(&quot;tv4&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv, jiffies);</i>
&gt;<i>  	tdx = do_timer_list(symbol_value(&quot;tv5&quot;) + OFFSET(timer_vec_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv, jiffies);</i>
&gt;<i>  </i>
&gt;<i>          qsort(td, tdx, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> @@ -7958,13 +7973,21 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  	fprintf(fp, &quot;%s\n&quot;, mkstring(buf, flen, CENTER|LJUST, &quot;JIFFIES&quot;));</i>
&gt;<i>  	fprintf(fp, &quot;%s\n&quot;, mkstring(buf, flen, RJUST|LONG_DEC,MKSTR(jiffies)));</i>
&gt;<i>  </i>
&gt;<i> -	fprintf(fp, &quot;%s  TIMER_LIST/TABLE  FUNCTION\n&quot;,</i>
&gt;<i> -		mkstring(buf, flen, CENTER|LJUST, &quot;EXPIRES&quot;));</i>
&gt;<i> +	/* +1 accounts possible &quot;-&quot; sign */</i>
&gt;<i> +	sprintf(buf4, &quot;%ld&quot;, highest_tte);</i>
&gt;<i> +	tlen = MAX(strlen(buf4) + 1, strlen(&quot;TTE&quot;));</i>
&gt;<i> +</i>
&gt;<i> +	fprintf(fp, &quot;%s  %s  TIMER_LIST/TABLE  FUNCTION\n&quot;,</i>
&gt;<i> +		mkstring(buf, flen, CENTER|LJUST, &quot;EXPIRES&quot;),</i>
&gt;<i> +		mkstring(buf4, tlen, CENTER|LJUST, &quot;TTE&quot;));</i>
&gt;<i>  </i>
&gt;<i>          for (i = 0; i &lt; tdx; i++) {</i>
&gt;<i>          	fprintf(fp, &quot;%s&quot;,</i>
&gt;<i>  		    mkstring(buf, flen, RJUST|LONG_DEC, MKSTR(td[i].expires)));</i>
&gt;<i>  </i>
&gt;<i> +                fprintf(fp, &quot;  %s&quot;,</i>
&gt;<i> +                    mkstring(buf4, tlen, RJUST|SLONG_DEC,</i>
&gt;<i> MKSTR(td[i].tte)));</i>
&gt;<i> +</i>
&gt;<i>  		if (td[i].address &lt; 32) {</i>
&gt;<i>                          sprintf(buf, &quot;timer_table[%ld]&quot;, td[i].address);</i>
&gt;<i>                          fprintf(fp, &quot;  %s  &quot;,</i>
&gt;<i> @@ -8003,15 +8026,16 @@ dump_timer_data(const ulong *cpus)</i>
&gt;<i>  static void</i>
&gt;<i>  dump_timer_data_tvec_bases_v1(const ulong *cpus)</i>
&gt;<i>  {</i>
&gt;<i> -	int i, cpu, tdx, flen;</i>
&gt;<i> +	int i, cpu, tdx, flen, tlen;</i>
&gt;<i>          struct timer_data *td;</i>
&gt;<i>          int vec_root_size, vec_size;</i>
&gt;<i>          struct tv_range tv[TVN];</i>
&gt;<i> -	ulong *vec, jiffies, highest, function;</i>
&gt;<i> +	ulong *vec, jiffies, highest, highest_tte, function;</i>
&gt;<i>  	long count;</i>
&gt;<i>  	char buf1[BUFSIZE];</i>
&gt;<i>  	char buf2[BUFSIZE];</i>
&gt;<i>  	char buf3[BUFSIZE];</i>
&gt;<i> +	char buf4[BUFSIZE];</i>
&gt;<i>  </i>
&gt;<i>  	/*</i>
&gt;<i>           */</i>
&gt;<i> @@ -8038,33 +8062,35 @@ next_cpu:</i>
&gt;<i>          init_tv_ranges(tv, vec_root_size, vec_size, cpu);</i>
&gt;<i>  </i>
&gt;<i>          count += do_timer_list(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -                vec_root_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_root_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>  </i>
&gt;<i>  	if (count)</i>
&gt;<i>          	td = (struct timer_data *)</i>
&gt;<i>                  	GETBUF((count*2) * sizeof(struct timer_data));</i>
&gt;<i>          tdx = 0;</i>
&gt;<i>  	highest = 0;</i>
&gt;<i> +	highest_tte = 0;</i>
&gt;<i> +</i>
&gt;<i>          get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i>  </i>
&gt;<i>          do_timer_list(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -                vec_root_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_root_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>          do_timer_list(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>          do_timer_list(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>          do_timer_list(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>          tdx = do_timer_list(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>  </i>
&gt;<i>          qsort(td, tdx, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> @@ -8077,8 +8103,13 @@ next_cpu:</i>
&gt;<i>          fprintf(fp, &quot;%s\n&quot;, mkstring(buf1,flen,</i>
&gt;<i>  		RJUST|LONG_DEC,MKSTR(jiffies)));</i>
&gt;<i>  </i>
&gt;<i> -	fprintf(fp, &quot;%s  %s  %s\n&quot;,</i>
&gt;<i> +        /* +1 accounts possible &quot;-&quot; sign */</i>
&gt;<i> +        sprintf(buf4, &quot;%ld&quot;, highest_tte);</i>
&gt;<i> +        tlen = MAX(strlen(buf4) + 1, strlen(&quot;TTE&quot;));</i>
&gt;<i> +</i>
&gt;<i> +	fprintf(fp, &quot;%s  %s  %s  %s\n&quot;,</i>
&gt;<i>  		mkstring(buf1, flen, CENTER|RJUST, &quot;EXPIRES&quot;),</i>
&gt;<i> +		mkstring(buf4, tlen, CENTER|RJUST, &quot;TTE&quot;),</i>
&gt;<i>  		mkstring(buf2, VADDR_PRLEN, CENTER|LJUST, &quot;TIMER_LIST&quot;),</i>
&gt;<i>  		mkstring(buf3, VADDR_PRLEN, CENTER|LJUST, &quot;FUNCTION&quot;));</i>
&gt;<i>  </i>
&gt;<i> @@ -8086,6 +8117,9 @@ next_cpu:</i>
&gt;<i>                  fprintf(fp, &quot;%s&quot;,</i>
&gt;<i>                      mkstring(buf1, flen, RJUST|LONG_DEC,</i>
&gt;<i>                      MKSTR(td[i].expires)));</i>
&gt;<i>  </i>
&gt;<i> +                fprintf(fp, &quot;  %s&quot;,</i>
&gt;<i> +                    mkstring(buf4, tlen, RJUST|SLONG_DEC,</i>
&gt;<i> MKSTR(td[i].tte)));</i>
&gt;<i> +</i>
&gt;<i>                  fprintf(fp, &quot;  %s  &quot;, mkstring(buf1,</i>
&gt;<i>  			MAX(VADDR_PRLEN, strlen(&quot;TIMER_LIST&quot;)),</i>
&gt;<i>  			RJUST|CENTER|LONG_HEX, MKSTR(td[i].address)));</i>
&gt;<i> @@ -8123,17 +8157,18 @@ next_cpu:</i>
&gt;<i>  static void</i>
&gt;<i>  dump_timer_data_tvec_bases_v2(const ulong *cpus)</i>
&gt;<i>  {</i>
&gt;<i> -	int i, cpu, tdx, flen;</i>
&gt;<i> +	int i, cpu, tdx, flen, tlen;</i>
&gt;<i>          struct timer_data *td;</i>
&gt;<i>          int vec_root_size, vec_size;</i>
&gt;<i>          struct tv_range tv[TVN];</i>
&gt;<i> -	ulong *vec, jiffies, highest, function;</i>
&gt;<i> +	ulong *vec, jiffies, highest, highest_tte, function;</i>
&gt;<i>  	ulong tvec_bases;</i>
&gt;<i>  	long count;</i>
&gt;<i>  	struct syment *sp;</i>
&gt;<i>  	char buf1[BUFSIZE];</i>
&gt;<i>  	char buf2[BUFSIZE];</i>
&gt;<i>  	char buf3[BUFSIZE];</i>
&gt;<i> +	char buf4[BUFSIZE];</i>
&gt;<i>  </i>
&gt;<i>          vec_root_size = (i = ARRAY_LENGTH(tvec_root_s_vec)) ?</i>
&gt;<i>                  i : get_array_length(&quot;tvec_root_s.vec&quot;, NULL,</i>
&gt;<i>                  SIZE(list_head));</i>
&gt;<i> @@ -8180,33 +8215,35 @@ next_cpu:</i>
&gt;<i>          init_tv_ranges(tv, vec_root_size, vec_size, cpu);</i>
&gt;<i>  </i>
&gt;<i>          count += do_timer_list(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -                vec_root_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_root_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>          count += do_timer_list(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, NULL, NULL, tv);</i>
&gt;<i> +                vec_size, vec, NULL, NULL, NULL, tv, 0);</i>
&gt;<i>  </i>
&gt;<i>  	if (count)</i>
&gt;<i>          	td = (struct timer_data *)</i>
&gt;<i>                  	GETBUF((count*2) * sizeof(struct timer_data));</i>
&gt;<i>          tdx = 0;</i>
&gt;<i>  	highest = 0;</i>
&gt;<i> +	highest_tte = 0;</i>
&gt;<i> +</i>
&gt;<i>          get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i>  </i>
&gt;<i>          do_timer_list(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -                vec_root_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_root_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>          do_timer_list(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>          do_timer_list(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>          do_timer_list(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>          tdx = do_timer_list(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -                vec_size, vec, (void *)td, &amp;highest, tv);</i>
&gt;<i> +                vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, tv,</i>
&gt;<i> jiffies);</i>
&gt;<i>  </i>
&gt;<i>          qsort(td, tdx, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> @@ -8229,8 +8266,13 @@ next_cpu:</i>
&gt;<i>          fprintf(fp, &quot;%s\n&quot;, mkstring(buf1,flen,</i>
&gt;<i>  		RJUST|LONG_DEC,MKSTR(jiffies)));</i>
&gt;<i>  </i>
&gt;<i> -	fprintf(fp, &quot;%s  %s  %s\n&quot;,</i>
&gt;<i> +        /* +1 accounts possible &quot;-&quot; sign */</i>
&gt;<i> +        sprintf(buf4, &quot;%ld&quot;, highest_tte);</i>
&gt;<i> +        tlen = MAX(strlen(buf4) + 1, strlen(&quot;TTE&quot;));</i>
&gt;<i> +</i>
&gt;<i> +	fprintf(fp, &quot;%s  %s  %s  %s\n&quot;,</i>
&gt;<i>  		mkstring(buf1, flen, CENTER|RJUST, &quot;EXPIRES&quot;),</i>
&gt;<i> +		mkstring(buf4, tlen, CENTER|RJUST, &quot;TTE&quot;),</i>
&gt;<i>  		mkstring(buf2, VADDR_PRLEN, CENTER|LJUST, &quot;TIMER_LIST&quot;),</i>
&gt;<i>  		mkstring(buf3, VADDR_PRLEN, CENTER|LJUST, &quot;FUNCTION&quot;));</i>
&gt;<i>  </i>
&gt;<i> @@ -8238,6 +8280,9 @@ next_cpu:</i>
&gt;<i>                  fprintf(fp, &quot;%s&quot;,</i>
&gt;<i>                      mkstring(buf1, flen, RJUST|LONG_DEC,</i>
&gt;<i>                      MKSTR(td[i].expires)));</i>
&gt;<i>  </i>
&gt;<i> +                fprintf(fp, &quot;  %s&quot;,</i>
&gt;<i> +                    mkstring(buf4, tlen, RJUST|SLONG_DEC,</i>
&gt;<i> MKSTR(td[i].tte)));</i>
&gt;<i> +</i>
&gt;<i>                  fprintf(fp, &quot;  %s  &quot;, mkstring(buf1,</i>
&gt;<i>  			MAX(VADDR_PRLEN, strlen(&quot;TIMER_LIST&quot;)),</i>
&gt;<i>  			RJUST|CENTER|LONG_HEX, MKSTR(td[i].address)));</i>
&gt;<i> @@ -8274,17 +8319,18 @@ next_cpu:</i>
&gt;<i>  static void</i>
&gt;<i>  dump_timer_data_tvec_bases_v3(const ulong *cpus)</i>
&gt;<i>  {</i>
&gt;<i> -	int i, cpu, tdx, flen;</i>
&gt;<i> +	int i, cpu, tdx, flen, tlen;</i>
&gt;<i>  	struct timer_data *td;</i>
&gt;<i>  	int vec_root_size, vec_size;</i>
&gt;<i>  	struct tv_range tv[TVN];</i>
&gt;<i> -	ulong *vec, jiffies, highest, function;</i>
&gt;<i> +	ulong *vec, jiffies, highest, highest_tte, function;</i>
&gt;<i>  	ulong tvec_bases;</i>
&gt;<i>  	long count, head_size;</i>
&gt;<i>  	struct syment *sp;</i>
&gt;<i>  	char buf1[BUFSIZE];</i>
&gt;<i>  	char buf2[BUFSIZE];</i>
&gt;<i>  	char buf3[BUFSIZE];</i>
&gt;<i> +	char buf4[BUFSIZE];</i>
&gt;<i>  </i>
&gt;<i>  	vec_root_size = vec_size = 0;</i>
&gt;<i>  	head_size = SIZE(hlist_head);</i>
&gt;<i> @@ -8325,33 +8371,35 @@ next_cpu:</i>
&gt;<i>  	init_tv_ranges(tv, vec_root_size, vec_size, cpu);</i>
&gt;<i>  </i>
&gt;<i>  	count += do_timer_list_v3(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -		vec_root_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_root_size, vec, NULL, NULL, NULL, 0);</i>
&gt;<i>  	count += do_timer_list_v3(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, NULL, 0);</i>
&gt;<i>  	count += do_timer_list_v3(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, NULL, 0);</i>
&gt;<i>  	count += do_timer_list_v3(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, NULL, 0);</i>
&gt;<i>  	count += do_timer_list_v3(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, NULL, NULL);</i>
&gt;<i> +		vec_size, vec, NULL, NULL, NULL, 0);</i>
&gt;<i>  </i>
&gt;<i>  	if (count)</i>
&gt;<i>  		td = (struct timer_data *)</i>
&gt;<i>  			GETBUF((count*2) * sizeof(struct timer_data));</i>
&gt;<i>  	tdx = 0;</i>
&gt;<i>  	highest = 0;</i>
&gt;<i> +	highest_tte = 0;</i>
&gt;<i> +</i>
&gt;<i>  	get_symbol_data(&quot;jiffies&quot;, sizeof(ulong), &amp;jiffies);</i>
&gt;<i>  </i>
&gt;<i>  	do_timer_list_v3(tv[1].base + OFFSET(tvec_root_s_vec),</i>
&gt;<i> -		vec_root_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_root_size, vec, (void *)td, &amp;highest, &amp;highest_tte, jiffies);</i>
&gt;<i>  	do_timer_list_v3(tv[2].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, jiffies);</i>
&gt;<i>  	do_timer_list_v3(tv[3].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, jiffies);</i>
&gt;<i>  	do_timer_list_v3(tv[4].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, jiffies);</i>
&gt;<i>  	tdx = do_timer_list_v3(tv[5].base + OFFSET(tvec_s_vec),</i>
&gt;<i> -		vec_size, vec, (void *)td, &amp;highest);</i>
&gt;<i> +		vec_size, vec, (void *)td, &amp;highest, &amp;highest_tte, jiffies);</i>
&gt;<i>  </i>
&gt;<i>  	qsort(td, tdx, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> @@ -8369,8 +8417,13 @@ next_cpu:</i>
&gt;<i>  	fprintf(fp, &quot;%s\n&quot;, mkstring(buf1,flen,</i>
&gt;<i>  		RJUST|LONG_DEC,MKSTR(jiffies)));</i>
&gt;<i>  </i>
&gt;<i> -	fprintf(fp, &quot;%s  %s  %s\n&quot;,</i>
&gt;<i> +	/* +1 accounts possible &quot;-&quot; sign */</i>
&gt;<i> +	sprintf(buf4, &quot;%ld&quot;, highest_tte);</i>
&gt;<i> +	tlen = MAX(strlen(buf4) + 1, strlen(&quot;TTE&quot;));</i>
&gt;<i> +</i>
&gt;<i> +	fprintf(fp, &quot;%s  %s  %s  %s\n&quot;,</i>
&gt;<i>  		mkstring(buf1, flen, CENTER|RJUST, &quot;EXPIRES&quot;),</i>
&gt;<i> +		mkstring(buf4, tlen, CENTER|RJUST, &quot;TTE&quot;),</i>
&gt;<i>  		mkstring(buf2, VADDR_PRLEN, CENTER|LJUST, &quot;TIMER_LIST&quot;),</i>
&gt;<i>  		mkstring(buf3, VADDR_PRLEN, CENTER|LJUST, &quot;FUNCTION&quot;));</i>
&gt;<i>  </i>
&gt;<i> @@ -8378,6 +8431,9 @@ next_cpu:</i>
&gt;<i>  		fprintf(fp, &quot;%s&quot;,</i>
&gt;<i>  			mkstring(buf1, flen, RJUST|LONG_DEC, MKSTR(td[i].expires)));</i>
&gt;<i>  </i>
&gt;<i> +		fprintf(fp, &quot;  %s&quot;,</i>
&gt;<i> +			mkstring(buf4, tlen, RJUST|SLONG_DEC, MKSTR(td[i].tte)));</i>
&gt;<i> +</i>
&gt;<i>  		fprintf(fp, &quot;  %s  &quot;, mkstring(buf1,</i>
&gt;<i>  			MAX(VADDR_PRLEN, strlen(&quot;TIMER_LIST&quot;)),</i>
&gt;<i>  			RJUST|CENTER|LONG_HEX, MKSTR(td[i].address)));</i>
&gt;<i> @@ -8517,7 +8573,9 @@ do_timer_list(ulong vec_kvaddr,</i>
&gt;<i>  	      ulong *vec,</i>
&gt;<i>  	      void *option,</i>
&gt;<i>  	      ulong *highest,</i>
&gt;<i> -	      struct tv_range *tv)</i>
&gt;<i> +	      ulong *highest_tte,</i>
&gt;<i> +	      struct tv_range *tv,</i>
&gt;<i> +	      ulong jiffies)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, t;</i>
&gt;<i>  	int count, tdx;</i>
&gt;<i> @@ -8595,8 +8653,11 @@ do_timer_list(ulong vec_kvaddr,</i>
&gt;<i>                                          td[tdx].address = timer_list[t];</i>
&gt;<i>                                          td[tdx].expires = expires;</i>
&gt;<i>                                          td[tdx].function = function;</i>
&gt;<i> +                                        td[tdx].tte = expires - jiffies;</i>
&gt;<i>                                          if (highest &amp;&amp; (expires &gt; *highest))</i>
&gt;<i>                                                  *highest = expires;</i>
&gt;<i> +                                        if (highest_tte &amp;&amp; (abs(td[tdx].tte)</i>
&gt;<i> &gt; *highest_tte))</i>
&gt;<i> +                                                *highest_tte =</i>
&gt;<i> abs(td[tdx].tte);</i>
&gt;<i>                                          tdx++;</i>
&gt;<i>                                  }</i>
&gt;<i>  			}</i>
&gt;<i> @@ -8659,8 +8720,11 @@ new_timer_list_format:</i>
&gt;<i>                                  td[tdx].address = timer_list[t];</i>
&gt;<i>                                  td[tdx].expires = expires;</i>
&gt;<i>                                  td[tdx].function = function;</i>
&gt;<i> +                                td[tdx].tte = expires - jiffies;</i>
&gt;<i>                                  if (highest &amp;&amp; (expires &gt; *highest))</i>
&gt;<i>                                          *highest = expires;</i>
&gt;<i> +                                if (highest_tte &amp;&amp; (abs(td[tdx].tte) &gt;</i>
&gt;<i> *highest_tte))</i>
&gt;<i> +                                        *highest_tte = abs(td[tdx].tte);</i>
&gt;<i>                                  tdx++;</i>
&gt;<i>                          }</i>
&gt;<i>  		}</i>
&gt;<i> @@ -8677,7 +8741,9 @@ do_timer_list_v3(ulong vec_kvaddr,</i>
&gt;<i>  	      int size,</i>
&gt;<i>  	      ulong *vec,</i>
&gt;<i>  	      void *option,</i>
&gt;<i> -	      ulong *highest)</i>
&gt;<i> +	      ulong *highest,</i>
&gt;<i> +	      ulong *highest_tte,</i>
&gt;<i> +	      ulong jiffies)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, t;</i>
&gt;<i>  	int count, tdx;</i>
&gt;<i> @@ -8743,8 +8809,11 @@ do_timer_list_v3(ulong vec_kvaddr,</i>
&gt;<i>  				td[tdx].address = timer_list[t];</i>
&gt;<i>  				td[tdx].expires = expires;</i>
&gt;<i>  				td[tdx].function = function;</i>
&gt;<i> +				td[tdx].tte = expires - jiffies;</i>
&gt;<i>  				if (highest &amp;&amp; (expires &gt; *highest))</i>
&gt;<i>  					*highest = expires;</i>
&gt;<i> +				if (highest_tte &amp;&amp; (abs(td[tdx].tte) &gt; *highest_tte))</i>
&gt;<i> +					*highest_tte = abs(td[tdx].tte);</i>
&gt;<i>  				tdx++;</i>
&gt;<i>  			}</i>
&gt;<i>  		}</i>
&gt;<i> @@ -8766,7 +8835,7 @@ struct timer_bases_data {</i>
&gt;<i>  };</i>
&gt;<i>  </i>
&gt;<i>  static int</i>
&gt;<i> -do_timer_list_v4(struct timer_bases_data *data)</i>
&gt;<i> +do_timer_list_v4(struct timer_bases_data *data, ulong jiffies)</i>
&gt;<i>  {</i>
&gt;<i>  	int i, t, timer_cnt, found;</i>
&gt;<i>  	struct list_data list_data, *ld;</i>
&gt;<i> @@ -8826,6 +8895,7 @@ do_timer_list_v4(struct timer_bases_data *data)</i>
&gt;<i>  			data-&gt;timers[data-&gt;cnt].address = timer_list[t];</i>
&gt;<i>  			data-&gt;timers[data-&gt;cnt].expires = expires;</i>
&gt;<i>  			data-&gt;timers[data-&gt;cnt].function = function;</i>
&gt;<i> +			data-&gt;timers[data-&gt;cnt].tte = expires - jiffies;</i>
&gt;<i>  			data-&gt;cnt++;</i>
&gt;<i>  </i>
&gt;<i>  			if (data-&gt;cnt == data-&gt;total) {</i>
&gt;<i> @@ -8852,12 +8922,13 @@ do_timer_list_v4(struct timer_bases_data *data)</i>
&gt;<i>  static void</i>
&gt;<i>  dump_timer_data_timer_bases(const ulong *cpus)</i>
&gt;<i>  {</i>
&gt;<i> -	int i, cpu, flen, base, nr_bases, found, display, j = 0;</i>
&gt;<i> +	int i, cpu, flen, tlen, base, nr_bases, found, display, j = 0;</i>
&gt;<i>  	struct syment *sp;</i>
&gt;<i> -	ulong timer_base, jiffies, function;</i>
&gt;<i> +	ulong timer_base, jiffies, function, highest_tte;</i>
&gt;<i>  	struct timer_bases_data data;</i>
&gt;<i>  	char buf1[BUFSIZE];</i>
&gt;<i>  	char buf2[BUFSIZE];</i>
&gt;<i> +	char buf4[BUFSIZE];</i>
&gt;<i>  </i>
&gt;<i>  	if (!(data.num_vectors = get_array_length(&quot;timer_base.vectors&quot;, NULL, 0)))</i>
&gt;<i>  		error(FATAL, &quot;cannot determine timer_base.vectors[] array size\n&quot;);</i>
&gt;<i> @@ -8912,12 +8983,42 @@ next_base:</i>
&gt;<i>  	data.cnt = 0;</i>
&gt;<i>  	data.timer_base = timer_base;</i>
&gt;<i>  </i>
&gt;<i> -	found = do_timer_list_v4(&amp;data);</i>
&gt;<i> +	found = do_timer_list_v4(&amp;data, jiffies);</i>
&gt;<i>  	</i>
&gt;<i>  	qsort(data.timers, found, sizeof(struct timer_data), compare_timer_data);</i>
&gt;<i>  </i>
&gt;<i> -	fprintf(fp, &quot;  %s     TIMER_LIST     FUNCTION\n&quot;,</i>
&gt;<i> -		mkstring(buf1, flen, LJUST, &quot;EXPIRES&quot;));</i>
&gt;<i> +	highest_tte = 0;</i>
&gt;<i> +	for (i = 0; i &lt; found; i++) {</i>
&gt;<i> +	    display = FALSE;</i>
&gt;<i> +</i>
&gt;<i> +	    if (is_kernel_text(data.timers[i].function)) {</i>
&gt;<i> +		display = TRUE;</i>
&gt;<i> +	    } else {</i>
&gt;<i> +		if (readmem(data.timers[i].function, KVADDR, &amp;function,</i>
&gt;<i> +		    sizeof(ulong), &quot;timer function&quot;,</i>
&gt;<i> +		    RETURN_ON_ERROR|QUIET) &amp;&amp; is_kernel_text(function)) {</i>
&gt;<i> +		    display = TRUE;</i>
&gt;<i> +		} else {</i>
&gt;<i> +                    if (LIVE())</i>
&gt;<i> +			display = FALSE;</i>
&gt;<i> +		    else</i>
&gt;<i> +			display = TRUE;</i>
&gt;<i> +		}</i>
&gt;<i> +	    }</i>
&gt;<i> +</i>
&gt;<i> +	    if (display) {</i>
&gt;<i> +		if (abs(data.timers[i].tte) &gt; highest_tte)</i>
&gt;<i> +		    highest_tte = abs(data.timers[i].tte);</i>
&gt;<i> +	    }</i>
&gt;<i> +	}</i>
&gt;<i> +</i>
&gt;<i> +	/* +1 accounts possible &quot;-&quot; sign */</i>
&gt;<i> +	sprintf(buf4, &quot;%ld&quot;, highest_tte);</i>
&gt;<i> +	tlen = MAX(strlen(buf4) + 1, strlen(&quot;TTE&quot;));</i>
&gt;<i> +</i>
&gt;<i> +	fprintf(fp, &quot;  %s     %s     TIMER_LIST     FUNCTION\n&quot;,</i>
&gt;<i> +		mkstring(buf1, flen, LJUST, &quot;EXPIRES&quot;),</i>
&gt;<i> +		mkstring(buf4, tlen, LJUST, &quot;TTE&quot;));</i>
&gt;<i>  </i>
&gt;<i>  	for (i = 0; i &lt; found; i++) {</i>
&gt;<i>  		display = FALSE;</i>
&gt;<i> @@ -8946,6 +9047,8 @@ next_base:</i>
&gt;<i>  		if (display) {</i>
&gt;<i>  			fprintf(fp, &quot;  %s&quot;,</i>
&gt;<i>  				mkstring(buf1, flen, RJUST|LONG_DEC, MKSTR(data.timers[i].expires)));</i>
&gt;<i> +			fprintf(fp, &quot;  %s&quot;,</i>
&gt;<i> +				mkstring(buf4, tlen, RJUST|SLONG_DEC, MKSTR(data.timers[i].tte)));</i>
&gt;<i>  			mkstring(buf1, VADDR_PRLEN, RJUST|LONG_HEX,</i>
&gt;<i>  			MKSTR(data.timers[i].address));</i>
&gt;<i>  			fprintf(fp, &quot;  %s  &quot;, mkstring(buf2, 16, CENTER, buf1));</i>
&gt;<i>  			fprintf(fp, &quot;%s  &lt;%s&gt;\n&quot;,</i>
&gt;<i> diff --git a/tools.c b/tools.c</i>
&gt;<i> index 2d95c3a..5c0e63e 100644</i>
&gt;<i> --- a/tools.c</i>
&gt;<i> +++ b/tools.c</i>
&gt;<i> @@ -1650,11 +1650,14 @@ mkstring(char *s, int size, ulong flags, const char</i>
&gt;<i> *opt)</i>
&gt;<i>  	int left;</i>
&gt;<i>  	int right;</i>
&gt;<i>  </i>
&gt;<i> -	switch (flags &amp; (LONG_DEC|LONG_HEX|INT_HEX|INT_DEC|LONGLONG_HEX|ZERO_FILL))</i>
&gt;<i> +	switch (flags &amp;</i>
&gt;<i> (LONG_DEC|SLONG_DEC|LONG_HEX|INT_HEX|INT_DEC|LONGLONG_HEX|ZERO_FILL))</i>
&gt;<i>  	{</i>
&gt;<i>  	case LONG_DEC:</i>
&gt;<i>  		sprintf(s, &quot;%lu&quot;, (ulong)opt);</i>
&gt;<i>  		break;</i>
&gt;<i> +	case SLONG_DEC:</i>
&gt;<i> +		sprintf(s, &quot;%ld&quot;, (ulong)opt);</i>
&gt;<i> +		break;</i>
&gt;<i>  	case LONG_HEX:</i>
&gt;<i>  		sprintf(s, &quot;%lx&quot;, (ulong)opt);</i>
&gt;<i>  		break;</i>
&gt;<i> --</i>
&gt;<i> 2.22.0</i>
&gt;<i> </i>
&gt;<i> </i>

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="07802" href="msg07802.html">[PATCH v2] kernel/timers: show time to expire for	each timer</a></strong>
<ul><li><em>From:</em> Oleksandr Natalenko</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07806.html">Re:  [ANNOUNCE] crash gcore command, version 1.5.1 is released</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07808.html">Re:  [PATCH] Allows to change the error output direction</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07802.html">[PATCH v2] kernel/timers: show time to expire for	each timer</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07803.html">[ANNOUNCE] crash gcore command,	version 1.5.1 is released</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07807"><strong>Date</strong></a></li>
<li><a href="index.html#07807"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
