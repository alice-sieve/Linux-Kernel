<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re:  [PATCH] Speed up "kmem &#45;[sS]" by optimizing is_page_ptr() -->
<!--X-From-R13: Rnir Oaqrefba &#60;naqrefbaNerqung.pbz> -->
<!--X-Date: Fri, 23 Feb 2018 09:20:18 &#45;0800 -->
<!--X-Message-Id: 1399471870.4721537.1519406408097.JavaMail.zimbra@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 1518544323&#45;30278&#45;1&#45;git&#45;send&#45;email&#45;k&#45;hagio@ab.jp.nec.com -->
<!--X-Reference: 260833146.2200404.1518550403011.JavaMail.zimbra@redhat.com -->
<!--X-Reference: 417505940.4055664.1519231309909.JavaMail.zimbra@redhat.com -->
<!--X-Reference: 026be9ed&#45;fef3&#45;e971&#45;de1c&#45;119cf0b4aeab@redhat.com -->
<!--X-Reference: 849916623.4122576.1519247687639.JavaMail.zimbra@redhat.com -->
<!--X-Reference: 6e8031f1&#45;d62c&#45;c56a&#45;0976&#45;66e0c7c5e954@redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr() &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</h1>
[<a href="msg07341.html">Date Prev</a>][<a href="msg07343.html">Date Next</a>][<a href="msg07341.html">Thread Prev</a>][<a href="msg07345.html">Thread Next</a>][<a href="maillist.html#07342">Date Index</a>][<a href="index.html#07342">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</li>
<li><em>From</em>: Dave Anderson &lt;anderson@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Fri, 23 Feb 2018 12:20:08 -0500 (EST)</li>
<li><em>In-reply-to</em>: &lt;<a href="msg07341.html">6e8031f1-d62c-c56a-0976-66e0c7c5e954@redhat.com</a>&gt;</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>



 ----- Original Message -----
&gt;<i> Hi Dave,</i>
&gt;<i> </i>
&gt;<i> On 2/21/2018 4:14 PM, Dave Anderson wrote:</i>
&gt;<i> &gt; </i>
&gt;<i> &gt; </i>
&gt;<i> &gt; ----- Original Message -----</i>
&gt;<i> &gt;&gt; Hi Dave,</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt; Thank you so much for your review!</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt; On 2/21/2018 11:41 AM, Dave Anderson wrote:</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt; Hi Kasuhito,</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt; Just as a follow-up review of this part of your original patch:</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;   +#ifdef VMEMMAP_VADDR</i>
&gt;<i> &gt;&gt;&gt;   +               nr = nr_mem_sections;</i>
&gt;<i> &gt;&gt;&gt;   +               if (machdep-&gt;flags &amp; VMEMMAP)</i>
&gt;<i> &gt;&gt;&gt;   +                       nr = pfn_to_section_nr((addr - VMEMMAP_VADDR) /</i>
&gt;<i> &gt;&gt;&gt;   SIZE(page));</i>
&gt;<i> &gt;&gt;&gt;   +               else if (readmem(addr + OFFSET(page_flags), KVADDR,</i>
&gt;<i> &gt;&gt;&gt;   &amp;flags,</i>
&gt;<i> &gt;&gt;&gt;   +                       sizeof(ulong), &quot;page.flags&quot;,</i>
&gt;<i> &gt;&gt;&gt;   RETURN_ON_ERROR|QUIET))</i>
&gt;<i> &gt;&gt;&gt;   +                       nr = (flags &gt;&gt; (SIZE(page_flags)*8 -</i>
&gt;<i> &gt;&gt;&gt;   SECTIONS_SHIFT())</i>
&gt;<i> &gt;&gt;&gt;   +                               &amp; ((1UL &lt;&lt; SECTIONS_SHIFT()) - 1));</i>
&gt;<i> &gt;&gt;&gt;   +</i>
&gt;<i> &gt;&gt;&gt;   +               if (nr &lt; nr_mem_sections) {</i>
&gt;<i> &gt;&gt;&gt;   +#else</i>
&gt;<i> &gt;&gt;&gt;                   for (nr = 0; nr &lt; nr_mem_sections ; nr++) {</i>
&gt;<i> &gt;&gt;&gt;   +#endif</i>
&gt;<i> &gt;&gt;&gt;   </i>
&gt;<i> &gt;&gt;&gt; One of my original concerns was associated with the</i>
&gt;<i> &gt;&gt;&gt; backwards-compatiblity</i>
&gt;<i> &gt;&gt;&gt; of the non-VMEMMAP page-&gt;flags usage, primarily because it has changed</i>
&gt;<i> &gt;&gt;&gt; over the years.  Perhaps the SECTIONS_SHIFT part has remained the same,</i>
&gt;<i> &gt;&gt;&gt; but depending upon its future stability in this function still worries</i>
&gt;<i> &gt;&gt;&gt; me.</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt; Yes, I understand the concern.</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt; The SECTIONS_SHIFT part is the same as the function page_to_section() in</i>
&gt;<i> &gt;&gt; include/linux/mm.h.  I thought that if the values related to</i>
&gt;<i> &gt;&gt; SECTIONS_SHIFT</i>
&gt;<i> &gt;&gt; in kernel change, the crash utility will have to follow it regardless of</i>
&gt;<i> &gt;&gt; this patch, because they are used commonly in crash.  But possible changes</i>
&gt;<i> &gt;&gt; could not be limited to such values.</i>
&gt;<i> &gt; </i>
&gt;<i> &gt; It's true that crash should follow the upstream values, but in the past</i>
&gt;<i> &gt; there have been periods of times when the MAX_PHYSMEM_BITS and</i>
&gt;<i> &gt; SECTION_SIZE_BITS</i>
&gt;<i> &gt; for different architectures changed upstream, but were not immediately</i>
&gt;<i> &gt; updated in</i>
&gt;<i> &gt; the crash utility.  And that was because crash still worked OK because most</i>
&gt;<i> &gt; systems did not have large enough memory for the changes to cause things to</i>
&gt;<i> &gt; fail.</i>
&gt;<i> </i>
&gt;<i> Thank you, I understood it more precisely.</i>
&gt;<i> </i>
&gt;<i> [...]</i>
&gt;<i> &gt; So this goes to the question as to whether is_page_ptr() should return TRUE</i>
&gt;<i> &gt; if the incoming page address is accessible(), but it references a physical</i>
&gt;<i> &gt; address</i>
&gt;<i> &gt; that does not exist.  With the current code, it verifies that it's a page</i>
&gt;<i> &gt; address,</i>
&gt;<i> &gt; and that the page address points to an actual physical memory page.  I</i>
&gt;<i> &gt; suggested</i>
&gt;<i> &gt; using accessible() on the page structure address, but that would not</i>
&gt;<i> &gt; necessarily</i>
&gt;<i> &gt; be accurate because theoretically a vmemmap'd/instantiated page of page</i>
&gt;<i> &gt; structures</i>
&gt;<i> &gt; could contain page structure addresses that do not reference physical</i>
&gt;<i> &gt; memory.</i>
&gt;<i> &gt; (e.g., if a hole started at a page address that's in the  middle of a</i>
&gt;<i> &gt; vmemmap'd</i>
&gt;<i> &gt; page of page structures)</i>
&gt;<i> </i>
&gt;<i> As to the last example (IIUC), I had confirmed that accessible() returned</i>
&gt;<i> FALSE if a page address was in a hole like below on x86_64/RHEL7, so I was</i>
&gt;<i> writing the prototype patch.</i>
&gt;<i> </i>
&gt;<i>   crash&gt; kmem -n</i>
&gt;<i>   ...</i>
&gt;<i>   NR      SECTION        CODED_MEM_MAP        MEM_MAP       PFN</i>
&gt;<i>   ...</i>
&gt;<i>   23  ffff88043ffd82e0  ffffea0000000000  ffffea0002e00000  753664  ## There</i>
&gt;<i>   is a</i>
&gt;<i>   32  ffff88043ffd8400  ffffea0000000000  ffffea0004000000  1048576 ## hole</i>
&gt;<i>   here.</i>
&gt;<i>   ...</i>
&gt;<i>   crash&gt; kmem ffffea0002ffffc0  ## The last page struct of NR=23</i>
&gt;<i>   DEBUG: addr=0xffffea0002ffffc0 nr=23 accessible=1</i>
&gt;<i>   DEBUG: addr=0xffffea0002ffffc0 nr=23 accessible=1  ## in is_page_ptr()</i>
&gt;<i>   DEBUG: addr=0xffffea0002ffffc0 nr=23 accessible=1</i>
&gt;<i>   DEBUG: addr=0xffffea0002ffffc0 nr=23 accessible=1</i>
&gt;<i>         PAGE        PHYSICAL      MAPPING       INDEX CNT FLAGS</i>
&gt;<i>   ffffea0002ffffc0  bffff000                0        0  1 1fffff00000000</i>
&gt;<i>   crash&gt; kmem ffffea0003000000  ## A page address in a hole.</i>
&gt;<i>   kmem: WARNING: cannot make virtual-to-physical translation:</i>
&gt;<i>   ffffea0003000000</i>
&gt;<i>   DEBUG: addr=0xffffea0003000000 nr=24 accessible=0</i>
&gt;<i>   DEBUG: addr=0xffffea0003000000 nr=24 accessible=0  ## returned 0</i>
&gt;<i>   DEBUG: addr=0xffffea0003000000 nr=24 accessible=0</i>
&gt;<i>   ffffea0003000000: kernel virtual address not found in mem map</i>
&gt;<i> </i>
&gt;<i> I'm not sure whether there is the case that a page address does not</i>
&gt;<i> reference physical memory except for the above.  But originally,</i>
&gt;<i> since accessible() is readmem(), which actually reads a dump file,</i>
&gt;<i> it could return FALSE also due to some errors quietly, and this could</i>
&gt;<i> leads to a wrong judgement.</i>
&gt;<i> </i>
&gt;<i> And I had thought that if accessible() was valid for the page validity</i>
&gt;<i> test, there was no need to calculate its section.  So could it remove</i>
&gt;<i> the accessible() and continue to utilize the valid_section_nr() section</i>
&gt;<i> for the test like this?:</i>
&gt;<i> ---</i>
&gt;<i> diff --git a/defs.h b/defs.h</i>
&gt;<i> index aa17792..ab98cb7 100644</i>
&gt;<i> --- a/defs.h</i>
&gt;<i> +++ b/defs.h</i>
&gt;<i> @@ -3335,6 +3335,9 @@ struct arm64_stackframe {</i>
&gt;<i>  #define VTOP(X)               x86_64_VTOP((ulong)(X))</i>
&gt;<i>  #define IS_VMALLOC_ADDR(X)    x86_64_IS_VMALLOC_ADDR((ulong)(X))</i>
&gt;<i>  </i>
&gt;<i> +#define IS_VMEMMAP_PAGE_ADDR(X)  x86_64_IS_VMEMMAP_PAGE_ADDR((ulong)(X))</i>
&gt;<i> +#define VMEMMAP_PAGE_TO_PFN(X)   (((ulong)(X) - VMEMMAP_VADDR) / SIZE(page))</i>
&gt;<i> +</i>
&gt;<i>  /*</i>
&gt;<i>   * the default page table level for x86_64:</i>
&gt;<i>   *    4 level page tables</i>
&gt;<i> @@ -5646,6 +5649,7 @@ void x86_64_dump_machdep_table(ulong);</i>
&gt;<i>  ulong x86_64_PTOV(ulong);</i>
&gt;<i>  ulong x86_64_VTOP(ulong);</i>
&gt;<i>  int x86_64_IS_VMALLOC_ADDR(ulong);</i>
&gt;<i> +int x86_64_IS_VMEMMAP_PAGE_ADDR(ulong);</i>
&gt;<i>  void x86_64_display_idt_table(void);</i>
&gt;<i>  #define display_idt_table() x86_64_display_idt_table()</i>
&gt;<i>  long x86_64_exception_frame(ulong, ulong, char *, struct bt_info *, FILE *);</i>
&gt;<i> diff --git a/memory.c b/memory.c</i>
&gt;<i> index 0df8ecc..928c3c2 100644</i>
&gt;<i> --- a/memory.c</i>
&gt;<i> +++ b/memory.c</i>
&gt;<i> @@ -13350,6 +13350,30 @@ is_page_ptr(ulong addr, physaddr_t *phys)</i>
&gt;<i>  	physaddr_t section_paddr;</i>
&gt;<i>  </i>
&gt;<i>  	if (IS_SPARSEMEM()) {</i>
&gt;<i> +#ifdef IS_VMEMMAP_PAGE_ADDR</i>
&gt;<i> +		if (machdep-&gt;flags &amp; VMEMMAP) {</i>
&gt;<i> +			if (IS_VMEMMAP_PAGE_ADDR(addr)) {</i>
&gt;<i> +				nr = pfn_to_section_nr(VMEMMAP_PAGE_TO_PFN(addr));</i>
&gt;<i> +				if ((sec_addr = valid_section_nr(nr))) {</i>
&gt;<i> +					coded_mem_map = section_mem_map_addr(sec_addr);</i>
&gt;<i> +					mem_map = sparse_decode_mem_map(coded_mem_map, nr);</i>
&gt;<i> +					end_mem_map = mem_map + (PAGES_PER_SECTION() * SIZE(page));</i>
&gt;<i> +</i>
&gt;<i> +					if ((addr &gt;= mem_map) &amp;&amp; (addr &lt; end_mem_map)) {</i>
&gt;<i> +						if ((addr - mem_map) % SIZE(page))</i>
&gt;<i> +							return FALSE;</i>
&gt;<i> +						if (phys) {</i>
&gt;<i> +							section_paddr = PTOB(section_nr_to_pfn(nr));</i>
&gt;<i> +							pgnum = (addr - mem_map) / SIZE(page);</i>
&gt;<i> +							*phys = section_paddr + ((physaddr_t)pgnum * PAGESIZE());</i>
&gt;<i> +						}</i>
&gt;<i> +						return TRUE;</i>
&gt;<i> +					}</i>
&gt;<i> +				}</i>
&gt;<i> +			}</i>
&gt;<i> +			return FALSE;</i>
&gt;<i> +		}</i>
&gt;<i> +#endif</i>
&gt;<i>  		nr_mem_sections = NR_MEM_SECTIONS();</i>
&gt;<i>  	        for (nr = 0; nr &lt; nr_mem_sections ; nr++) {</i>
&gt;<i>  	                if ((sec_addr = valid_section_nr(nr))) {</i>
&gt;<i> diff --git a/x86_64.c b/x86_64.c</i>
&gt;<i> index 7449571..7240c5d 100644</i>
&gt;<i> --- a/x86_64.c</i>
&gt;<i> +++ b/x86_64.c</i>
&gt;<i> @@ -1570,6 +1570,14 @@ x86_64_IS_VMALLOC_ADDR(ulong vaddr)</i>
&gt;<i>  		(vaddr &gt;= VSYSCALL_START &amp;&amp; vaddr &lt; VSYSCALL_END));</i>
&gt;<i>  }</i>
&gt;<i>  </i>
&gt;<i> +int</i>
&gt;<i> +x86_64_IS_VMEMMAP_PAGE_ADDR(ulong vaddr)</i>
&gt;<i> +{</i>
&gt;<i> +	return ((machdep-&gt;flags &amp; VMEMMAP) &amp;&amp;</i>
&gt;<i> +		(vaddr &gt;= VMEMMAP_VADDR &amp;&amp; vaddr &lt;= VMEMMAP_END) &amp;&amp;</i>
&gt;<i> +		!((vaddr - VMEMMAP_VADDR) % SIZE(page)));</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i>  static int</i>
&gt;<i>  x86_64_is_module_addr(ulong vaddr)</i>
&gt;<i>  {</i>
&gt;<i> ---</i>
&gt;<i> </i>
&gt;<i> &gt; So if we don't want to change the functionality of is_page_ptr(), then maybe</i>
&gt;<i> &gt; the binary search would be a suitable compromise for both accuracy and speed</i>
&gt;<i> &gt; on extremely large systems?</i>
&gt;<i> </i>
&gt;<i> I have not considered it enough yet, but if all ranges of mem_sections are</i>
&gt;<i> ascending for section numbers and vmemmap holes like above are to be managed</i>
&gt;<i> well, it might be good.  (I'm guessing that the binary search might need an</i>
&gt;<i> auxiliary array or something due to the vmemmap holes..)</i>
&gt;<i> </i>
&gt;<i> Thanks,</i>
&gt;<i> Kazuhito Hagio</i>


This &quot;#ifdef IS_VMEMMAP_PAGE_ADDR&quot; patch is getting really ugly.  I've been
playing around with this, and this is my latest counter-proposal.

First, the mem_section numbers are ascending.  They may not necessarily start
with 0, and there may be holes, but they are ascending.  That being the case,
there is no need for is_page_ptr() to walk through NR_MEM_SECTIONS() worth
of entries, because there will be an ending number that's typically much
smaller.  Even on a 256GB dumpfile I have on hand, which has a NR_MEM_SECTIONS()
value of 524288, the largest valid section number is 2055. (What is the smallest
and largest number that you see on whatever large-memory system that you are 
testing with?)

In any case, let's store the largest section number during initialization in 
the vm_table, and use it as a delimeter in is_page_ptr().

diff --git a/defs.h b/defs.h
index aa17792..8768fd5 100644
--- a/defs.h
+++ b/defs.h
@@ -2369,6 +2369,7 @@ struct vm_table {                /* kernel VM-related data */
 		ulong mask;
 		char *name;
 	} *pageflags_data;
+	ulong max_mem_section_nr;
 };
 
 #define NODES                       (0x1)
diff --git a/memory.c b/memory.c
index 0df8ecc..6770937 100644
--- a/memory.c
+++ b/memory.c
@@ -255,7 +255,7 @@ static void PG_reserved_flag_init(void);
 static void PG_slab_flag_init(void);
 static ulong nr_blockdev_pages(void);
 void sparse_mem_init(void);
-void dump_mem_sections(void);
+void dump_mem_sections(int);
 void list_mem_sections(void);
 ulong sparse_decode_mem_map(ulong, ulong);
 char *read_mem_section(ulong);
@@ -13350,7 +13350,7 @@ is_page_ptr(ulong addr, physaddr_t *phys)
 	physaddr_t section_paddr;
 
 	if (IS_SPARSEMEM()) {
-		nr_mem_sections = NR_MEM_SECTIONS();
+		nr_mem_sections = vt-&gt;max_mem_section_nr+1;
 	        for (nr = 0; nr &lt; nr_mem_sections ; nr++) {
 	                if ((sec_addr = valid_section_nr(nr))) {
 	                        coded_mem_map = section_mem_map_addr(sec_addr);
@@ -13668,6 +13668,7 @@ dump_vm_table(int verbose)
 	fprintf(fp, &quot;   swap_info_struct: %lx\n&quot;, (ulong)vt-&gt;swap_info_struct);
 	fprintf(fp, &quot;            mem_sec: %lx\n&quot;, (ulong)vt-&gt;mem_sec);
 	fprintf(fp, &quot;        mem_section: %lx\n&quot;, (ulong)vt-&gt;mem_section);
+	fprintf(fp, &quot; max_mem_section_nr: %ld\n&quot;, vt-&gt;max_mem_section_nr);
 	fprintf(fp, &quot;       ZONE_HIGHMEM: %d\n&quot;, vt-&gt;ZONE_HIGHMEM);
 	fprintf(fp, &quot;node_online_map_len: %d\n&quot;, vt-&gt;node_online_map_len);
 	if (vt-&gt;node_online_map_len) {
@@ -16295,8 +16296,8 @@ dump_memory_nodes(int initialize)
 		vt-&gt;numnodes = n;
 	}
 
-	if (!initialize &amp;&amp; IS_SPARSEMEM())
-		dump_mem_sections();
+	if (IS_SPARSEMEM())
+		dump_mem_sections(initialize);
 }
 
 /*
@@ -17128,9 +17129,9 @@ pfn_to_map(ulong pfn)
 }
 
 void 
-dump_mem_sections(void)
+dump_mem_sections(int initialize)
 {
-	ulong nr,addr;
+	ulong nr, max, addr;
 	ulong nr_mem_sections;
 	ulong coded_mem_map, mem_map, pfn;
 	char buf1[BUFSIZE];
@@ -17140,6 +17141,15 @@ dump_mem_sections(void)
 
 	nr_mem_sections = NR_MEM_SECTIONS();
 
+	if (initialize) {
+		for (nr = max = 0; nr &lt; nr_mem_sections ; nr++) {
+			if (valid_section_nr(nr))
+				max = nr;
+		}
+		vt-&gt;max_mem_section_nr = max;
+		return;
+	}
+
 	fprintf(fp, &quot;\n&quot;);
 	pad_line(fp, BITS32() ? 59 : 67, '-');
         fprintf(fp, &quot;\n\nNR  %s  %s  %s  PFN\n&quot;,


Now, with respect to the architecture-specific, VMEMMAP-only, part
that is of most interest to you, let's do it with an architecture
specific callback.  You can post it for x86_64, and the other architecture
maintainers can write their own version.  For example, add a new
callback function to the machdep_table structure, i.e., like this:

  struct machdep_table {
          ulong flags;
          ulong kvbase;
  ...
          void (*get_irq_affinity)(int);
          void (*show_interrupts)(int, ulong *);
+         int is_page_ptr(ulong, physaddr_t *);
  };
  
Write the x86_64_is_page_ptr() function that works for VMEMMAP
kernels, and returns FALSE otherwise.  And add the call to the top 
of is_page_ptr() like this:

  int
  is_page_ptr(ulong addr, physaddr_t *phys)
  {
          int n;
          ulong ppstart, ppend;
          struct node_table *nt;
          ulong pgnum, node_size;
          ulong nr, sec_addr;
          ulong nr_mem_sections;
          ulong coded_mem_map, mem_map, end_mem_map;
          physaddr_t section_paddr;

+	  if (machdep-&gt;is_page_ptr(addr, phys))
+		  return TRUE;
  
          if (IS_SPARSEMEM()) {
  ...
  
To avoid having to check whether the machdep-&gt;is_page_ptr function
exists, write a generic_is_page_ptr() function that just returns
FALSE, and initialize machdep-&gt;is_page_ptr to generic_is_page_ptr in
the setup_environment() function.  Later on, individual architectures
can overwrite it when machdep_init(SETUP_ENV) is called.

How's that sound?

Dave

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="07345" href="msg07345.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</a></strong>
<ul><li><em>From:</em> Kazuhito Hagio</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="07320" href="msg07320.html">[PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing	is_page_ptr()</a></strong>
<ul><li><em>From:</em> k-hagio</li></ul></li>
<li><strong><a name="07321" href="msg07321.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by	optimizing	is_page_ptr()</a></strong>
<ul><li><em>From:</em> Dave Anderson</li></ul></li>
<li><strong><a name="07334" href="msg07334.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by	optimizing	is_page_ptr()</a></strong>
<ul><li><em>From:</em> Dave Anderson</li></ul></li>
<li><strong><a name="07335" href="msg07335.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</a></strong>
<ul><li><em>From:</em> Kazuhito Hagio</li></ul></li>
<li><strong><a name="07336" href="msg07336.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</a></strong>
<ul><li><em>From:</em> Dave Anderson</li></ul></li>
<li><strong><a name="07341" href="msg07341.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</a></strong>
<ul><li><em>From:</em> Kazuhito Hagio</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07341.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07343.html">[PATCH] crash/symbols: Error out earlier in case	_stext_vmlinux is NULL or UNINITIALIZED</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07341.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07345.html">Re:  [PATCH] Speed up &quot;kmem -[sS]&quot; by optimizing is_page_ptr()</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07342"><strong>Date</strong></a></li>
<li><a href="index.html#07342"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
