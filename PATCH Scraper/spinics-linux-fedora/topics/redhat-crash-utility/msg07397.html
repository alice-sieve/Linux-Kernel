<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH v2] vmware_vmss: read vCPUs regs and show	them in 'bt' -->
<!--X-From-R13: Eretvb Zbcrm &#60;fycNerqung.pbz> -->
<!--X-Date: Thu, 22 Mar 2018 04:12:08 &#45;0700 -->
<!--X-Message-Id: 20180322111155.32656&#45;1&#45;slp@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="[PATCH v2] vmware_vmss: read vCPUs regs and show	them in 'bt' &mdash; Red Hat Crash Utility">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Red Hat Crash Utility &mdash;  [PATCH v2] vmware_vmss: read vCPUs regs and show	them in 'bt'</title>
<link rel="alternate" type="application/rss+xml" title="Red Hat Crash Utility" href="//feeds.feedburner.com/RedHatCrashUtility">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH v2] vmware_vmss: read vCPUs regs and show	them in 'bt'</h1>
[<a href="msg07396.html">Date Prev</a>][<a href="msg07398.html">Date Next</a>][<a href="msg07391.html">Thread Prev</a>][<a href="msg07398.html">Thread Next</a>][<a href="maillist.html#07397">Date Index</a>][<a href="index.html#07397">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH v2] vmware_vmss: read vCPUs regs and show	them in 'bt'</li>
<li><em>From</em>: Sergio Lopez &lt;slp@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Thu, 22 Mar 2018 12:11:55 +0100</li>
<li><em>Reply-to</em>: &quot;Discussion list for crash utility usage,	maintenance and development&quot; &lt;crash-utility@xxxxxxxxxx&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>VMSS dump files contain the state of each vCPU at the time of suspending
the VM. This change enables 'crash' to read some relevant registers from
each vCPU state to display them in 'bt' and adds additional output for
commands 'help -D', 'help -r' and 'help -p'.

This is also the first step towards implementing kaslr offset
calculation for VMSS dump files.
---
 defs.h        |   5 +
 help.c        |   3 +
 kernel.c      |   2 +
 main.c        |   3 +
 memory.c      |   2 +
 vmware_vmss.c | 375 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 vmware_vmss.h |  31 +++++
 x86_64.c      |  13 +-
 8 files changed, 424 insertions(+), 10 deletions(-)

diff --git a/defs.h b/defs.h
index 7998ebf..44efc8a 100644
--- a/defs.h
+++ b/defs.h
@@ -283,6 +283,7 @@ struct number_option {
 #define LKCD_KERNTYPES()    (pc-&gt;flags &amp; KERNTYPES)
 #define KVMDUMP_DUMPFILE()  (pc-&gt;flags &amp; KVMDUMP)
 #define SADUMP_DUMPFILE()  (pc-&gt;flags &amp; SADUMP)
+#define VMSS_DUMPFILE()     (pc-&gt;flags &amp; VMWARE_VMSS)
 
 #define NETDUMP_LOCAL    (0x1)  /* netdump_data flags */
 #define NETDUMP_REMOTE   (0x2)  
@@ -6388,6 +6389,10 @@ int vmware_vmss_init(char *filename, FILE *ofp);
 uint vmware_vmss_page_size(void);
 int read_vmware_vmss(int, void *, int, ulong, physaddr_t);
 int write_vmware_vmss(int, void *, int, ulong, physaddr_t);
+void vmware_vmss_display_regs(int, FILE *);
+void get_vmware_vmss_regs(struct bt_info *, ulong *, ulong *);
+int vmware_vmss_memory_dump(FILE *);
+void dump_registers_for_vmss_dump(void);
 
 /*
  *  gnu_binutils.c
diff --git a/help.c b/help.c
index 5f6d9be..06b7961 100644
--- a/help.c
+++ b/help.c
@@ -710,6 +710,9 @@ dump_registers(void)
 	} else if (NETDUMP_DUMPFILE() || KDUMP_DUMPFILE()) {
 		dump_registers_for_elf_dumpfiles();
 		return;
+	} else if (VMSS_DUMPFILE()) {
+		dump_registers_for_vmss_dump();
+		return;
 	}
 
 	error(FATAL, &quot;-r option not supported on %s\n&quot;,
diff --git a/kernel.c b/kernel.c
index 1bf6251..7642217 100644
--- a/kernel.c
+++ b/kernel.c
@@ -2969,6 +2969,8 @@ back_trace(struct bt_info *bt)
 		get_xendump_regs(bt, &amp;eip, &amp;esp);
 	else if (SADUMP_DUMPFILE())
 		get_sadump_regs(bt, &amp;eip, &amp;esp);
+	else if (VMSS_DUMPFILE())
+		get_vmware_vmss_regs(bt, &amp;eip, &amp;esp);
         else if (REMOTE_PAUSED()) {
 		if (!is_task_active(bt-&gt;task) || !get_remote_regs(bt, &amp;eip, &amp;esp))
 			machdep-&gt;get_stack_frame(bt, &amp;eip, &amp;esp);
diff --git a/main.c b/main.c
index 2aae0c6..15834cb 100644
--- a/main.c
+++ b/main.c
@@ -1361,6 +1361,9 @@ dump_program_context(void)
         if (pc-&gt;flags &amp; DISKDUMP)
                 sprintf(&amp;buf[strlen(buf)],
                         &quot;%sDISKDUMP&quot;, others++ ? &quot;|&quot; : &quot;&quot;);
+        if (pc-&gt;flags &amp; VMWARE_VMSS)
+                sprintf(&amp;buf[strlen(buf)],
+                        &quot;%sVMWARE_VMSS&quot;, others++ ? &quot;|&quot; : &quot;&quot;);
         if (pc-&gt;flags &amp; SYSMAP)
                 sprintf(&amp;buf[strlen(buf)],
                         &quot;%sSYSMAP&quot;, others++ ? &quot;|&quot; : &quot;&quot;);
diff --git a/memory.c b/memory.c
index 0669276..9f752c2 100644
--- a/memory.c
+++ b/memory.c
@@ -16909,6 +16909,8 @@ dumpfile_memory(int cmd)
                         retval = kcore_memory_dump(fp);
 		else if (pc-&gt;flags &amp; SADUMP)
 			retval = sadump_memory_dump(fp);
+		else if (pc-&gt;flags &amp; VMWARE_VMSS)
+			retval = vmware_vmss_memory_dump(fp);
 		break;
 	
 	case DUMPFILE_ENVIRONMENT:
diff --git a/vmware_vmss.c b/vmware_vmss.c
index 667676a..a97a545 100644
--- a/vmware_vmss.c
+++ b/vmware_vmss.c
@@ -25,6 +25,8 @@
 #define VMW_PAGE_SIZE (4096)
 #define VMW_PAGE_SHIFT (12)
 
+#define MAX_BLOCK_DUMP (128)
+
 static vmssdata vmss = { 0 };
 
 int
@@ -128,7 +130,8 @@ vmware_vmss_init(char *filename, FILE *ofp)
 		DEBUG_PARSE_PRINT((ofp, LOGPRX&quot;Group: %-20s offset=%#llx size=0x%#llx.\n&quot;,
 				  grps[i].name, (ulonglong)grps[i].position, (ulonglong)grps[i].size));
 
-		if (strcmp(grps[i].name, &quot;memory&quot;) != 0) {
+		if (strcmp(grps[i].name, &quot;memory&quot;) != 0 &amp;&amp;
+		    (strcmp(grps[i].name, &quot;cpu&quot;) != 0 || !machine_type(&quot;X86_64&quot;))) {
 			continue;
 		}
 
@@ -198,12 +201,6 @@ vmware_vmss_init(char *filename, FILE *ofp)
 				}
 				blockpos += padsize;
 
-				if (fseek(fp, blockpos + nbytes, SEEK_SET) == -1) {
-					error(INFO, LOGPRX&quot;Cannot seek past block at %#llx.\n&quot;,
-					      (ulonglong)(blockpos + nbytes));
-					break;
-				}
-
 				if (strcmp(name, &quot;Memory&quot;) == 0) {
 					/* The things that we really care about...*/
 					vmss.memoffset = blockpos;
@@ -217,11 +214,44 @@ vmware_vmss_init(char *filename, FILE *ofp)
 						result = FALSE;
 						goto exit;
 					}
+
+					if (fseek(fp, blockpos + nbytes, SEEK_SET) == -1) {
+						error(INFO, LOGPRX&quot;Cannot seek past block at %#llx.\n&quot;,
+						      (ulonglong)(blockpos + nbytes));
+						break;
+					}
+				} else if (strcmp(name, &quot;gpregs&quot;) == 0 &amp;&amp;
+					   nbytes == VMW_GPREGS_SIZE &amp;&amp;
+					   idx[0] &lt; vmss.num_vcpus) {
+					int cpu = idx[0];
+
+					fread(vmss.regs64[cpu], nbytes, 1, fp);
+				} else if (strcmp(name, &quot;CR64&quot;) == 0 &amp;&amp;
+					   nbytes == VMW_CR64_SIZE &amp;&amp;
+					   idx[0] &lt; vmss.num_vcpus) {
+					int cpu = idx[0];
+
+					fread(&amp;vmss.regs64[cpu]-&gt;cr[0], nbytes, 1, fp);
+				} else if (strcmp(name, &quot;IDTR&quot;) == 0 &amp;&amp;
+					   nbytes == VMW_IDTR_SIZE &amp;&amp;
+					   idx[0] &lt; vmss.num_vcpus) {
+					int cpu = idx[0];
+					char buf[10];
+
+					fread(&amp;buf[0], nbytes, 1, fp);
+					vmss.regs64[cpu]-&gt;idtr = *((uint64_t *)(&amp;buf[0] + 2));
+				} else {
+					if (fseek(fp, blockpos + nbytes, SEEK_SET) == -1) {
+						error(INFO, LOGPRX&quot;Cannot seek past block at %#llx.\n&quot;,
+						      (ulonglong)(blockpos + nbytes));
+						break;
+					}
 				}
 			} else {
 				union {
 					uint8_t val[TAG_VALSIZE_MASK];
 					uint32_t val32;
+					uint64_t val64;
 				} u;
 				unsigned k;
 				unsigned valsize = TAG_VALSIZE(tag);
@@ -253,6 +283,30 @@ vmware_vmss_init(char *filename, FILE *ofp)
 					if (strcmp(name, &quot;align_mask&quot;) == 0) {
 						vmss.alignmask = u.val32;
 					}
+				} else if (strcmp(grps[i].name, &quot;cpu&quot;) == 0) {
+					if (strcmp(name, &quot;cpu:numVCPUs&quot;) == 0) {
+						if (vmss.regs64 != NULL) {
+							error(INFO, LOGPRX&quot;Duplicated cpu:numVCPUs entry.\n&quot;);
+							break;
+						}
+
+						vmss.num_vcpus = u.val32;
+						vmss.regs64 = malloc(vmss.num_vcpus * sizeof(void *));
+
+						for (k = 0; k &lt; vmss.num_vcpus; k++) {
+							vmss.regs64[k] = malloc(sizeof(vmssregs64));
+							memset(vmss.regs64[k], 0, sizeof(vmssregs64));
+						}
+					} else if (strcmp(name, &quot;rip&quot;) == 0) {
+						int cpu = idx[0];
+						vmss.regs64[cpu]-&gt;rip = u.val64;
+					} else if (strcmp(name, &quot;eflags&quot;) == 0) {
+						int cpu = idx[0];
+						vmss.regs64[cpu]-&gt;rflags |= u.val32;
+					} else if (strcmp(name, &quot;EFLAGS&quot;) == 0) {
+						int cpu = idx[0];
+						vmss.regs64[cpu]-&gt;rflags |= u.val32;
+					}
 				}
 
 				DEBUG_PARSE_PRINT((ofp, &quot;\n&quot;));
@@ -350,3 +404,310 @@ write_vmware_vmss(int fd, void *bufptr, int cnt, ulong addr, physaddr_t paddr)
 	return SEEK_ERROR;
 }
 
+void
+vmware_vmss_display_regs(int cpu, FILE *ofp)
+{
+	if (cpu &gt;= vmss.num_vcpus)
+		return;
+
+	if (machine_type(&quot;X86_64&quot;)) {
+		fprintf(ofp,
+		    &quot;	 RIP: %016llx  RSP: %016llx  RFLAGS: %08llx\n&quot;
+		    &quot;	 RAX: %016llx  RBX: %016llx  RCX: %016llx\n&quot;
+		    &quot;	 RDX: %016llx  RSI: %016llx  RDI: %016llx\n&quot;
+		    &quot;	 RBP: %016llx	R8: %016llx   R9: %016llx\n&quot;
+		    &quot;	 R10: %016llx  R11: %016llx  R12: %016llx\n&quot;
+		    &quot;	 R13: %016llx  R14: %016llx  R15: %016llx\n&quot;,
+		    vmss.regs64[cpu]-&gt;rip,
+		    vmss.regs64[cpu]-&gt;rsp,
+		    vmss.regs64[cpu]-&gt;rflags,
+		    vmss.regs64[cpu]-&gt;rax,
+		    vmss.regs64[cpu]-&gt;rbx,
+		    vmss.regs64[cpu]-&gt;rcx,
+		    vmss.regs64[cpu]-&gt;rdx,
+		    vmss.regs64[cpu]-&gt;rsi,
+		    vmss.regs64[cpu]-&gt;rdi,
+		    vmss.regs64[cpu]-&gt;rbp,
+		    vmss.regs64[cpu]-&gt;r8,
+		    vmss.regs64[cpu]-&gt;r9,
+		    vmss.regs64[cpu]-&gt;r10,
+		    vmss.regs64[cpu]-&gt;r11,
+		    vmss.regs64[cpu]-&gt;r12,
+		    vmss.regs64[cpu]-&gt;r13,
+		    vmss.regs64[cpu]-&gt;r14,
+		    vmss.regs64[cpu]-&gt;r15
+		);
+	}
+}
+
+void
+get_vmware_vmss_regs(struct bt_info *bt, ulong *ipp, ulong *spp)
+{
+	ulong ip, sp;
+	struct register_set *rp;
+
+	ip = sp = 0;
+
+	if (!is_task_active(bt-&gt;task)) {
+		machdep-&gt;get_stack_frame(bt, ipp, spp);
+		return;
+	}
+
+	bt-&gt;flags |= BT_DUMPFILE_SEARCH;
+	if (machine_type(&quot;X86_64&quot;))
+		machdep-&gt;get_stack_frame(bt, ipp, spp);
+	else if (machine_type(&quot;X86&quot;))
+		get_netdump_regs_x86(bt, ipp, spp);
+	if (bt-&gt;flags &amp; BT_DUMPFILE_SEARCH)
+		return;
+
+	if ((vmss.regs64 == NULL) ||
+	    (bt-&gt;tc-&gt;processor &gt;= vmss.num_vcpus))
+		return;
+
+	ip = (ulong)vmss.regs64[bt-&gt;tc-&gt;processor]-&gt;rip;
+	sp = (ulong)vmss.regs64[bt-&gt;tc-&gt;processor]-&gt;rsp;
+	if (is_kernel_text(ip) &amp;&amp;
+	    (((sp &gt;= GET_STACKBASE(bt-&gt;task)) &amp;&amp;
+	      (sp &lt; GET_STACKTOP(bt-&gt;task))) ||
+	     in_alternate_stack(bt-&gt;tc-&gt;processor, sp))) {
+		*ipp = ip;
+		*spp = sp;
+		bt-&gt;flags |= BT_KERNEL_SPACE;
+		return;
+	}
+
+	if (!is_kernel_text(ip) &amp;&amp;
+	    in_user_stack(bt-&gt;tc-&gt;task, sp))
+		bt-&gt;flags |= BT_USER_SPACE;
+}
+
+int
+vmware_vmss_memory_dump(FILE *fp)
+{
+	cptdumpheader hdr;
+	cptgroupdesc *grps = NULL;
+	unsigned grpsize;
+	unsigned i;
+	int result = TRUE;
+
+	if (fseek(vmss.dfp, 0, SEEK_SET) != 0) {
+		fprintf(fp, &quot;Error seeking to position 0.\n&quot;);
+		return FALSE;
+	}
+
+	if (fread(&amp;hdr, sizeof(cptdumpheader), 1, vmss.dfp) != 1) {
+		fprintf(fp, &quot;Failed to read vmss file: %s [Error %d] %s\n&quot;,
+			errno, strerror(errno));
+		return FALSE;
+	}
+
+	fprintf(fp, &quot;vmware_vmss:\n&quot;);
+	fprintf(fp, &quot;    Header: id=%x version=%d numgroups=%d\n&quot;,
+		hdr.id, hdr.version, hdr.numgroups);
+
+	vmss.cpt64bit = (hdr.id != CPTDUMP_OLD_MAGIC_NUMBER);
+	fprintf(fp, &quot;    Checkpoint is %d-bit\n&quot;, vmss.cpt64bit ? 64 : 32);
+
+	grpsize = hdr.numgroups * sizeof (cptgroupdesc);
+	grps = (cptgroupdesc *) malloc(grpsize * sizeof(cptgroupdesc));
+	if (grps == NULL) {
+		fprintf(fp, &quot;Failed to allocate memory! [Error %d] %s\n&quot;,
+			errno, strerror(errno));
+		return FALSE;
+	}
+
+	if (fread(grps, sizeof(cptgroupdesc), grpsize, vmss.dfp) != grpsize) {
+		fprintf(fp, &quot;Failed to read vmss file: [Error %d] %s\n&quot;,
+			errno, strerror(errno));
+		result = FALSE;
+		goto exit;
+	}
+
+	for (i = 0; i &lt; hdr.numgroups; i++) {
+		if (fseek(vmss.dfp, grps[i].position, SEEK_SET) == -1) {
+			fprintf(fp, &quot;Bad offset of VMSS Group['%s'] in vmss file at %#llx.\n&quot;,
+				grps[i].name, (ulonglong)grps[i].position);
+			continue;
+		}
+		fprintf(fp, &quot;\nGroup: %s offset=%#llx size=0x%#llx\n&quot;,
+			grps[i].name, (ulonglong)grps[i].position, (ulonglong)grps[i].size);
+
+		for (;;) {
+			uint16_t tag;
+			char name[TAG_NAMELEN_MASK + 1];
+			unsigned nameLen;
+			unsigned nindx;
+			int idx[3];
+			unsigned j;
+			int nextgroup = FALSE;
+
+			if (fread(&amp;tag, sizeof(tag), 1, vmss.dfp) != 1) {
+				fprintf(fp, &quot;Cannot read tag.\n&quot;);
+				break;
+			}
+			if (tag == NULL_TAG)
+				break;
+
+			nameLen = TAG_NAMELEN(tag);
+			if (fread(name, nameLen, 1, vmss.dfp) != 1) {
+				fprintf(fp, &quot;Cannot read tag name.\n&quot;);
+				break;
+			}
+			name[nameLen] = 0;
+			fprintf(fp, &quot;    Item %20s&quot;, name);
+
+			nindx = TAG_NINDX(tag);
+			if (nindx &gt; 3) {
+				fprintf(fp, &quot;Too many indexes %d (&gt; 3).\n&quot;, nindx);
+				break;
+			}
+			idx[0] = idx[1] = idx[2] = NO_INDEX;
+			for (j= 0; j &lt; 3; j++) {
+				if (j &lt; nindx) {
+					if (fread(&amp;idx[j], sizeof(idx[0]), 1, vmss.dfp) != 1) {
+						fprintf(fp, &quot;Cannot read index.\n&quot;);
+						nextgroup = TRUE;
+						break;
+					}
+					fprintf(fp, &quot;[%d]&quot;, idx[j]);
+				} else
+					fprintf(fp, &quot;   &quot;);
+			}
+		       if (nextgroup)
+				break;
+
+			if (IS_BLOCK_TAG(tag)) {
+				uint64_t nbytes;
+				uint64_t blockpos;
+				uint64_t nbytesinmem;
+				int compressed = IS_BLOCK_COMPRESSED_TAG(tag);
+				uint16_t padsize;
+				unsigned k, l;
+				char byte;
+
+				if (fread(&amp;nbytes, sizeof(nbytes), 1, vmss.dfp) != 1) {
+					fprintf(fp, &quot;Cannot read block size.\n&quot;);
+					break;
+				}
+				if (fread(&amp;nbytesinmem, sizeof(nbytesinmem), 1, vmss.dfp) != 1) {
+					fprintf(fp, &quot;Cannot read block memory size.\n&quot;);
+					break;
+				}
+				if (fread(&amp;padsize, sizeof(padsize), 1, vmss.dfp) != 1) {
+					fprintf(fp, &quot;Cannot read block padding size.\n&quot;);
+					break;
+				}
+				if ((blockpos = ftell(vmss.dfp)) == -1) {
+					fprintf(fp, &quot;Cannot determine location within VMSS file.\n&quot;);
+					break;
+				}
+				blockpos += padsize;
+
+				fprintf(fp, &quot; =&gt; %sBLOCK: position=%#llx size=%#llx memsize=%#llx\n&quot;,
+					compressed ? &quot;COMPRESSED &quot; : &quot;&quot;,
+					(ulonglong)blockpos, (ulonglong)nbytes, (ulonglong)nbytesinmem);
+
+				if (nbytes &amp;&amp; nbytes &lt;= MAX_BLOCK_DUMP &amp;&amp; !compressed) {
+					fprintf(fp, &quot;Hex dump: \n&quot;);
+					l = 0;
+					for (k = 0; k &lt; nbytes; k++) {
+						if (fread(&amp;byte, 1, 1, vmss.dfp) != 1) {
+							fprintf(fp, &quot;Cannot read byte.\n&quot;);
+							result = FALSE;
+							goto exit;
+						}
+
+						fprintf(fp, &quot; %02hhX&quot;, byte);
+
+						if (l++ == 15) {
+							fprintf(fp, &quot;\n&quot;);
+							l = 0;
+						}
+					}
+					if (l)
+						fprintf(fp, &quot;\n\n&quot;);
+					else
+						fprintf(fp, &quot;\n&quot;);
+				} else {
+					if (fseek(vmss.dfp, blockpos + nbytes, SEEK_SET) == -1) {
+						fprintf(fp, &quot;Cannot seek past block at %#llx.\n&quot;,
+							(ulonglong)(blockpos + nbytes));
+						result = FALSE;
+						goto exit;
+					}
+				}
+			} else {
+				union {
+					uint8_t val[TAG_VALSIZE_MASK];
+					uint32_t val32;
+					uint64_t val64;
+				} u;
+				unsigned k;
+				unsigned valsize = TAG_VALSIZE(tag);
+				uint64_t blockpos = ftell(vmss.dfp);
+
+				fprintf(fp, &quot; =&gt; position=%#llx size=%#x: &quot;,
+					(ulonglong)blockpos, valsize);
+
+				if (fread(u.val, sizeof(u.val[0]), valsize, vmss.dfp) != valsize) {
+					fprintf(fp, &quot;Cannot read item.\n&quot;);
+					break;
+				}
+				for (k = 0; k &lt; valsize; k++) {
+					/* Assume Little Endian */
+					fprintf(fp, &quot;%02X&quot;, u.val[valsize - k - 1]);
+				}
+
+
+				fprintf(fp, &quot;\n&quot;);
+			}
+		}
+	}
+
+exit:
+	if (grps)
+		free(grps);
+
+	return result;
+}
+
+void
+dump_registers_for_vmss_dump(void)
+{
+	int i;
+	vmssregs64 *regs;
+
+	if (!machine_type(&quot;X86_64&quot;)) {
+		fprintf(fp, &quot;-r option not supported on this dumpfile type\n&quot;);
+		return;
+	}
+
+	for (i = 0; i &lt; vmss.num_vcpus; i++) {
+		regs = vmss.regs64[i];
+
+		if (i)
+			fprintf(fp, &quot;\n&quot;);
+
+		fprintf(fp, &quot;CPU %d:\n&quot;, i);
+
+		fprintf(fp, &quot;  RAX: %016llx  RBX: %016llx  RCX: %016llx\n&quot;,
+			regs-&gt;rax, regs-&gt;rbx, regs-&gt;rcx);
+		fprintf(fp, &quot;  RDX: %016llx  RSI: %016llx  RDI: %016llx\n&quot;,
+			regs-&gt;rdx, regs-&gt;rsi, regs-&gt;rdi);
+		fprintf(fp, &quot;  RSP: %016llx  RBP: %016llx  R8:  %016llx\n&quot;,
+			regs-&gt;rsp, regs-&gt;rbp, regs-&gt;r8);
+		fprintf(fp, &quot;   R9: %016llx  R10: %016llx  R11: %016llx\n&quot;,
+			regs-&gt;r9, regs-&gt;r10, regs-&gt;r11);
+		fprintf(fp, &quot;  R12: %016llx  R13: %016llx  R14: %016llx\n&quot;,
+			regs-&gt;r12, regs-&gt;r13, regs-&gt;r14);
+		fprintf(fp, &quot;  R15: %016llx  RIP: %016llx  RFLAGS: %08llx\n&quot;,
+			regs-&gt;r15, regs-&gt;rip, regs-&gt;rflags);
+		fprintf(fp, &quot;  IDT: base: %016llx\n&quot;,
+                        regs-&gt;idtr);
+                fprintf(fp, &quot;  CR0: %016llx  CR1: %016llx  CR2: %016llx\n&quot;,
+			regs-&gt;cr[0], regs-&gt;cr[1], regs-&gt;cr[2]);
+		fprintf(fp, &quot;  CR3: %016llx  CR4: %016llx\n&quot;,
+			regs-&gt;cr[3], regs-&gt;cr[4]);
+	}
+}
diff --git a/vmware_vmss.h b/vmware_vmss.h
index a4b8937..41d14c3 100644
--- a/vmware_vmss.h
+++ b/vmware_vmss.h
@@ -89,6 +89,35 @@ struct memregion {
 };
 typedef struct memregion	memregion;
 
+#define VMW_GPREGS_SIZE (128)
+#define VMW_CR64_SIZE (72)
+#define VMW_IDTR_SIZE (10)
+struct vmssregs64 {
+	/* read from vmss */
+	uint64_t	rax;
+	uint64_t	rcx;
+	uint64_t	rdx;
+	uint64_t	rbx;
+	uint64_t	rbp;
+	uint64_t	rsp;
+	uint64_t	rsi;
+	uint64_t	rdi;
+	uint64_t	r8;
+	uint64_t	r9;
+	uint64_t	r10;
+	uint64_t	r11;
+	uint64_t	r12;
+	uint64_t	r13;
+	uint64_t	r14;
+	uint64_t	r15;
+	/* manually managed */
+	uint64_t	idtr;
+	uint64_t	cr[VMW_CR64_SIZE / 8];
+	uint64_t	rip;
+	uint64_t	rflags;
+};
+typedef struct vmssregs64 vmssregs64;
+
 #define MAX_REGIONS	3
 struct vmssdata {
 	int32_t	cpt64bit;
@@ -99,6 +128,8 @@ struct vmssdata {
         memregion	regions[MAX_REGIONS];
 	uint64_t	memoffset;
 	uint64_t	memsize;
+	uint64_t	num_vcpus;
+	vmssregs64	**regs64;
 };
 typedef struct vmssdata vmssdata;
 
diff --git a/x86_64.c b/x86_64.c
index 0d5e150..7b02761 100644
--- a/x86_64.c
+++ b/x86_64.c
@@ -3273,6 +3273,8 @@ x86_64_low_budget_back_trace_cmd(struct bt_info *bt_in)
 			diskdump_display_regs(bt-&gt;tc-&gt;processor, ofp);
 		else if (SADUMP_DUMPFILE())
 			sadump_display_regs(bt-&gt;tc-&gt;processor, ofp);
+		else if (VMSS_DUMPFILE())
+			vmware_vmss_display_regs(bt-&gt;tc-&gt;processor, ofp);
 		return;
 	}
 
@@ -3295,13 +3297,16 @@ x86_64_low_budget_back_trace_cmd(struct bt_info *bt_in)
 			diskdump_display_regs(bt-&gt;tc-&gt;processor, ofp);
 		else if (SADUMP_DUMPFILE())
 			sadump_display_regs(bt-&gt;tc-&gt;processor, ofp);
+		else if (VMSS_DUMPFILE())
+			vmware_vmss_display_regs(bt-&gt;tc-&gt;processor, ofp);
 		else if (pc-&gt;flags2 &amp; QEMU_MEM_DUMP_ELF)
 			display_regs_from_elf_notes(bt-&gt;tc-&gt;processor, ofp);
 		return;
 	} else if ((bt-&gt;flags &amp; BT_KERNEL_SPACE) &amp;&amp;
 		   (KVMDUMP_DUMPFILE() ||
 		    (ELF_NOTES_VALID() &amp;&amp; DISKDUMP_DUMPFILE()) ||
-		    SADUMP_DUMPFILE() || (pc-&gt;flags2 &amp; QEMU_MEM_DUMP_ELF))) {
+		    SADUMP_DUMPFILE() || (pc-&gt;flags2 &amp; QEMU_MEM_DUMP_ELF) ||
+		    VMSS_DUMPFILE())) {
 		fprintf(ofp, &quot;    [exception RIP: &quot;);
 		if ((sp = value_search(bt-&gt;instptr, &amp;offset))) {
 			fprintf(ofp, &quot;%s&quot;, sp-&gt;name);
@@ -3317,6 +3322,8 @@ x86_64_low_budget_back_trace_cmd(struct bt_info *bt_in)
 			diskdump_display_regs(bt-&gt;tc-&gt;processor, ofp);
 		else if (SADUMP_DUMPFILE())
 			sadump_display_regs(bt-&gt;tc-&gt;processor, ofp);
+		else if (VMSS_DUMPFILE())
+			vmware_vmss_display_regs(bt-&gt;tc-&gt;processor, ofp);
 		else if (pc-&gt;flags2 &amp; QEMU_MEM_DUMP_ELF)
 			display_regs_from_elf_notes(bt-&gt;tc-&gt;processor, ofp);
 
@@ -4941,7 +4948,7 @@ skip_stage:
 	if (halt_rip &amp;&amp; halt_rsp) {
         	*rip = halt_rip;
 		*rsp = halt_rsp;
-		if (KVMDUMP_DUMPFILE() || SADUMP_DUMPFILE())
+		if (KVMDUMP_DUMPFILE() || SADUMP_DUMPFILE() || VMSS_DUMPFILE())
 			bt_in-&gt;flags &amp;= ~(ulonglong)BT_DUMPFILE_SEARCH;
 		return;
 	}
@@ -4986,7 +4993,7 @@ skip_stage:
 
         machdep-&gt;get_stack_frame(bt, rip, rsp);
 
-	if (KVMDUMP_DUMPFILE() || SADUMP_DUMPFILE())
+	if (KVMDUMP_DUMPFILE() || SADUMP_DUMPFILE() || VMSS_DUMPFILE())
 		bt_in-&gt;flags &amp;= ~(ulonglong)BT_DUMPFILE_SEARCH;
 }
 
-- 
2.14.3

--
Crash-utility mailing list
Crash-utility@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/crash-utility">https://www.redhat.com/mailman/listinfo/crash-utility</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="07398" href="msg07398.html">Re:  [PATCH v2] vmware_vmss: read vCPUs regs and	show them in 'bt'</a></strong>
<ul><li><em>From:</em> Dave Anderson</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg07396.html">Re:  [PATCH v3 1/4] Move kaslr related functions from	sadump.c to kaslr_helper.c</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg07398.html">Re:  [PATCH v2] vmware_vmss: read vCPUs regs and	show them in 'bt'</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg07391.html">[PATCH] vmware_vmss: read vCPUs regs and show them	in 'bt'</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg07398.html">Re:  [PATCH v2] vmware_vmss: read vCPUs regs and	show them in 'bt'</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#07397"><strong>Date</strong></a></li>
<li><a href="index.html#07397"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-devel/>[Fedora&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-tools/>[Fedora&nbsp;Tools]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td align=left>&nbsp;</td>
<td valign=top align=right><H1><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></H1></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
