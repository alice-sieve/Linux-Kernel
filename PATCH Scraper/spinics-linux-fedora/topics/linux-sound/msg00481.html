<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier -->
<!--X-From-R13: Tryvcr Pnyov &#60;onyovNgv.pbz> -->
<!--X-Date: Wed, 2 Jul 2014 07:10:40 &#45;0700 -->
<!--X-Message-Id: 20140702141001.GA5541@saruman.home -->
<!--X-Content-Type: multipart/signed -->
<!--X-Reference: 1404307852&#45;10456&#45;1&#45;git&#45;send&#45;email&#45;dmurphy@ti.com -->
<!--X-Derived: pgpBmI1zljj1k.pgp -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Sound: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Sound &mdash; Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</title>
<link rel="alternate" type="application/rss+xml" title="Linux Sound" href="//feeds.feedburner.com/LinuxSound">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:6612422167" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</h1>
[<a href="msg00480.html">Date Prev</a>][<a href="msg00482.html">Date Next</a>][<a href="msg00488.html">Thread Prev</a>][<a href="msg00482.html">Thread Next</a>][<a href="maillist.html#00481">Date Index</a>][<a href="index.html#00481">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</li>
<li><em>From</em>: Felipe Balbi &lt;<a href="mailto:balbi@DOMAIN.HIDDEN">balbi@xxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 2 Jul 2014 09:10:02 -0500</li>
<li><em>Cc</em>: &lt;<a href="mailto:linux-sound@DOMAIN.HIDDEN">linux-sound@xxxxxxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:linux-kernel@DOMAIN.HIDDEN">linux-kernel@xxxxxxxxxxxxxxx</a>&gt;,        &lt;<a href="mailto:alsa-devel@DOMAIN.HIDDEN">alsa-devel@xxxxxxxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:broonie@DOMAIN.HIDDEN">broonie@xxxxxxxxxx</a>&gt;,        &lt;<a href="mailto:devicetree@DOMAIN.HIDDEN">devicetree@xxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg00479.html">1404307852-10456-1-git-send-email-dmurphy@ti.com</a>&gt;</li>
<li><em>Reply-to</em>: &lt;<a href="mailto:balbi@DOMAIN.HIDDEN">balbi@xxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.5.23 (2014-03-12)</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Hi,

On Wed, Jul 02, 2014 at 08:30:52AM -0500, Dan Murphy wrote:
&gt; Support the TI TAS2552 Class D amplifier.
&gt; 
&gt; The TAS2552 is a high efficiency Class-D audio
&gt; power amplifier with advanced battery current
&gt; management and an integrated Class-G boost
&gt; The device constantly measures the
&gt; current and voltage across the load and provides a
&gt; digital stream of this information.
&gt; 
&gt; Signed-off-by: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt; ---
&gt; 
&gt; v3 - Updated bindings doc per comments, rearranged probe pdata vs 
&gt; np check - <a  rel="nofollow" href="https://patchwork.kernel.org/patch/4453481/">https://patchwork.kernel.org/patch/4453481/</a>
&gt; 
&gt;  .../devicetree/bindings/sound/tas2552.txt          |   22 +
&gt;  include/sound/tas2552-plat.h                       |   25 ++
&gt;  sound/soc/codecs/Kconfig                           |    5 +
&gt;  sound/soc/codecs/Makefile                          |    2 +
&gt;  sound/soc/codecs/tas2552.c                         |  463 ++++++++++++++++++++
&gt;  sound/soc/codecs/tas2552.h                         |   75 ++++
&gt;  6 files changed, 592 insertions(+)
&gt;  create mode 100644 Documentation/devicetree/bindings/sound/tas2552.txt
&gt;  create mode 100644 include/sound/tas2552-plat.h
&gt;  create mode 100644 sound/soc/codecs/tas2552.c
&gt;  create mode 100644 sound/soc/codecs/tas2552.h
&gt; 
&gt; diff --git a/Documentation/devicetree/bindings/sound/tas2552.txt b/Documentation/devicetree/bindings/sound/tas2552.txt
&gt; new file mode 100644
&gt; index 0000000..ada8fd4
&gt; --- /dev/null
&gt; +++ b/Documentation/devicetree/bindings/sound/tas2552.txt
&gt; @@ -0,0 +1,22 @@
&gt; +Texas Instruments - tas2552 Codec module
&gt; +
&gt; +The tas2552 serial control bus communicates through I2C protocols
&gt; +
&gt; +Required properties:
&gt; +
&gt; +- compatible - One of:
&gt; +    &quot;ti,tas2552&quot; - TAS2552
&gt; +
&gt; +- reg -  I2C slave address
&gt; +
&gt; +Optional properties:
&gt; +
&gt; +- power-gpio - gpio pin to enable/disable the device
&gt; +
&gt; +Example:
&gt; +
&gt; +tas2552: tas2552@41 {
&gt; +	compatible = &quot;ti,tas2552&quot;;
&gt; +	reg = &lt;0x41&gt;;
&gt; +	enable-gpio = &lt;&amp;gpio4 2 GPIO_ACTIVE_HIGH&gt;;

you probably want to add:

	pvdd-supply = &lt;&amp;pvdd&gt;;
	vbat-supply = &lt;&amp;vbat&gt;;
	avdd-supply = &lt;&amp;avdd&gt;;
	iovdd-supply = &lt;&amp;iovdd&gt;;

that way you can make sure to switch your regulators on from the driver.
Since they must be all on, you can just grab them all with
regulator_bulk_get() and enable them all with regulator_bulk_enable().

Also, I wonder if it makes sense to add a link to [1] here.

[1] <a  rel="nofollow" href="http://www.ti.com/product/TAS2552">http://www.ti.com/product/TAS2552</a>

&gt; +};
&gt; diff --git a/include/sound/tas2552-plat.h b/include/sound/tas2552-plat.h
&gt; new file mode 100644
&gt; index 0000000..65e7627
&gt; --- /dev/null
&gt; +++ b/include/sound/tas2552-plat.h

platform-data is usually placed under include/linux/platform_data/

&gt; @@ -0,0 +1,25 @@
&gt; +/*
&gt; + * TAS2552 driver platform header
&gt; + *
&gt; + * Copyright (C) 2014 Texas Instruments Inc.
&gt; + *
&gt; + * Author: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt; + *
&gt; + * This program is free software; you can redistribute it and/or
&gt; + * modify it under the terms of the GNU General Public License
&gt; + * version 2 as published by the Free Software Foundation.
&gt; + *
&gt; + * This program is distributed in the hope that it will be useful, but
&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of
&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&gt; + * General Public License for more details.
&gt; + */
&gt; +
&gt; +#ifndef TAS2552_PLAT_H
&gt; +#define TAS2552_PLAT_H
&gt; +
&gt; +struct tas2552_platform_data {
&gt; +	int enable_gpio;
&gt; +};
&gt; +
&gt; +#endif
&gt; diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
&gt; index 0b9571c..cc09261 100644
&gt; --- a/sound/soc/codecs/Kconfig
&gt; +++ b/sound/soc/codecs/Kconfig
&gt; @@ -99,6 +99,7 @@ config SND_SOC_ALL_CODECS
&gt;  	select SND_SOC_TLV320AIC32X4 if I2C
&gt;  	select SND_SOC_TLV320AIC3X if I2C
&gt;  	select SND_SOC_TPA6130A2 if I2C
&gt; +	select SND_SOC_TAS2552 if I2C
&gt;  	select SND_SOC_TLV320DAC33 if I2C
&gt;  	select SND_SOC_TWL4030 if TWL4030_CORE
&gt;  	select SND_SOC_TWL6040 if TWL6040_CORE
&gt; @@ -754,4 +755,8 @@ config SND_SOC_TPA6130A2
&gt;  	tristate &quot;Texas Instruments TPA6130A2 headphone amplifier&quot;
&gt;  	depends on I2C
&gt;  
&gt; +config SND_SOC_TAS2552
&gt; +	tristate &quot;Texas Instruments TAS2552 Mono Audio amplifier&quot;
&gt; +	depends on I2C
&gt; +
&gt;  endmenu
&gt; diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
&gt; index 1bd6e1c..33bc7228 100644
&gt; --- a/sound/soc/codecs/Makefile
&gt; +++ b/sound/soc/codecs/Makefile
&gt; @@ -162,6 +162,7 @@ snd-soc-wm-hubs-objs := wm_hubs.o
&gt;  # Amp
&gt;  snd-soc-max9877-objs := max9877.o
&gt;  snd-soc-tpa6130a2-objs := tpa6130a2.o
&gt; +snd-soc-tas2552-objs := tas2552.o
&gt;  
&gt;  obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
&gt;  obj-$(CONFIG_SND_SOC_AB8500_CODEC)	+= snd-soc-ab8500-codec.o
&gt; @@ -325,3 +326,4 @@ obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
&gt;  # Amp
&gt;  obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
&gt;  obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
&gt; +obj-$(CONFIG_SND_SOC_TAS2552)	+= snd-soc-tas2552.o
&gt; diff --git a/sound/soc/codecs/tas2552.c b/sound/soc/codecs/tas2552.c
&gt; new file mode 100644
&gt; index 0000000..79b8212
&gt; --- /dev/null
&gt; +++ b/sound/soc/codecs/tas2552.c
&gt; @@ -0,0 +1,463 @@
&gt; +/*
&gt; + * ALSA SoC Texas Instruments TAS2552 Mono Audio Amplifier
&gt; + *
&gt; + * Copyright (C) 2014 Texas Instruments Inc.
&gt; + *
&gt; + * Author: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt; + *
&gt; + * This program is free software; you can redistribute it and/or
&gt; + * modify it under the terms of the GNU General Public License
&gt; + * version 2 as published by the Free Software Foundation.
&gt; + *
&gt; + * This program is distributed in the hope that it will be useful, but
&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of
&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&gt; + * General Public License for more details.
&gt; + */
&gt; +
&gt; +#include &lt;linux/module.h&gt;
&gt; +#include &lt;linux/errno.h&gt;
&gt; +#include &lt;linux/device.h&gt;
&gt; +#include &lt;linux/i2c.h&gt;
&gt; +#include &lt;linux/gpio.h&gt;
&gt; +#include &lt;linux/of_gpio.h&gt;
&gt; +#include &lt;linux/regmap.h&gt;
&gt; +#include &lt;linux/slab.h&gt;
&gt; +
&gt; +#include &lt;sound/pcm.h&gt;
&gt; +#include &lt;sound/pcm_params.h&gt;
&gt; +#include &lt;sound/soc.h&gt;
&gt; +#include &lt;sound/soc-dapm.h&gt;
&gt; +#include &lt;sound/tlv.h&gt;
&gt; +#include &lt;sound/tas2552-plat.h&gt;
&gt; +
&gt; +#include &quot;tas2552.h&quot;
&gt; +
&gt; +static struct reg_default tas2552_reg_defs[] = {
&gt; +	{TAS2552_CFG_1, 0x16},
&gt; +	{TAS2552_CFG_3, 0x5E},
&gt; +	{TAS2552_DOUT, 0x00},
&gt; +	{TAS2552_OUTPUT_DATA, 0xC8},
&gt; +	{TAS2552_PDM_CFG, 0x02},
&gt; +	{TAS2552_PGA_GAIN, 0x10},
&gt; +	{TAS2552_BOOST_PT_CTRL, 0x0F},
&gt; +	{TAS2552_LIMIT_LVL_CTRL, 0x0C},
&gt; +	{TAS2552_LIMIT_RATE_HYS, 0x20},
&gt; +	{TAS2552_CFG_2, 0xEA},
&gt; +	{TAS2552_SER_CTRL_1, 0x00},
&gt; +	{TAS2552_SER_CTRL_2, 0x00},
&gt; +	{TAS2552_PLL_CTRL_1, 0x10},
&gt; +	{TAS2552_PLL_CTRL_2, 0x00},
&gt; +	{TAS2552_PLL_CTRL_3, 0x00},
&gt; +	{TAS2552_BTIP, 0x8f},
&gt; +	{TAS2552_BTS_CTRL, 0x80},
&gt; +	{TAS2552_LIMIT_RELEASE, 0x05},
&gt; +	{TAS2552_LIMIT_INT_COUNT, 0x00},
&gt; +	{TAS2552_EDGE_RATE_CTRL, 0x40},
&gt; +	{TAS2552_VBAT_DATA, 0x00},
&gt; +};
&gt; +
&gt; +struct tas2552_data {
&gt; +	struct mutex mutex;
&gt; +	struct snd_soc_codec *codec;
&gt; +	struct regmap *regmap;
&gt; +	struct i2c_client *tas2552_client;
&gt; +	unsigned char regs[TAS2552_VBAT_DATA];
&gt; +	int power_gpio;
&gt; +	u8 power_state:1;
&gt; +};
&gt; +
&gt; +static int tas2552_power(struct tas2552_data *data, u8 power)
&gt; +{
&gt; +	int	ret = 0;
&gt; +
&gt; +	BUG_ON(data-&gt;tas2552_client == NULL);

don't hang the entire machine because of a bug on the amplifier driver,
WARN() should be enough, followed by the return of an error code.

In fact, is this really necessary ? It would be a simple bug on the
driver to fix.

&gt; +
&gt; +	mutex_lock(&amp;data-&gt;mutex);
&gt; +	if (power == data-&gt;power_state)

Same here. Is this really necessary ? It's simple to guarantee this case
won't happen in code.

&gt; +		goto exit;
&gt; +
&gt; +	if (power) {
&gt; +		if (data-&gt;power_gpio &gt;= 0)
&gt; +			gpio_set_value(data-&gt;power_gpio, 1);
&gt; +
&gt; +		data-&gt;power_state = 1;
&gt; +	} else {
&gt; +		if (data-&gt;power_gpio &gt;= 0)
&gt; +			gpio_set_value(data-&gt;power_gpio, 0);
&gt; +
&gt; +		data-&gt;power_state = 0;
&gt; +	}
&gt; +
&gt; +exit:
&gt; +	mutex_unlock(&amp;data-&gt;mutex);
&gt; +	return ret;
&gt; +}
&gt; +
&gt; +static void tas2552_sw_shutdown(struct tas2552_data *tas_data, int sw_shutdown)
&gt; +{
&gt; +	u8 cfg1_reg = 0x0;
&gt; +
&gt; +	if (sw_shutdown)
&gt; +		cfg1_reg |= (sw_shutdown &lt;&lt; 1);

this line is dangerous. You're using a 32-bit variable to write a single
bit on cfg1 register. What if user passes 0xff on sw_shutdown ?

I think a better approach would be to:

a) first of all, move this sw_shutdown function to
runtime_suspend/runtime_resume.

b) to the check as below:

	if (shutdown)
		cfg1_reg |= TAS2552_SWS;
	else
		cfg1_reg &amp;= ~TAS2552_SWS;

then, of course #define TAS2552_SWS (1 &lt;&lt; 1) (or BIT(1), even)

&gt; +	else
&gt; +		cfg1_reg &amp;= ~TAS2552_SWS_MASK;
&gt; +
&gt; +	snd_soc_update_bits(tas_data-&gt;codec, TAS2552_CFG_1,
&gt; +						 TAS2552_SWS_MASK, cfg1_reg);
&gt; +}
&gt; +
&gt; +static void tas2552_init(struct snd_soc_codec *codec)
&gt; +{
&gt; +	snd_soc_write(codec, TAS2552_CFG_1, 0x16);
&gt; +	snd_soc_write(codec, TAS2552_CFG_3, 0x5E);
&gt; +	snd_soc_write(codec, TAS2552_DOUT, 0x00);
&gt; +	snd_soc_write(codec, TAS2552_OUTPUT_DATA, 0xC8);
&gt; +	snd_soc_write(codec, TAS2552_PDM_CFG, 0x02);
&gt; +	snd_soc_write(codec, TAS2552_PGA_GAIN, 0x10);
&gt; +	snd_soc_write(codec, TAS2552_BOOST_PT_CTRL, 0x0F);
&gt; +	snd_soc_write(codec, TAS2552_LIMIT_LVL_CTRL, 0x0C);
&gt; +	snd_soc_write(codec, TAS2552_LIMIT_RATE_HYS, 0x20);
&gt; +	snd_soc_write(codec, TAS2552_CFG_2, 0xEA);

what do all these magic constants mean ? Also, lower case hex numbers
are usually preferred.

No battery tracking ?  Any plans to add that at a later date ? It's
probably not needed to have functional audio, but might have some use
cases where you want it.

/* goes re-read datasheet */

Actually, I strongly believe you want to enable battery tracking (LIM_EN
on cfg2).

&gt; +}
&gt; +
&gt; +static int tas2552_hw_params(struct snd_pcm_substream *substream,
&gt; +			     struct snd_pcm_hw_params *params,
&gt; +			     struct snd_soc_dai *dai)
&gt; +{
&gt; +	u8 wclk_reg;
&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; +
&gt; +	/* Setting DAC clock dividers based on substream sample rate. */
&gt; +	switch (params_rate(params)) {
&gt; +	case 8000:
&gt; +		wclk_reg = TAS2552_8KHZ;
&gt; +		break;
&gt; +	case 11025:
&gt; +		wclk_reg = TAS2552_11_12KHZ;
&gt; +		break;
&gt; +	case 16000:
&gt; +		wclk_reg = TAS2552_16KHZ;
&gt; +		break;
&gt; +	case 32000:
&gt; +		wclk_reg = TAS2552_32KHZ;
&gt; +		break;
&gt; +	case 22050:
&gt; +	case 24000:
&gt; +		wclk_reg = TAS2552_22_24KHZ;
&gt; +		break;
&gt; +	case 44100:
&gt; +	case 48000:
&gt; +		wclk_reg = TAS2552_44_48KHZ;
&gt; +		break;
&gt; +	case 96000:
&gt; +		wclk_reg = TAS2552_88_96KHZ;
&gt; +		break;
&gt; +	default:

might be worth adding a dev_vdbg() here.

&gt; +		return -EINVAL;
&gt; +	}
&gt; +
&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_3, TAS2552_WCLK_MASK, wclk_reg);
&gt; +
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static int tas2552_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
&gt; +{
&gt; +	u8 serial_format;
&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; +
&gt; +	switch (fmt &amp; SND_SOC_DAIFMT_MASTER_MASK) {
&gt; +	case SND_SOC_DAIFMT_CBS_CFS:
&gt; +		serial_format = 0x00;
&gt; +		break;
&gt; +	case SND_SOC_DAIFMT_CBS_CFM:
&gt; +		serial_format = TAS2552_WORD_CLK_MASK;
&gt; +		break;
&gt; +	case SND_SOC_DAIFMT_CBM_CFS:
&gt; +		serial_format = TAS2552_BIT_CLK_MASK;
&gt; +		break;
&gt; +	case SND_SOC_DAIFMT_CBM_CFM:
&gt; +		serial_format = (TAS2552_BIT_CLK_MASK | TAS2552_WORD_CLK_MASK);
&gt; +		break;
&gt; +	default:
&gt; +		return -EINVAL;
&gt; +	}
&gt; +
&gt; +	snd_soc_update_bits(codec, TAS2552_SER_CTRL_1,
&gt; +			    (TAS2552_BIT_CLK_MASK | TAS2552_WORD_CLK_MASK),
&gt; +			    serial_format);
&gt; +
&gt; +	switch (fmt &amp; SND_SOC_DAIFMT_FORMAT_MASK) {
&gt; +	case SND_SOC_DAIFMT_I2S:
&gt; +		serial_format = 0x0;
&gt; +		break;
&gt; +	case SND_SOC_DAIFMT_DSP_A:
&gt; +		serial_format = TAS2552_DAIFMT_DSP;
&gt; +		break;
&gt; +	case SND_SOC_DAIFMT_RIGHT_J:
&gt; +		serial_format = TAS2552_DAIFMT_RIGHT_J;
&gt; +		break;
&gt; +	case SND_SOC_DAIFMT_LEFT_J:
&gt; +		serial_format = TAS2552_DAIFMT_LEFT_J;
&gt; +		break;
&gt; +
&gt; +	default:
&gt; +		return -EINVAL;
&gt; +	}
&gt; +
&gt; +	snd_soc_update_bits(codec, TAS2552_SER_CTRL_1, TAS2552_DATA_FORMAT_MASK,
&gt; +						serial_format);
&gt; +
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static int tas2552_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
&gt; +				  unsigned int freq, int dir)
&gt; +{
&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; +	struct tas2552_data *data = dev_get_drvdata(dai-&gt;dev);
&gt; +
&gt; +	/* Fill in the PLL control registers for J &amp; D
&gt; +	 * PLL_CLK = (.5 * freq * J.D) / 2^p
&gt; +	 * Need to fill in J and D here based on incoming freq
&gt; +	 */
&gt; +
&gt; +	tas2552_sw_shutdown(data, 1);

if you move sw_shutdown to runtime_suspend/resume, you could implement
this as follows:

	ret = pm_runtime_get_sync(data-&gt;dev);
	if (ret)
		return ret;

&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_PLL_ENABLE, 0);
&gt; +
&gt; +	snd_soc_write(codec, TAS2552_PLL_CTRL_1, 0x10);
&gt; +	snd_soc_write(codec, TAS2552_PLL_CTRL_2, 0x00);
&gt; +	snd_soc_write(codec, TAS2552_PLL_CTRL_3, 0x00);
&gt; +
&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_PLL_ENABLE,
&gt; +						TAS2552_PLL_ENABLE);
&gt; +
&gt; +	tas2552_sw_shutdown(data, 0);

and this as:

	pm_runtime_mark_last_busy(data-&gt;dev);
	pm_runtime_put_autosuspend(data-&gt;dev);

then use a 1000 ms default timeout and you're good to go. In fact, you
can make this even better by trying to make sure device is already
powered when you get here. Also, I'm not sure what kind of latency you'd
causing by constantly powering device on and off as you currently are.

&gt; +
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static int tas2552_mute(struct snd_soc_dai *dai, int mute)
&gt; +{
&gt; +	u8 cfg1_reg = 0x0;
&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; +
&gt; +	if (mute)
&gt; +		cfg1_reg |= TAS2552_MUTE_MASK;
&gt; +	else
&gt; +		cfg1_reg &amp;= ~TAS2552_MUTE_MASK;
&gt; +
&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_1, TAS2552_MUTE_MASK, cfg1_reg);
&gt; +
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static int tas2552_startup(struct snd_pcm_substream *substream,
&gt; +			   struct snd_soc_dai *dai)
&gt; +{
&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; +	struct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);
&gt; +
&gt; +	tas2552_sw_shutdown(tas2552, 1);
&gt; +	tas2552_power(tas2552, 1);

shouldn't you power first ? Looking at datasheet, if pin EN isn't high,
device won't be enabled. It'd be surprising that it still responds to
i2c.

&gt; +
&gt; +	/* Turn on Class D amplifier */
&gt; +	snd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_CLASSD_EN_MASK,
&gt; +						TAS2552_CLASSD_EN);
&gt; +
&gt; +	tas2552_sw_shutdown(tas2552, 0);
&gt; +
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static void tas2552_shutdown(struct snd_pcm_substream *substream,
&gt; +			   struct snd_soc_dai *dai)
&gt; +{
&gt; +	struct snd_soc_codec *codec = dai-&gt;codec;
&gt; +	struct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);
&gt; +
&gt; +	tas2552_sw_shutdown(tas2552, 1);
&gt; +	tas2552_power(tas2552, 0);
&gt; +}
&gt; +
&gt; +static struct snd_soc_dai_ops tas2552_speaker_dai_ops = {
&gt; +	.hw_params	= tas2552_hw_params,
&gt; +	.set_sysclk	= tas2552_set_dai_sysclk,
&gt; +	.set_fmt	= tas2552_set_dai_fmt,
&gt; +	.startup	= tas2552_startup,
&gt; +	.shutdown	= tas2552_shutdown,
&gt; +	.digital_mute = tas2552_mute,
&gt; +};
&gt; +
&gt; +/* Formats supported by TAS2552 driver. */
&gt; +#define TAS2552_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
&gt; +			 SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
&gt; +
&gt; +/* TAS2552 dai structure. */
&gt; +static struct snd_soc_dai_driver tas2552_dai[] = {
&gt; +	{
&gt; +		.name = &quot;tas2552-amplifier&quot;,
&gt; +		.playback = {
&gt; +			.stream_name = &quot;Speaker&quot;,
&gt; +			.channels_min = 2,
&gt; +			.channels_max = 2,
&gt; +			.rates = SNDRV_PCM_RATE_8000_192000,
&gt; +			.formats = TAS2552_FORMATS,
&gt; +		},
&gt; +		.ops = &amp;tas2552_speaker_dai_ops,
&gt; +	},
&gt; +};
&gt; +
&gt; +/*
&gt; + * DAC digital volumes. From -7 to 24 dB in 1 dB steps
&gt; + */
&gt; +static DECLARE_TLV_DB_SCALE(dac_tlv, -7, 100, 24);
&gt; +
&gt; +static const struct snd_kcontrol_new tas2552_snd_controls[] = {
&gt; +	SOC_SINGLE_TLV(&quot;Speaker Driver Playback Volume&quot;,
&gt; +			 TAS2552_PGA_GAIN, 0, 0x1f, 1, dac_tlv),
&gt; +};
&gt; +
&gt; +static int tas2552_codec_probe(struct snd_soc_codec *codec)
&gt; +{
&gt; +	struct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);
&gt; +
&gt; +	tas2552-&gt;codec = codec;
&gt; +	tas2552_power(tas2552, 1);
&gt; +	tas2552_init(codec);
&gt; +
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static int tas2552_codec_remove(struct snd_soc_codec *codec)
&gt; +{
&gt; +	struct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);
&gt; +
&gt; +	tas2552_power(tas2552, 0);
&gt; +
&gt; +	return 0;
&gt; +};
&gt; +
&gt; +static struct snd_soc_codec_driver soc_codec_dev_tas2552 = {
&gt; +	.probe = tas2552_codec_probe,
&gt; +	.remove = tas2552_codec_remove,
&gt; +	.controls = tas2552_snd_controls,
&gt; +	.num_controls = ARRAY_SIZE(tas2552_snd_controls),
&gt; +};
&gt; +
&gt; +static const struct regmap_config tas2552_regmap_config = {
&gt; +	.reg_bits = 8,
&gt; +	.val_bits = 8,
&gt; +
&gt; +	.max_register = TAS2552_MAX_REG,
&gt; +	.reg_defaults = tas2552_reg_defs,
&gt; +	.num_reg_defaults = ARRAY_SIZE(tas2552_reg_defs),
&gt; +	.cache_type = REGCACHE_RBTREE,
&gt; +};
&gt; +
&gt; +static int tas2552_probe(struct i2c_client *client,
&gt; +			   const struct i2c_device_id *id)
&gt; +{
&gt; +	struct device *dev;
&gt; +	struct tas2552_data *data;
&gt; +	struct tas2552_platform_data *pdata = client-&gt;dev.platform_data;
&gt; +	struct device_node *np = client-&gt;dev.of_node;
&gt; +	int ret;
&gt; +
&gt; +	dev = &amp;client-&gt;dev;
&gt; +	data = devm_kzalloc(&amp;client-&gt;dev, sizeof(*data), GFP_KERNEL);
&gt; +	if (data == NULL)
&gt; +		return -ENOMEM;
&gt; +
&gt; +	if (np) {
&gt; +		data-&gt;power_gpio = of_get_named_gpio(np, &quot;enable-gpio&quot;, 0);
&gt; +	} else if (pdata) {
&gt; +		data-&gt;power_gpio = pdata-&gt;enable_gpio;
&gt; +	} else {
&gt; +		dev_err(dev, &quot;Platform or dev tree data not set\n&quot;);
&gt; +		return -ENODEV;
&gt; +	}
&gt; +
&gt; +	data-&gt;regmap = devm_regmap_init_i2c(client, &amp;tas2552_regmap_config);
&gt; +	if (IS_ERR(data-&gt;regmap)) {
&gt; +		ret = PTR_ERR(data-&gt;regmap);
&gt; +		dev_err(&amp;client-&gt;dev, &quot;Failed to allocate register map: %d\n&quot;,
&gt; +			ret);
&gt; +		return ret;
&gt; +	}
&gt; +
&gt; +	data-&gt;tas2552_client = client;
&gt; +	data-&gt;regmap = devm_regmap_init_i2c(client, &amp;tas2552_regmap_config);
&gt; +	if (IS_ERR(data-&gt;regmap)) {
&gt; +		ret = PTR_ERR(data-&gt;regmap);
&gt; +		dev_err(&amp;client-&gt;dev, &quot;Failed to allocate register map: %d\n&quot;,
&gt; +			ret);
&gt; +		return ret;
&gt; +	}
&gt; +
&gt; +	dev_set_drvdata(&amp;client-&gt;dev, data);
&gt; +
&gt; +	mutex_init(&amp;data-&gt;mutex);
&gt; +
&gt; +	if (data-&gt;power_gpio &gt;= 0) {
&gt; +		ret = devm_gpio_request(dev, data-&gt;power_gpio,
&gt; +					&quot;tas2552 enable&quot;);
&gt; +		if (ret &lt; 0) {
&gt; +			dev_err(dev, &quot;Failed to request power GPIO (%d)\n&quot;,
&gt; +				data-&gt;power_gpio);
&gt; +			goto err_gpio;
&gt; +		}
&gt; +		gpio_direction_output(data-&gt;power_gpio, 0);
&gt; +	}
&gt; +
&gt; +	ret = snd_soc_register_codec(&amp;client-&gt;dev,
&gt; +				      &amp;soc_codec_dev_tas2552,
&gt; +				      tas2552_dai, ARRAY_SIZE(tas2552_dai));
&gt; +	if (ret &lt; 0)
&gt; +		dev_err(&amp;client-&gt;dev, &quot;Failed to register codec: %d\n&quot;, ret);
&gt; +
&gt; +	return 0;
&gt; +
&gt; +err_gpio:
&gt; +	data-&gt;tas2552_client = NULL;
&gt; +	return ret;
&gt; +}
&gt; +
&gt; +static int tas2552_i2c_remove(struct i2c_client *client)
&gt; +{
&gt; +	snd_soc_unregister_codec(&amp;client-&gt;dev);
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static const struct i2c_device_id tas2552_id[] = {
&gt; +	{ &quot;tas2552-codec&quot;, 0 },
&gt; +	{ }
&gt; +};
&gt; +MODULE_DEVICE_TABLE(i2c, tas2552_id);
&gt; +
&gt; +#if IS_ENABLED(CONFIG_OF)
&gt; +static const struct of_device_id tas2552_of_match[] = {
&gt; +	{ .compatible = &quot;ti,tas2552&quot;, },
&gt; +	{},
&gt; +};
&gt; +MODULE_DEVICE_TABLE(of, tas2552_of_match);
&gt; +#endif
&gt; +
&gt; +static struct i2c_driver tas2552_i2c_driver = {
&gt; +	.driver = {
&gt; +		.name = &quot;tas2552-codec&quot;,
&gt; +		.owner = THIS_MODULE,
&gt; +		.of_match_table = of_match_ptr(tas2552_of_match),
&gt; +	},
&gt; +	.probe = tas2552_probe,
&gt; +	.remove = tas2552_i2c_remove,
&gt; +	.id_table = tas2552_id,
&gt; +};
&gt; +
&gt; +module_i2c_driver(tas2552_i2c_driver);
&gt; +
&gt; +MODULE_AUTHOR(&quot;Dan Muprhy &lt;dmurphy@xxxxxx&gt;&quot;);
&gt; +MODULE_DESCRIPTION(&quot;TAS2552 Audio amplifier driver&quot;);
&gt; +MODULE_LICENSE(&quot;GPL&quot;);
&gt; diff --git a/sound/soc/codecs/tas2552.h b/sound/soc/codecs/tas2552.h
&gt; new file mode 100644
&gt; index 0000000..174c64d
&gt; --- /dev/null
&gt; +++ b/sound/soc/codecs/tas2552.h
&gt; @@ -0,0 +1,75 @@
&gt; +/*
&gt; + * ALSA SoC Texas Instruments TAS2552 Mono Audio Amplifier
&gt; + *
&gt; + * Copyright (C) 2014 Texas Instruments Inc.
&gt; + *
&gt; + * Author: Dan Murphy &lt;dmurphy@xxxxxx&gt;
&gt; + *
&gt; + * This program is free software; you can redistribute it and/or
&gt; + * modify it under the terms of the GNU General Public License
&gt; + * version 2 as published by the Free Software Foundation.
&gt; + *
&gt; + * This program is distributed in the hope that it will be useful, but
&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of
&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&gt; + * General Public License for more details.
&gt; + */
&gt; +
&gt; +#ifndef __TAS2552_H__
&gt; +#define __TAS2552_H__
&gt; +
&gt; +/* Register Address Map */
&gt; +#define TAS2552_DEVICE_STATUS	0x00
&gt; +#define TAS2552_CFG_1			0x01
&gt; +#define TAS2552_CFG_2			0x02
&gt; +#define TAS2552_CFG_3			0x03
&gt; +#define TAS2552_DOUT			0x04
&gt; +#define TAS2552_SER_CTRL_1		0x05
&gt; +#define TAS2552_SER_CTRL_2		0x06
&gt; +#define TAS2552_OUTPUT_DATA		0x07
&gt; +#define TAS2552_PLL_CTRL_1		0x08
&gt; +#define TAS2552_PLL_CTRL_2		0x09
&gt; +#define TAS2552_PLL_CTRL_3		0x0a
&gt; +#define TAS2552_BTIP			0x0b
&gt; +#define TAS2552_BTS_CTRL		0x0c
&gt; +#define TAS2552_LIMIT_LVL_CTRL	0x0d
&gt; +#define TAS2552_LIMIT_RATE_HYS	0x0e
&gt; +#define TAS2552_LIMIT_RELEASE	0x0f
&gt; +#define TAS2552_LIMIT_INT_COUNT	0x10
&gt; +#define TAS2552_PDM_CFG			0x11
&gt; +#define TAS2552_PGA_GAIN		0x12
&gt; +#define TAS2552_EDGE_RATE_CTRL	0x13
&gt; +#define TAS2552_BOOST_PT_CTRL	0x14
&gt; +#define TAS2552_VER_NUM			0x16
&gt; +#define TAS2552_VBAT_DATA		0x19
&gt; +#define TAS2552_MAX_REG			0x20
&gt; +
&gt; +/* CFG1 Register Masks */
&gt; +#define TAS2552_MUTE_MASK		(1 &lt;&lt; 2)
&gt; +#define TAS2552_SWS_MASK		(1 &lt;&lt; 1)
&gt; +#define TAS2552_WCLK_MASK		0x07
&gt; +#define TAS2552_CLASSD_EN_MASK	(1 &lt;&lt; 7)
&gt; +#define TAS2552_CLASSD_EN		0x80
&gt; +
&gt; +#define TAS2552_PLL_ENABLE		(1 &lt;&lt; 3)
&gt; +
&gt; +/* CFG3 Register Masks */
&gt; +#define TAS2552_WORD_CLK_MASK		0x80
&gt; +#define TAS2552_BIT_CLK_MASK		0x40
&gt; +#define TAS2552_DATA_FORMAT_MASK	0x0c
&gt; +
&gt; +#define TAS2552_DAIFMT_DSP			0x04
&gt; +#define TAS2552_DAIFMT_RIGHT_J		0x08
&gt; +#define TAS2552_DAIFMT_LEFT_J		0x0c
&gt; +
&gt; +/* WCLK Dividers */
&gt; +#define TAS2552_8KHZ		0x00
&gt; +#define TAS2552_11_12KHZ	0x01
&gt; +#define TAS2552_16KHZ		0x02
&gt; +#define TAS2552_22_24KHZ	0x03
&gt; +#define TAS2552_32KHZ		0x04
&gt; +#define TAS2552_44_48KHZ	0x05
&gt; +#define TAS2552_88_96KHZ	0x06
&gt; +#define TAS2552_176_192KHZ	0x07
&gt; +
&gt; +#endif
&gt; -- 
&gt; 1.7.9.5
&gt; 
&gt; --
&gt; To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
&gt; the body of a message to majordomo@xxxxxxxxxxxxxxx
&gt; More majordomo info at  <a  rel="nofollow" href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a>
&gt; Please read the FAQ at  <a  rel="nofollow" href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a>

-- 
balbi
</pre><p><strong>Attachment:
<a href="pgpBmI1zljj1k.pgp" ><tt>signature.asc</tt></a></strong><br>
<em>Description:</em> Digital signature</p>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00482" href="msg00482.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Dan Murphy</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00479" href="msg00479.html">[PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
<ul><li><em>From:</em> Dan Murphy</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00480.html">Re: [alsa-devel] [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00482.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00488.html">Re: [alsa-devel] [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00482.html">Re: [PATCH v3] ASoC: tas2552: Support TI TAS2552 Amplifier</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00481"><strong>Date</strong></a></li>
<li><a href="index.html#00481"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/Pulseaudio/>[Pulseaudio]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/alsa-devel/>[ALSA&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=http://www.ske-art.com/z/biglist.html>[Big&nbsp;List&nbsp;of&nbsp;Linux&nbsp;Books]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td valign=top align=left>&nbsp;</td>
<td valign=top align=right>
<a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
