<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH v2 1/2] hid&#45;lenovo: Add support for X1 Tablet special keys and LED control -->
<!--X-From-R13: Rraavf Inffraoret &#60;qraavf.jnffraoretNfrpharg.pbz> -->
<!--X-Date: Fri, 9 Dec 2016 04:04:30 &#45;0800 -->
<!--X-Message-Id: f8c4a4b7&#45;c524&#45;2742&#45;2903&#45;25bb6b4d565a@secunet.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: b8f9c56c&#45;2dfc&#45;8895&#45;2f2a&#45;e17a34be06d2@secunet.com -->
<!--X-Reference: 20160914153247.GL25951@mail.corp.redhat.com -->
<!--X-Reference: 8228171a&#45;1430&#45;9e8d&#45;99fc&#45;8d0951d612d2@secunet.com -->
<!--X-Reference: 20160915081108.GC15777@mail.corp.redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Sound: Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Sound &mdash; Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</title>
<link rel="alternate" type="application/rss+xml" title="Linux Sound" href="//feeds.feedburner.com/LinuxSound">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:6612422167" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</h1>
[<a href="msg00632.html">Date Prev</a>][<a href="msg00634.html">Date Next</a>][<a href="msg00632.html">Thread Prev</a>][<a href="msg00627.html">Thread Next</a>][<a href="maillist.html#00633">Date Index</a>][<a href="index.html#00633">Thread Index</a>]
<script src="https://apis.google.com/js/platform.js" async defer></script>
<g:plusone size="small"></g:plusone>
<p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</li>
<li><em>From</em>: Dennis Wassenberg &lt;dennis.wassenberg@xxxxxxxxxxx&gt;</li>
<li><em>Date</em>: Fri, 9 Dec 2016 13:01:44 +0100</li>
<li><em>Cc</em>: &lt;linux-input@xxxxxxxxxxxxxxx&gt;, &lt;linux-sound@xxxxxxxxxxxxxxx&gt;,        &lt;alsa-devel@xxxxxxxxxxxxxxxx&gt;, Takashi Iwai &lt;tiwai@xxxxxxx&gt;,        &lt;lukas@xxxxxxxxx&gt;, Andrew Duggan &lt;aduggan@xxxxxxxxxxxxx&gt;,        &lt;perex@xxxxxxxx&gt;, &lt;vinod.koul@xxxxxxxxx&gt;, &lt;hui.wang@xxxxxxxxxxxxx&gt;,        &lt;rafael.j.wysocki@xxxxxxxxx&gt;, &lt;jikos@xxxxxxxxxx&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg00632.html">20160915081108.GC15777@mail.corp.redhat.com</a>&gt;</li>
<li><em>Organization</em>: secunet Security Networks</li>
<li><em>References</em>: &lt;<a href="msg00626.html">b8f9c56c-2dfc-8895-2f2a-e17a34be06d2@secunet.com</a>&gt; &lt;<a href="msg00628.html">20160914153247.GL25951@mail.corp.redhat.com</a>&gt; &lt;<a href="msg00630.html">8228171a-1430-9e8d-99fc-8d0951d612d2@secunet.com</a>&gt; &lt;<a href="msg00632.html">20160915081108.GC15777@mail.corp.redhat.com</a>&gt;</li>
<li><em>User-agent</em>: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Thunderbird/45.5.1</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Hi Benjamin,

thank you for answering my questions.

I have a few comments inlined. There are just 2 additional questions.

Best regards,

Dennis

On 15.09.2016 10:11, Benjamin Tissoires wrote:
&gt; On Sep 15 2016 or thereabouts, Dennis Wassenberg wrote:
&gt;&gt; Hi Benjamin,
&gt;&gt;
&gt;&gt; Thank you for your comments. I will prepare new patches to replace this
&gt;&gt; one. It will take some weeks to do this (vacation, other work). Would
&gt;&gt; you please answer my inquiries inlined before I do this.
&gt;&gt;
&gt;&gt; Best regards,
&gt;&gt;
&gt;&gt; Dennis
&gt;&gt;
&gt;&gt; On 14.09.2016 17:32, Benjamin Tissoires wrote:
&gt;&gt;&gt; Hi Dennis,
&gt;&gt;&gt;
&gt;&gt;&gt; On Sep 14 2016 or thereabouts, Dennis Wassenberg wrote:
&gt;&gt;&gt;&gt; The Lenovo X1 Tablet Cover is connected via USB. It constists of
&gt;&gt;&gt;&gt; 1 device with 3 usb interfaces. Interface 0 represents keyboard,
&gt;&gt;&gt;&gt; interface 1 the function / special keys and LED control, interface 2
&gt;&gt;&gt;&gt; is the Synaptics touchpad and pointing stick.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; This driver will bind to interfaces 0 and 1 and handle function / special keys
&gt;&gt;&gt;&gt; including LED control.
&gt;&gt;&gt;&gt; HID: add device id for Lenovo X1 Tablet Cover
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Signed-off-by: Dennis Wassenberg &lt;dennis.wassenberg@xxxxxxxxxxx&gt;
&gt;&gt;&gt;&gt; ---
&gt;&gt;&gt;&gt; Changes v1 -&gt; v2 (suggested by Benjamin Tissoires):
&gt;&gt;&gt;&gt;  * Squashed add of device IDs for Lenovo Thinkpad X1 Tablet Cover together with add of support for Lenovo Thinkpad X1 Tablet Cover into one patch
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; I wanted to review the first version, but got sidetracked.
&gt;&gt;&gt;
&gt;&gt;&gt; So here it comes :)
&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;  drivers/hid/hid-core.c     |   1 +
&gt;&gt;&gt;&gt;  drivers/hid/hid-ids.h      |   1 +
&gt;&gt;&gt;&gt;  drivers/hid/hid-lenovo.c   | 549 +++++++++++++++++++++++++++++++++++++++++++++
&gt;&gt;&gt;
&gt;&gt;&gt; This seems to be too big for a single patch. Especially when you have
&gt;&gt;&gt; actually several changes that could be split for easier reviewing (LED,
&gt;&gt;&gt; special keys and keys stuck at least).
&gt;&gt;&gt;
&gt;&gt; Whats the difference between special keys and keys stuck? This code will
&gt;&gt; mainly handle special keys and LED control. I can split these 2 thinks.
&gt;&gt; But I currently don't know where to do a third split.
&gt; 
&gt; IMO, in the first case, you are mapping unmapped keys to their proper
&gt; KEY_* event. In the other case, you are forcing the release of the keys,
&gt; which is not something we generally do given that you should be notified
&gt; of the release. Splitting this is 2 would allow to better understand the
&gt; changes and revert one if needed.
&gt; 
Understood.
&gt;&gt;&gt;&gt;  include/linux/hid-lenovo.h |  15 ++
&gt;&gt;&gt;&gt;  4 files changed, 566 insertions(+)
&gt;&gt;&gt;&gt;  create mode 100644 include/linux/hid-lenovo.h
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
&gt;&gt;&gt;&gt; index 6add0b6..ba6a200 100644
&gt;&gt;&gt;&gt; --- a/drivers/hid/hid-core.c
&gt;&gt;&gt;&gt; +++ b/drivers/hid/hid-core.c
&gt;&gt;&gt;&gt; @@ -2111,6 +2111,7 @@ void hid_disconnect(struct hid_device *hdev)
&gt;&gt;&gt;&gt;  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE2) },
&gt;&gt;&gt;&gt;  	{ HID_USB_DEVICE(USB_VENDOR_ID_RAZER, USB_DEVICE_ID_RAZER_BLADE_14) },
&gt;&gt;&gt;&gt;  	{ HID_USB_DEVICE(USB_VENDOR_ID_CMEDIA, USB_DEVICE_ID_CM6533) },
&gt;&gt;&gt;&gt; +	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_COVER) },
&gt;&gt;&gt;
&gt;&gt;&gt; I know it's hard given the existing code, but please try to keep the
&gt;&gt;&gt; list sorted and insert your device in the appropriate place.
&gt;&gt;&gt;
&gt;&gt; oh sorry, yes of course.
&gt;&gt;&gt;&gt;  	{ }
&gt;&gt;&gt;&gt;  };
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt; diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
&gt;&gt;&gt;&gt; index 3466f0d..1f08fb5 100644
&gt;&gt;&gt;&gt; --- a/drivers/hid/hid-ids.h
&gt;&gt;&gt;&gt; +++ b/drivers/hid/hid-ids.h
&gt;&gt;&gt;&gt; @@ -615,6 +615,7 @@
&gt;&gt;&gt;&gt;  #define USB_DEVICE_ID_LENOVO_CUSBKBD	0x6047
&gt;&gt;&gt;&gt;  #define USB_DEVICE_ID_LENOVO_CBTKBD	0x6048
&gt;&gt;&gt;&gt;  #define USB_DEVICE_ID_LENOVO_TPPRODOCK	0x6067
&gt;&gt;&gt;&gt; +#define USB_DEVICE_ID_LENOVO_X1_COVER	0x6085
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt;  #define USB_VENDOR_ID_LG		0x1fd2
&gt;&gt;&gt;&gt;  #define USB_DEVICE_ID_LG_MULTITOUCH	0x0064
&gt;&gt;&gt;&gt; diff --git a/drivers/hid/hid-lenovo.c b/drivers/hid/hid-lenovo.c
&gt;&gt;&gt;&gt; index 1ac4ff4..4251aac 100644
&gt;&gt;&gt;&gt; --- a/drivers/hid/hid-lenovo.c
&gt;&gt;&gt;&gt; +++ b/drivers/hid/hid-lenovo.c
&gt;&gt;&gt;&gt; @@ -3,9 +3,11 @@
&gt;&gt;&gt;&gt;   *  - ThinkPad USB Keyboard with TrackPoint (tpkbd)
&gt;&gt;&gt;&gt;   *  - ThinkPad Compact Bluetooth Keyboard with TrackPoint (cptkbd)
&gt;&gt;&gt;&gt;   *  - ThinkPad Compact USB Keyboard with TrackPoint (cptkbd)
&gt;&gt;&gt;&gt; + *  - ThinkPad X1 Cover USB Keyboard with TrackPoint and Touchpad (tpx1cover)
&gt;&gt;&gt;&gt;   *
&gt;&gt;&gt;&gt;   *  Copyright (c) 2012 Bernhard Seibold
&gt;&gt;&gt;&gt;   *  Copyright (c) 2014 Jamie Lentin &lt;jm@xxxxxxxxxxxx&gt;
&gt;&gt;&gt;&gt; + *  Copyright (c) 2016 Dennis Wassenberg &lt;dennis.wassenberg@xxxxxxxxxxx&gt;
&gt;&gt;&gt;&gt;   */
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt;  /*
&gt;&gt;&gt;&gt; @@ -19,11 +21,19 @@
&gt;&gt;&gt;&gt;  #include &lt;linux/sysfs.h&gt;
&gt;&gt;&gt;&gt;  #include &lt;linux/device.h&gt;
&gt;&gt;&gt;&gt;  #include &lt;linux/hid.h&gt;
&gt;&gt;&gt;&gt; +#include &lt;linux/hid-lenovo.h&gt;
&gt;&gt;&gt;&gt;  #include &lt;linux/input.h&gt;
&gt;&gt;&gt;&gt;  #include &lt;linux/leds.h&gt;
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt;  #include &quot;hid-ids.h&quot;
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt; +struct led_table_entry {
&gt;&gt;&gt;&gt; +	struct led_classdev *dev;
&gt;&gt;&gt;&gt; +	uint8_t state;
&gt;&gt;&gt;&gt; +};
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +static struct led_table_entry hid_lenovo_led_table[HID_LENOVO_LED_MAX];
&gt;&gt;&gt;
&gt;&gt;&gt; Ouch. Please no static arrays containing random devices. The device is
&gt;&gt;&gt; USB, so you could have several of its kind plugged at once.
&gt;&gt;&gt;
&gt;&gt;&gt; So, please include this array in the driver data in the hid device, and
&gt;&gt;&gt; if you need a list of hid device connected, use an actual list of struct
&gt;&gt;&gt; hid_device.
&gt;&gt;&gt; Well, you can also use a list of struct led_table_entry if you add a
&gt;&gt;&gt; field with the type, and iterate over the list for each call on the API
&gt;&gt;&gt; in case there are 2 or more LEDs of the same type.
&gt;&gt;&gt;
&gt;&gt; Yes, you are right. For my use case (X1 Tablet only) this was sufficient
&gt;&gt; to do it in this way:) X1 Tablet is only able to connect one
&gt;&gt; ThinKeyboard Cover.
I implemented the 2nd alternative you explained. But additionally I need an array/list for every lenovo_led_type to save the current state of a led type. If the devices are always connected I don't need it, I would save the state in led_table_entry or in the drvdata. But in case of that MUTE or MICMUTE toggles via thinkpad_helper (e.g. via amixer) I want the hid_lenovo driver keep updated but I can not store it at the drvdata or led_table_entry because it is not available. Thats why I would like to introduce a static array which stores the led state of each led type. If a new device is attached I can query this array and set the led of the new device appropriately. Do you agree?
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt;  struct lenovo_drvdata_tpkbd {
&gt;&gt;&gt;&gt;  	int led_state;
&gt;&gt;&gt;&gt;  	struct led_classdev led_mute;
&gt;&gt;&gt;&gt; @@ -42,6 +52,37 @@ struct lenovo_drvdata_cptkbd {
&gt;&gt;&gt;&gt;  	int sensitivity;
&gt;&gt;&gt;&gt;  };
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt; +struct lenovo_drvdata_tpx1cover {
&gt;&gt;&gt;&gt; +	uint16_t led_state;
&gt;&gt;&gt;&gt; +	uint8_t fnlock_state;
&gt;&gt;&gt;&gt; +	uint8_t led_present;
&gt;&gt;&gt;&gt; +	struct led_classdev led_mute;
&gt;&gt;&gt;&gt; +	struct led_classdev led_micmute;
&gt;&gt;&gt;&gt; +	struct led_classdev led_fnlock;
&gt;&gt;&gt;&gt; +};
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +int hid_lenovo_led_set(int led_num, bool on)
&gt;&gt;&gt;
&gt;&gt;&gt; You are declaring an enum for LEDs, I'd prefer see it used here (so you
&gt;&gt;&gt; have to give it a name first).
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	struct led_classdev *dev;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (led_num &gt;= HID_LENOVO_LED_MAX)
&gt;&gt;&gt;&gt; +		return -EINVAL;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	dev = hid_lenovo_led_table[led_num].dev;
&gt;&gt;&gt;&gt; +	hid_lenovo_led_table[led_num].state = on;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (!dev)
&gt;&gt;&gt;&gt; +		return -ENODEV;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (!dev-&gt;brightness_set)
&gt;&gt;&gt;&gt; +		return -ENODEV;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	dev-&gt;brightness_set(dev, on ? LED_FULL : LED_OFF);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	return 0;
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +EXPORT_SYMBOL_GPL(hid_lenovo_led_set);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt;  #define map_key_clear(c) hid_map_usage_clear(hi, usage, bit, max, EV_KEY, (c))
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt;  static const __u8 lenovo_pro_dock_need_fixup_collection[] = {
&gt;&gt;&gt;&gt; @@ -86,6 +127,84 @@ static int lenovo_input_mapping_tpkbd(struct hid_device *hdev,
&gt;&gt;&gt;&gt;  	return 0;
&gt;&gt;&gt;&gt;  }
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt; +static int lenovo_input_mapping_tpx1cover(struct hid_device *hdev,
&gt;&gt;&gt;&gt; +		struct hid_input *hi, struct hid_field *field,
&gt;&gt;&gt;&gt; +		struct hid_usage *usage, unsigned long **bit, int *max)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	if ((usage-&gt;hid &amp; HID_USAGE_PAGE) == HID_UP_CONSUMER) {
&gt;&gt;&gt;&gt; +		switch (usage-&gt;hid &amp; HID_USAGE) {
&gt;&gt;&gt;&gt; +		case 0x0001: // Unknown keys -&gt; Idenditied by usage index!
&gt;&gt;&gt;
&gt;&gt;&gt; Why don't use directly usage-&gt;hid and check for HID_CP_CONSUMERCONTROL (0x000c0001)?
&gt;&gt;&gt;
&gt;&gt; ok, I will use this.
&gt;&gt;
&gt;&gt;&gt; Note that here you are working with keys while previously it was LED.
&gt;&gt;&gt; Split in 2 patches please.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; +			map_key_clear(KEY_UNKNOWN);
&gt;&gt;&gt;
&gt;&gt;&gt; why?
&gt;&gt;&gt; If the key doesn't seem to be used, please don't map it and return -1.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +			switch (usage-&gt;usage_index) {
&gt;&gt;&gt;&gt; +			case 0x8:
&gt;&gt;&gt;
&gt;&gt;&gt; It feels weird to have an hexadecimal representation when dealing with
&gt;&gt;&gt; indexes.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_FN);
&gt;&gt;&gt;
&gt;&gt;&gt; You should consider using map_key_clear(KEY_FN); instead. This way the
&gt;&gt;&gt; event handling code will be cheaper.
&gt;&gt;&gt;
&gt;&gt;&gt; Rince, wash reapeat in the following cases.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +				break;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			case 0x9:
&gt;&gt;&gt;&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_MICMUTE);
&gt;&gt;&gt;&gt; +				break;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			case 0xa:
&gt;&gt;&gt;&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_CONFIG);
&gt;&gt;&gt;&gt; +				break;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			case 0xb:
&gt;&gt;&gt;&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_SEARCH);
&gt;&gt;&gt;&gt; +				break;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			case 0xc:
&gt;&gt;&gt;&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_SETUP);
&gt;&gt;&gt;&gt; +				break;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			case 0xd:
&gt;&gt;&gt;&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_SWITCHVIDEOMODE);
&gt;&gt;&gt;&gt; +				break;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			case 0xe:
&gt;&gt;&gt;&gt; +				input_set_capability(hi-&gt;input, EV_KEY, KEY_RFKILL);
&gt;&gt;&gt;&gt; +				break;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			default:
&gt;&gt;&gt;&gt; +				return -1;
&gt;&gt;&gt;&gt; +			}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			return 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		case 0x006f: // Consumer.006f ---&gt; Key.BrightnessUp
&gt;&gt;&gt;&gt; +			map_key_clear(KEY_BRIGHTNESSUP);
&gt;&gt;&gt;
&gt;&gt;&gt; Why are you overriding the existing behavior from hid-input if you are
&gt;&gt;&gt; using the same code?
&gt;&gt;&gt;
&gt;&gt;&gt; Just return 0 and hid-input will set the values for you.
&gt;&gt;&gt;
&gt;&gt;&gt; Rince, wash repeat for the rest of the cases.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +			return 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		case 0x0070: // Consumer.0070 ---&gt; Key.BrightnessDown
&gt;&gt;&gt;&gt; +			map_key_clear(KEY_BRIGHTNESSDOWN);
&gt;&gt;&gt;&gt; +			return 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		case 0x00b7:// Consumer.00b7 ---&gt; Key.StopCD
&gt;&gt;&gt;&gt; +			map_key_clear(KEY_STOPCD);
&gt;&gt;&gt;&gt; +			return 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		case 0x00cd: // Consumer.00cd ---&gt; Key.PlayPause
&gt;&gt;&gt;&gt; +			map_key_clear(KEY_PLAYPAUSE);
&gt;&gt;&gt;&gt; +			return 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		case 0x00e0: // Consumer.00e0 ---&gt; Absolute.Volume
&gt;&gt;&gt;&gt; +			return 0;
&gt;&gt;&gt;&gt; +		case 0x00e2: // Consumer.00e2 ---&gt; Key.Mute
&gt;&gt;&gt;&gt; +			map_key_clear(KEY_MUTE);
&gt;&gt;&gt;&gt; +			return 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		case 0x00e9: // Consumer.00e9 ---&gt; Key.VolumeUp
&gt;&gt;&gt;&gt; +			map_key_clear(KEY_VOLUMEUP);
&gt;&gt;&gt;&gt; +			return 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		case 0x00ea: // Consumer.00ea ---&gt; Key.VolumeDown
&gt;&gt;&gt;&gt; +			map_key_clear(KEY_VOLUMEDOWN);
&gt;&gt;&gt;&gt; +			return 1;
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	return 0;
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt;  static int lenovo_input_mapping_cptkbd(struct hid_device *hdev,
&gt;&gt;&gt;&gt;  		struct hid_input *hi, struct hid_field *field,
&gt;&gt;&gt;&gt;  		struct hid_usage *usage, unsigned long **bit, int *max)
&gt;&gt;&gt;&gt; @@ -172,6 +291,9 @@ static int lenovo_input_mapping(struct hid_device *hdev,
&gt;&gt;&gt;&gt;  	case USB_DEVICE_ID_LENOVO_CBTKBD:
&gt;&gt;&gt;&gt;  		return lenovo_input_mapping_cptkbd(hdev, hi, field,
&gt;&gt;&gt;&gt;  							usage, bit, max);
&gt;&gt;&gt;&gt; +	case USB_DEVICE_ID_LENOVO_X1_COVER:
&gt;&gt;&gt;&gt; +		return lenovo_input_mapping_tpx1cover(hdev, hi, field,
&gt;&gt;&gt;&gt; +							usage, bit, max);
&gt;&gt;&gt;&gt;  	default:
&gt;&gt;&gt;&gt;  		return 0;
&gt;&gt;&gt;&gt;  	}
&gt;&gt;&gt;&gt; @@ -362,6 +484,143 @@ static int lenovo_event_cptkbd(struct hid_device *hdev,
&gt;&gt;&gt;&gt;  	return 0;
&gt;&gt;&gt;&gt;  }
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt; +static enum led_brightness lenovo_led_brightness_get_tpx1cover(
&gt;&gt;&gt;&gt; +			struct led_classdev *led_cdev)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	struct device *dev = led_cdev-&gt;dev-&gt;parent;
&gt;&gt;&gt;&gt; +	struct hid_device *hdev = to_hid_device(dev);
&gt;&gt;&gt;&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt;&gt;&gt;&gt; +	int led_nr = 0;
&gt;&gt;&gt;
&gt;&gt;&gt; Would be even better to use the enum.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (led_cdev == &amp;drv_data-&gt;led_mute)
&gt;&gt;&gt;&gt; +		led_nr = 0;
&gt;&gt;&gt;&gt; +	else if (led_cdev == &amp;drv_data-&gt;led_micmute)
&gt;&gt;&gt;&gt; +		led_nr = 1;
&gt;&gt;&gt;&gt; +	else if (led_cdev == &amp;drv_data-&gt;led_fnlock)
&gt;&gt;&gt;&gt; +		led_nr = 2;
&gt;&gt;&gt;&gt; +	else
&gt;&gt;&gt;&gt; +		return LED_OFF;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	return drv_data-&gt;led_state &amp; (1 &lt;&lt; led_nr)
&gt;&gt;&gt;&gt; +				? LED_FULL
&gt;&gt;&gt;&gt; +				: LED_OFF;
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +static void lenovo_led_brightness_set_tpx1cover(struct led_classdev *led_cdev,
&gt;&gt;&gt;&gt; +			enum led_brightness value)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	struct device *dev = led_cdev-&gt;dev-&gt;parent;
&gt;&gt;&gt;&gt; +	struct hid_device *hdev = to_hid_device(dev);
&gt;&gt;&gt;&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt;&gt;&gt;&gt; +	struct hid_report *report;
&gt;&gt;&gt;&gt; +	int led_nr = -1;
&gt;&gt;&gt;
&gt;&gt;&gt; Likewise, the enum would be nice
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	int led_nr_hw = -1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (led_cdev == &amp;drv_data-&gt;led_mute) {
&gt;&gt;&gt;&gt; +		led_nr = 0;
&gt;&gt;&gt;&gt; +		led_nr_hw = 0x64;
&gt;&gt;&gt;
&gt;&gt;&gt; Are you sure you are not overriding bits in 0x44?
&gt;&gt;&gt;
&gt;&gt; ???
&gt; 
&gt; See the comment just below.
&gt; It feels weird that you need to have 0x54, 0x64, 0x74 to set an LED. I
&gt; wouldn't be surprised if the (constant) 0x44 part is there to set a
&gt; different feature of the cover.
&gt; 
&gt; However, I might have a wrong view of the protocol and using those plain
&gt; values are probably enough (and maybe the firmware uses 0x44 as the flag
&gt; that you are working with LEDs).
&gt; 
I can do so, yes. I have to reordner the enum. Because I introduce the enum, it is possible. But this should be an enum representing keys for every device which is handled by the hid-lenovo driver. Is there a guarantee that the order/values of the enum will not change in the future? If not the driver will not work after that. I tried to avoid making a hardware specific value dependent from a common enumeration. If it is guaranteed I will change it.
&gt;&gt;&gt; If you reorder the enum, I'd say the led_nr_hw could be represented as:
&gt;&gt;&gt; ((led_nr + 1) &lt;&lt; 4) | 0x44
&gt;&gt;&gt;
&gt;&gt;&gt; So I think this is too much to be just a coincidence.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	} else if (led_cdev == &amp;drv_data-&gt;led_micmute) {
&gt;&gt;&gt;&gt; +		led_nr = 1;
&gt;&gt;&gt;&gt; +		led_nr_hw = 0x74;
&gt;&gt;&gt;&gt; +	} else if (led_cdev == &amp;drv_data-&gt;led_fnlock) {
&gt;&gt;&gt;&gt; +		led_nr = 2;
&gt;&gt;&gt;&gt; +		led_nr_hw = 0x54;
&gt;&gt;&gt;&gt; +	} else {
&gt;&gt;&gt;&gt; +		hid_warn(hdev, &quot;Invalid LED to set.\n&quot;);
&gt;&gt;&gt;&gt; +		return;
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (value == LED_OFF)
&gt;&gt;&gt;&gt; +		drv_data-&gt;led_state &amp;= ~(1 &lt;&lt; led_nr);
&gt;&gt;&gt;&gt; +	else
&gt;&gt;&gt;&gt; +		drv_data-&gt;led_state |= 1 &lt;&lt; led_nr;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	report = hdev-&gt;report_enum[HID_OUTPUT_REPORT].report_id_hash[9];
&gt;&gt;&gt;&gt; +	if (report) {
&gt;&gt;&gt;&gt; +		report-&gt;field[0]-&gt;value[0] = led_nr_hw;
&gt;&gt;&gt;&gt; +		report-&gt;field[0]-&gt;value[1] = (drv_data-&gt;led_state &amp; (1 &lt;&lt; led_nr))
&gt;&gt;&gt;&gt; +			? 0x02 : 0x01;
&gt;&gt;&gt;&gt; +		hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +static int lenovo_event_tpx1cover(struct hid_device *hdev,
&gt;&gt;&gt;&gt; +		struct hid_field *field, struct hid_usage *usage, __s32 value)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	int ret = 0;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if ((usage-&gt;hid &amp; HID_USAGE_PAGE) == HID_UP_CONSUMER
&gt;&gt;&gt;&gt; +		&amp;&amp; (usage-&gt;hid &amp; HID_USAGE) == 0x0001) {
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (usage-&gt;usage_index == 0x8 &amp;&amp; value == 1) {
&gt;&gt;&gt;&gt; +			struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			if (drv_data &amp;&amp; drv_data-&gt;led_present) {
&gt;&gt;&gt;&gt; +				drv_data-&gt;fnlock_state = lenovo_led_brightness_get_tpx1cover(
&gt;&gt;&gt;&gt; +						&amp;drv_data-&gt;led_fnlock) == LED_OFF ? 1 : 0;
&gt;&gt;&gt;&gt; +				lenovo_led_brightness_set_tpx1cover(
&gt;&gt;&gt;&gt; +					&amp;drv_data-&gt;led_fnlock,
&gt;&gt;&gt;&gt; +					drv_data-&gt;fnlock_state ? LED_FULL : LED_OFF);
&gt;&gt;&gt;&gt; +			}
&gt;&gt;&gt;
&gt;&gt;&gt; This looks like a different semantic change where you sync the actual LED with the incoming event.
&gt;&gt;&gt; This is not something we usually do from the kernel but rely on the
&gt;&gt;&gt; userspace to do it for us. Not sure about the FN lock state though.
&gt;&gt;&gt;
&gt;&gt; In case of X1 Tablet the fn lock state and the fn lock led state is the
&gt;&gt; same. You can only change the fn lock while changing the fn lock led
&gt;&gt; state. I will check if it behaves different if I map KEY_FN 	appropriate.
&gt;&gt;&gt; Anyway, if this needs to be there, it should have its own patch
ok.
&gt;&gt;&gt;
&gt;&gt; ok. I will double check if this is relly needed. If so I will put in
&gt;&gt; into a separate patch.
&gt; 
&gt; Thanks.
&gt; 
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (usage-&gt;usage_index == 0x9 &amp;&amp; value == 1) {
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_MICMUTE, 1);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_MICMUTE, 0);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +			ret = 1;
&gt;&gt;&gt;
&gt;&gt;&gt; Aren't you notified when the key is released?
&gt;&gt;&gt;
&gt;&gt; Does map_key_clear work if a key can only identified by
&gt;&gt; usage-&gt;usage_index and not by usage-&gt;hid? If yes, I can remove this.
&gt; 
&gt; Basically, when you have usage_index &gt; 0, that means that the report
&gt; descriptor is declaring more than one field with the same usage in a
&gt; row. Given that you should use map_key_clear, you are mapping the HID
&gt; usage (the element in the array) to a KEY_* value and you should be
&gt; fine.
&gt; 
&gt; Consider that each field in the report gets assigned its own usage, and
&gt; usage-&gt;page, usage-&gt;usage and usage-&gt;usage_index are just a description
&gt; of the usage.
&gt; 
&gt;&gt; Otherwise I have to track the previously pressed keys to not issue a key
&gt;&gt; release of every special key each time one special key is pressed/released.
&gt; 
&gt; Just give a shot at it, but I am pretty confident it will work.
&gt; 
Yes, its working. Thanks for this hint!
&gt;&gt;&gt; If so, you should just drop the change because you used map_key_clear
&gt;&gt;&gt; above and hid-input will simply do the right thing for you.
&gt;&gt;&gt;
&gt;&gt;&gt; If you are not notified, this is big enough a difference to have its own
&gt;&gt;&gt; patch.
&gt;&gt;&gt;
&gt;&gt;&gt; Rince wash repeat
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (usage-&gt;usage_index == 0xa &amp;&amp; value == 1) {
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_CONFIG, 1);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_CONFIG, 0);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			ret = 1;
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (usage-&gt;usage_index == 0xb &amp;&amp; value == 1) {
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SEARCH, 1);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SEARCH, 0);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			ret = 1;
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (usage-&gt;usage_index == 0xc &amp;&amp; value == 1) {
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SETUP, 1);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SETUP, 0);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			ret = 1;
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (usage-&gt;usage_index == 0xd &amp;&amp; value == 1) {
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SWITCHVIDEOMODE, 1);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_SWITCHVIDEOMODE, 0);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			ret = 1;
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (usage-&gt;usage_index == 0xe &amp;&amp; value == 1) {
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_RFKILL, 1);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +			input_event(field-&gt;hidinput-&gt;input, EV_KEY, KEY_RFKILL, 0);
&gt;&gt;&gt;&gt; +			input_sync(field-&gt;hidinput-&gt;input);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			ret = 1;
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	return ret;
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt;  static int lenovo_event(struct hid_device *hdev, struct hid_field *field,
&gt;&gt;&gt;&gt;  		struct hid_usage *usage, __s32 value)
&gt;&gt;&gt;&gt;  {
&gt;&gt;&gt;&gt; @@ -369,6 +628,8 @@ static int lenovo_event(struct hid_device *hdev, struct hid_field *field,
&gt;&gt;&gt;&gt;  	case USB_DEVICE_ID_LENOVO_CUSBKBD:
&gt;&gt;&gt;&gt;  	case USB_DEVICE_ID_LENOVO_CBTKBD:
&gt;&gt;&gt;&gt;  		return lenovo_event_cptkbd(hdev, field, usage, value);
&gt;&gt;&gt;&gt; +	case USB_DEVICE_ID_LENOVO_X1_COVER:
&gt;&gt;&gt;&gt; +		return lenovo_event_tpx1cover(hdev, field, usage, value);
&gt;&gt;&gt;&gt;  	default:
&gt;&gt;&gt;&gt;  		return 0;
&gt;&gt;&gt;&gt;  	}
&gt;&gt;&gt;&gt; @@ -731,6 +992,251 @@ static int lenovo_probe_tpkbd(struct hid_device *hdev)
&gt;&gt;&gt;&gt;  	return ret;
&gt;&gt;&gt;&gt;  }
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt; +static int lenovo_probe_tpx1cover_configure(struct hid_device *hdev)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	struct hid_report *report = hdev-&gt;report_enum[HID_OUTPUT_REPORT].report_id_hash[9];
&gt;&gt;&gt;&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (!drv_data)
&gt;&gt;&gt;&gt; +		return -ENODEV;
&gt;&gt;&gt;
&gt;&gt;&gt; Can this really happen?
&gt;&gt;&gt;
&gt;&gt; I will remove this.
&gt; 
&gt; That was really a question, please make sure drv_data can't be null.
&gt; 
Can not happen there.
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (!report)
&gt;&gt;&gt;&gt; +		return -ENOENT;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	report-&gt;field[0]-&gt;value[0] = 0x54;
&gt;&gt;&gt;&gt; +	report-&gt;field[0]-&gt;value[1] = 0x20;
&gt;&gt;&gt;&gt; +	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
&gt;&gt;&gt;&gt; +	hid_hw_wait(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	report-&gt;field[0]-&gt;value[0] = 0x54;
&gt;&gt;&gt;&gt; +	report-&gt;field[0]-&gt;value[1] = 0x08;
&gt;&gt;&gt;&gt; +	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
&gt;&gt;&gt;&gt; +	hid_hw_wait(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	report-&gt;field[0]-&gt;value[0] = 0xA0;
&gt;&gt;&gt;&gt; +	report-&gt;field[0]-&gt;value[1] = 0x02;
&gt;&gt;&gt;&gt; +	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
&gt;&gt;&gt;&gt; +	hid_hw_wait(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	lenovo_led_brightness_set_tpx1cover(&amp;drv_data-&gt;led_mute,
&gt;&gt;&gt;&gt; +		hid_lenovo_led_table[HID_LENOVO_LED_MUTE].state ? LED_FULL : LED_OFF);
&gt;&gt;&gt;&gt; +	hid_hw_wait(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	lenovo_led_brightness_set_tpx1cover(&amp;drv_data-&gt;led_micmute,
&gt;&gt;&gt;&gt; +		hid_lenovo_led_table[HID_LENOVO_LED_MICMUTE].state ? LED_FULL : LED_OFF);
&gt;&gt;&gt;&gt; +	hid_hw_wait(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	lenovo_led_brightness_set_tpx1cover(&amp;drv_data-&gt;led_fnlock, LED_FULL);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	return 0;
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +static int lenovo_probe_tpx1cover_special_functions(struct hid_device *hdev)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	struct device *dev = &amp;hdev-&gt;dev;
&gt;&gt;&gt;&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = NULL;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	size_t name_sz = strlen(dev_name(dev)) + 16;
&gt;&gt;&gt;&gt; +	char *name_led = NULL;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	struct hid_report *report;
&gt;&gt;&gt;&gt; +	bool report_match = 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	int ret = 0;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 2, 0, 3);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 3, 0, 16);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_OUTPUT_REPORT, 9, 0, 2);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 32, 0, 1);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 84, 0, 1);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 100, 0, 1);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 116, 0, 1);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 132, 0, 1);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 144, 0, 1);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 162, 0, 1);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;
&gt;&gt;&gt; It feels weird to have you check if those reports are actually long
&gt;&gt;&gt; enough. I think this is related to checking which interface you have,
&gt;&gt;&gt; but you should be able to reduce the list to only those you are actually
&gt;&gt;&gt; using (report id &quot;9&quot; seems like a good candidate).
&gt;&gt;&gt;
&gt;&gt; Yes, its related to select the USB Interface. I queried all existing
&gt;&gt; reports of Interface 1 here. I will reduce this list but report id 9 is
&gt;&gt; not sufficient because IF2 has report id 9 too. So I will add one other
&gt;&gt; report id which enables a clear decision.
&gt;&gt;&gt; And please add a comment why you are checking some specific report IDs.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (!report_match) {
&gt;&gt;&gt;&gt; +		ret = -ENODEV;
&gt;&gt;&gt;&gt; +		goto err;
&gt;&gt;&gt;
&gt;&gt;&gt; just return -ENODEV here.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	drv_data = devm_kzalloc(&amp;hdev-&gt;dev,
&gt;&gt;&gt;&gt; +			sizeof(struct lenovo_drvdata_tpx1cover),
&gt;&gt;&gt;&gt; +			GFP_KERNEL);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (!drv_data) {
&gt;&gt;&gt;&gt; +		hid_err(hdev,
&gt;&gt;&gt;&gt; +			&quot;Could not allocate memory for tpx1cover driver data\n&quot;);
&gt;&gt;&gt;&gt; +		ret = -ENOMEM;
&gt;&gt;&gt;&gt; +		goto err;
&gt;&gt;&gt;
&gt;&gt;&gt; Just return -ENODEV too, the devres manager will kfree drv_data for you.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	name_led = devm_kzalloc(&amp;hdev-&gt;dev, name_sz, GFP_KERNEL);
&gt;&gt;&gt;&gt; +	if (!name_led) {
&gt;&gt;&gt;&gt; +		hid_err(hdev, &quot;Could not allocate memory for mute led data\n&quot;);
&gt;&gt;&gt;&gt; +		ret = -ENOMEM;
&gt;&gt;&gt;&gt; +		goto err_cleanup;
&gt;&gt;&gt;
&gt;&gt;&gt; likewise
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +	snprintf(name_led, name_sz, &quot;%s:amber:mute&quot;, dev_name(dev));
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_mute.name = name_led;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_mute.brightness_get = lenovo_led_brightness_get_tpx1cover;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_mute.brightness_set = lenovo_led_brightness_set_tpx1cover;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_mute.dev = dev;
&gt;&gt;&gt;&gt; +	hid_lenovo_led_table[HID_LENOVO_LED_MUTE].dev = &amp;drv_data-&gt;led_mute;
&gt;&gt;&gt;&gt; +	led_classdev_register(dev, &amp;drv_data-&gt;led_mute);
&gt;&gt;&gt;
&gt;&gt;&gt; Isn't devm_led_class_register working?
&gt;&gt;&gt;
&gt;&gt;&gt; That would be nice because you could drop all of your cleanup paths
&gt;&gt;&gt;
&gt;&gt; Ah, ok, didn't know that function until yet.
&gt; 
&gt; I *think* it should be fine to use it with hid-&gt;dev. If you use it with
&gt; input-&gt;dev, that won't do and you'll need to do some weird things to
&gt; remove the LED device (sadly that's what I had to do in the wacom
&gt; driver).
&gt; 
&gt; Just make sure /sys/class/leds/ doesn't contain a dangling LED device
&gt; when you remove the cover and you should know if this worked or not.
&gt; 
&gt; Cheers,
&gt; Benjamin
&gt; 
ok.
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	name_led = devm_kzalloc(&amp;hdev-&gt;dev, name_sz, GFP_KERNEL);
&gt;&gt;&gt;&gt; +	if (!name_led) {
&gt;&gt;&gt;&gt; +		hid_err(hdev,
&gt;&gt;&gt;&gt; +			&quot;Could not allocate memory for mic mute led data\n&quot;);
&gt;&gt;&gt;&gt; +		ret = -ENOMEM;
&gt;&gt;&gt;&gt; +		goto err_cleanup;
&gt;&gt;&gt;
&gt;&gt;&gt; ditto
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +	snprintf(name_led, name_sz, &quot;%s:amber:micmute&quot;, dev_name(dev));
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_micmute.name = name_led;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_micmute.brightness_get = lenovo_led_brightness_get_tpx1cover;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_micmute.brightness_set = lenovo_led_brightness_set_tpx1cover;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_micmute.dev = dev;
&gt;&gt;&gt;&gt; +	hid_lenovo_led_table[HID_LENOVO_LED_MICMUTE].dev = &amp;drv_data-&gt;led_micmute;
&gt;&gt;&gt;&gt; +	led_classdev_register(dev, &amp;drv_data-&gt;led_micmute);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	name_led = devm_kzalloc(&amp;hdev-&gt;dev, name_sz, GFP_KERNEL);
&gt;&gt;&gt;&gt; +	if (!name_led) {
&gt;&gt;&gt;&gt; +		hid_err(hdev,
&gt;&gt;&gt;&gt; +			&quot;Could not allocate memory for FN lock led data\n&quot;);
&gt;&gt;&gt;&gt; +		ret = -ENOMEM;
&gt;&gt;&gt;&gt; +		goto err_cleanup;
&gt;&gt;&gt;
&gt;&gt;&gt; ditto
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	snprintf(name_led, name_sz, &quot;%s:amber:fnlock&quot;, dev_name(dev));
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_fnlock.name = name_led;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_fnlock.brightness_get = lenovo_led_brightness_get_tpx1cover;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_fnlock.brightness_set = lenovo_led_brightness_set_tpx1cover;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_fnlock.dev = dev;
&gt;&gt;&gt;&gt; +	hid_lenovo_led_table[HID_LENOVO_LED_FNLOCK].dev = &amp;drv_data-&gt;led_fnlock;
&gt;&gt;&gt;&gt; +	led_classdev_register(dev, &amp;drv_data-&gt;led_fnlock);
&gt;&gt;&gt;
&gt;&gt;&gt; ditto
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_state = 0;
&gt;&gt;&gt;&gt; +	drv_data-&gt;fnlock_state = 1;
&gt;&gt;&gt;&gt; +	drv_data-&gt;led_present = 1;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	hid_set_drvdata(hdev, drv_data);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	return lenovo_probe_tpx1cover_configure(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +err_cleanup:
&gt;&gt;&gt;
&gt;&gt;&gt; Shouldn't be required if you use devm_led_classdev_register().
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	if (drv_data-&gt;led_fnlock.name) {
&gt;&gt;&gt;&gt; +		led_classdev_unregister(&amp;drv_data-&gt;led_fnlock);
&gt;&gt;&gt;&gt; +		devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_fnlock.name);
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (drv_data-&gt;led_micmute.name) {
&gt;&gt;&gt;&gt; +		led_classdev_unregister(&amp;drv_data-&gt;led_micmute);
&gt;&gt;&gt;&gt; +		devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_micmute.name);
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (drv_data-&gt;led_mute.name) {
&gt;&gt;&gt;&gt; +		led_classdev_unregister(&amp;drv_data-&gt;led_mute);
&gt;&gt;&gt;&gt; +		devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_mute.name);
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (drv_data)
&gt;&gt;&gt;&gt; +		kfree(drv_data);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +err:
&gt;&gt;&gt;&gt; +	return ret;
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +static int lenovo_probe_tpx1cover_touch(struct hid_device *hdev)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	struct hid_report *report;
&gt;&gt;&gt;&gt; +	bool report_match = 1;
&gt;&gt;&gt;&gt; +	int ret = 0;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 2, 0, 2);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 2, 1, 2);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 11, 0, 61);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 12, 0, 61);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 16, 0, 3);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_INPUT_REPORT, 16, 1, 2);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_OUTPUT_REPORT, 9, 0, 20);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_OUTPUT_REPORT, 10, 0, 20);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 14, 0, 1);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;&gt; +	report = hid_validate_values(hdev, HID_FEATURE_REPORT, 15, 0, 3);
&gt;&gt;&gt;&gt; +	report_match &amp;= report ? 1 : 0;
&gt;&gt;&gt;
&gt;&gt;&gt; Feels weird too (especially if there is no comment explaining why you
&gt;&gt;&gt; are doing those checks).
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (!report_match)
&gt;&gt;&gt;&gt; +		ret = -ENODEV;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	return ret;
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +static int lenovo_probe_tpx1cover(struct hid_device *hdev)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	int ret = 0;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	/*
&gt;&gt;&gt;&gt; +	 * Probing for special function keys and LED control -&gt; usb intf 1
&gt;&gt;&gt;&gt; +	 * Probing for touch input -&gt; usb intf 2 (handled by rmi4 driver)
&gt;&gt;&gt;&gt; +	 * Other (keyboard) -&gt; usb intf 0
&gt;&gt;&gt;&gt; +	 */
&gt;&gt;&gt;&gt; +	if (!lenovo_probe_tpx1cover_special_functions(hdev)) {
&gt;&gt;&gt;&gt; +		// special function keys and LED control
&gt;&gt;&gt;
&gt;&gt;&gt; No C++ style comments please.
&gt;&gt;&gt;
&gt;&gt; Oops
&gt;&gt;&gt;&gt; +		ret = 0;
&gt;&gt;&gt;&gt; +	} else if (!lenovo_probe_tpx1cover_touch(hdev)) {
&gt;&gt;&gt;&gt; +		// handled by rmi
&gt;&gt;&gt;&gt; +		ret = -ENODEV;
&gt;&gt;&gt;
&gt;&gt;&gt; I don't quite get how the touch can be handled if you just return
&gt;&gt;&gt; -ENODEV here. Given that the device has been added to
&gt;&gt;&gt; hid_have_special_driver, if you don't claim the device, no one else will
&gt;&gt;&gt; unless you add the ID in the other HID driver.
&gt;&gt;&gt;
&gt;&gt; Yes, ok. This is because I have some additional RMI4 code which handles
&gt;&gt; the touch. At the current upstream situation I should return 0 here such
&gt;&gt; that this touch works basically.
&gt;&gt;&gt;&gt; +	} else {
&gt;&gt;&gt;&gt; +		// keyboard
&gt;&gt;&gt;
&gt;&gt;&gt; Why is that keyboard chunk not given it's own probe function?
&gt;&gt;&gt;
&gt;&gt; Because it is just a few lines:) I will add a probe function.
&gt;&gt;&gt;&gt; +		struct lenovo_drvdata_tpx1cover *drv_data;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		drv_data = devm_kzalloc(&amp;hdev-&gt;dev,
&gt;&gt;&gt;&gt; +					sizeof(struct lenovo_drvdata_tpx1cover),
&gt;&gt;&gt;&gt; +					GFP_KERNEL);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (!drv_data) {
&gt;&gt;&gt;&gt; +			hid_err(hdev,
&gt;&gt;&gt;&gt; +				&quot;Could not allocate memory for tpx1cover driver data\n&quot;);
&gt;&gt;&gt;&gt; +			ret = -ENOMEM;
&gt;&gt;&gt;&gt; +			goto out;
&gt;&gt;&gt;
&gt;&gt;&gt; no need for a goto here. Just a plain return -ENOMEM should be good
&gt;&gt;&gt; enough.
&gt;&gt;&gt;
&gt;&gt; ok
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		drv_data-&gt;led_state = 0;
&gt;&gt;&gt;&gt; +		drv_data-&gt;led_present = 0;
&gt;&gt;&gt;&gt; +		drv_data-&gt;fnlock_state = 0;
&gt;&gt;&gt;&gt; +		hid_set_drvdata(hdev, drv_data);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		ret = 0;
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +out:
&gt;&gt;&gt;&gt; +	return ret;
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt;  static int lenovo_probe_cptkbd(struct hid_device *hdev)
&gt;&gt;&gt;&gt;  {
&gt;&gt;&gt;&gt;  	int ret;
&gt;&gt;&gt;&gt; @@ -803,6 +1309,9 @@ static int lenovo_probe(struct hid_device *hdev,
&gt;&gt;&gt;&gt;  	case USB_DEVICE_ID_LENOVO_CBTKBD:
&gt;&gt;&gt;&gt;  		ret = lenovo_probe_cptkbd(hdev);
&gt;&gt;&gt;&gt;  		break;
&gt;&gt;&gt;&gt; +	case USB_DEVICE_ID_LENOVO_X1_COVER:
&gt;&gt;&gt;&gt; +		ret = lenovo_probe_tpx1cover(hdev);
&gt;&gt;&gt;&gt; +		break;
&gt;&gt;&gt;&gt;  	default:
&gt;&gt;&gt;&gt;  		ret = 0;
&gt;&gt;&gt;&gt;  		break;
&gt;&gt;&gt;&gt; @@ -843,6 +1352,42 @@ static void lenovo_remove_cptkbd(struct hid_device *hdev)
&gt;&gt;&gt;&gt;  			&amp;lenovo_attr_group_cptkbd);
&gt;&gt;&gt;&gt;  }
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt; +static void lenovo_remove_tpx1cover(struct hid_device *hdev)
&gt;&gt;&gt;&gt; +{
&gt;&gt;&gt;&gt; +	struct lenovo_drvdata_tpx1cover *drv_data = hid_get_drvdata(hdev);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (!drv_data)
&gt;&gt;&gt;&gt; +		return;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (drv_data-&gt;led_present) {
&gt;&gt;&gt;&gt; +		if (drv_data-&gt;led_fnlock.name) {
&gt;&gt;&gt;&gt; +			hid_lenovo_led_table[HID_LENOVO_LED_FNLOCK].dev = NULL;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			led_classdev_unregister(&amp;drv_data-&gt;led_fnlock);
&gt;&gt;&gt;&gt; +			devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_fnlock.name);
&gt;&gt;&gt;
&gt;&gt;&gt; Calling yourself devm_kfree usually means there is something wrong.
&gt;&gt;&gt; Here, if you used devm_led_*, you could just drop the entire remove
&gt;&gt;&gt; function.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (drv_data-&gt;led_micmute.name) {
&gt;&gt;&gt;&gt; +			hid_lenovo_led_table[HID_LENOVO_LED_MICMUTE].dev = NULL;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			led_classdev_unregister(&amp;drv_data-&gt;led_micmute);
&gt;&gt;&gt;&gt; +			devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_micmute.name);
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +		if (drv_data-&gt;led_mute.name) {
&gt;&gt;&gt;&gt; +			hid_lenovo_led_table[HID_LENOVO_LED_MUTE].dev = NULL;
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +			led_classdev_unregister(&amp;drv_data-&gt;led_mute);
&gt;&gt;&gt;&gt; +			devm_kfree(&amp;hdev-&gt;dev, (void *) drv_data-&gt;led_mute.name);
&gt;&gt;&gt;&gt; +		}
&gt;&gt;&gt;&gt; +	}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	if (drv_data)
&gt;&gt;&gt;&gt; +		devm_kfree(&amp;hdev-&gt;dev, drv_data);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +	hid_set_drvdata(hdev, NULL);
&gt;&gt;&gt;&gt; +}
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt;  static void lenovo_remove(struct hid_device *hdev)
&gt;&gt;&gt;&gt;  {
&gt;&gt;&gt;&gt;  	switch (hdev-&gt;product) {
&gt;&gt;&gt;&gt; @@ -853,6 +1398,9 @@ static void lenovo_remove(struct hid_device *hdev)
&gt;&gt;&gt;&gt;  	case USB_DEVICE_ID_LENOVO_CBTKBD:
&gt;&gt;&gt;&gt;  		lenovo_remove_cptkbd(hdev);
&gt;&gt;&gt;&gt;  		break;
&gt;&gt;&gt;&gt; +	case USB_DEVICE_ID_LENOVO_X1_COVER:
&gt;&gt;&gt;&gt; +		lenovo_remove_tpx1cover(hdev);
&gt;&gt;&gt;&gt; +		break;
&gt;&gt;&gt;&gt;  	}
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt;  	hid_hw_stop(hdev);
&gt;&gt;&gt;&gt; @@ -883,6 +1431,7 @@ static int lenovo_input_configured(struct hid_device *hdev,
&gt;&gt;&gt;&gt;  	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CUSBKBD) },
&gt;&gt;&gt;&gt;  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CBTKBD) },
&gt;&gt;&gt;&gt;  	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPPRODOCK) },
&gt;&gt;&gt;&gt; +	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_COVER) },
&gt;&gt;&gt;&gt;  	{ }
&gt;&gt;&gt;&gt;  };
&gt;&gt;&gt;&gt;  
&gt;&gt;&gt;&gt; diff --git a/include/linux/hid-lenovo.h b/include/linux/hid-lenovo.h
&gt;&gt;&gt;&gt; new file mode 100644
&gt;&gt;&gt;&gt; index 0000000..d0b0145
&gt;&gt;&gt;&gt; --- /dev/null
&gt;&gt;&gt;&gt; +++ b/include/linux/hid-lenovo.h
&gt;&gt;&gt;&gt; @@ -0,0 +1,15 @@
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +#ifndef __HID_LENOVO_H__
&gt;&gt;&gt;&gt; +#define __HID_LENOVO_H__
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +enum {
&gt;&gt;&gt;&gt; +	HID_LENOVO_LED_MUTE,
&gt;&gt;&gt;
&gt;&gt;&gt; I'd rather have a name for the enum (so you can reuse it), and also have
&gt;&gt;&gt; each enum given its numerical value (or at least the first and last.
&gt;&gt;&gt;
&gt;&gt; ok.
&gt;&gt;&gt;&gt; +	HID_LENOVO_LED_MICMUTE,
&gt;&gt;&gt;&gt; +	HID_LENOVO_LED_FNLOCK,
&gt;&gt;&gt;&gt; +	HID_LENOVO_LED_MAX,
&gt;&gt;&gt;&gt; +};
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +int hid_lenovo_led_set(int led_num, bool on);
&gt;&gt;&gt;&gt; +
&gt;&gt;&gt;&gt; +#endif /* __HID_LENOVO_H_ */
&gt;&gt;&gt;&gt; -- 
&gt;&gt;&gt;&gt; 1.i9.1
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Cheers,
&gt;&gt;&gt; Benjamin
&gt;&gt;&gt;
&gt; --
&gt; To unsubscribe from this list: send the line &quot;unsubscribe linux-input&quot; in
&gt; the body of a message to majordomo@xxxxxxxxxxxxxxx
&gt; More majordomo info at  <a  rel="nofollow" href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a>
&gt; 
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-sound&quot; in
the body of a message to majordomo@xxxxxxxxxxxxxxx
More majordomo info at  <a  rel="nofollow" href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00626" href="msg00626.html">[PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
<ul><li><em>From:</em> Dennis Wassenberg</li></ul></li>
<li><strong><a name="00628" href="msg00628.html">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
<ul><li><em>From:</em> Benjamin Tissoires</li></ul></li>
<li><strong><a name="00630" href="msg00630.html">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
<ul><li><em>From:</em> Dennis Wassenberg</li></ul></li>
<li><strong><a name="00632" href="msg00632.html">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
<ul><li><em>From:</em> Benjamin Tissoires</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00632.html">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00634.html">[PATCH 1/4] hid-lenovo: Add support for X1 Tablet cover special keys</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00632.html">Re: [PATCH v2 1/2] hid-lenovo: Add support for X1 Tablet special keys and LED control</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00627.html">[PATCH v2 2/2] hda: thinkpad_helper: Add support for hid-lenovo LED control</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00633"><strong>Date</strong></a></li>
<li><a href="index.html#00633"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/Pulseaudio/>[Pulseaudio]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/alsa-devel/>[ALSA&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=http://www.ske-art.com/z/biglist.html>[Big&nbsp;List&nbsp;of&nbsp;Linux&nbsp;Books]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width="100%">
<tr>
<td valign=top align=left>&nbsp;</td>
<td valign=top align=right>
<a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr></table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
