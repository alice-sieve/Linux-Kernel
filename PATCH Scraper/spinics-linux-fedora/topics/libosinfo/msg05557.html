<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re:  [osinfo&#45;db PATCH 1/1] Fix out&#45;of&#45;tree build -->
<!--X-From-R13: Uhvqb =?vfb&#45;8859&#45;1?C?U=TQagure?= &#60;ntkNfvtkpch.bet> -->
<!--X-Date: Thu, 18 Apr 2019 05:02:15 &#45;0700 -->
<!--X-Message-Id: 20190418071748.GA21565@bogon.m.sigxcpu.org -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190415101149.32179&#45;1&#45;fidencio@redhat.com -->
<!--X-Reference: 20190415101149.32179&#45;2&#45;fidencio@redhat.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<title>Re:  [osinfo-db PATCH 1/1] Fix out-of-tree build &mdash; libosinfo</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="libosinfo: Re:  [osinfo-db PATCH 1/1] Fix out-of-tree build">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<link rel="alternate" type="application/rss+xml" title="libosinfo" href="//feeds.feedburner.com/libosinfo">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re:  [osinfo-db PATCH 1/1] Fix out-of-tree build</h1>
[<a href="msg05556.html">Date Prev</a>][<a href="msg05558.html">Date Next</a>][<a href="msg05515.html">Thread Prev</a>][<a href="msg05561.html">Thread Next</a>][<a href="maillist.html#05557">Date Index</a>][<a href="index.html#05557">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re:  [osinfo-db PATCH 1/1] Fix out-of-tree build</li>
<li><em>From</em>: Guido G&#xFC;nther &lt;agx@xxxxxxxxxxx&gt;</li>
<li><em>Date</em>: Thu, 18 Apr 2019 09:17:48 +0200</li>
<li><em>Cc</em>: libosinfo@xxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg05515.html">20190415101149.32179-2-fidencio@redhat.com</a>&gt;</li>
<li><em>References</em>: &lt;<a href="msg05514.html">20190415101149.32179-1-fidencio@redhat.com</a>&gt;	&lt;<a href="msg05515.html">20190415101149.32179-2-fidencio@redhat.com</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.10.1 (2018-07-13)</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Hi,
On Mon, Apr 15, 2019 at 12:11:49PM +0200, Fabiano Fid&#xEA;ncio wrote:
&gt; Let's set an ABS_TOPDIR and use it to run our tests, fixing then
&gt; the out-of-tree build.
&gt; 
&gt; <a  rel="nofollow" href="https://gitlab.com/libosinfo/osinfo-db/issues/25">https://gitlab.com/libosinfo/osinfo-db/issues/25</a>
&gt; ---
&gt;  Makefile | 4 +++-
&gt;  1 file changed, 3 insertions(+), 1 deletion(-)
&gt; 
&gt; diff --git a/Makefile b/Makefile
&gt; index 4f6f8d4..a1bdcfe 100644
&gt; --- a/Makefile
&gt; +++ b/Makefile
&gt; @@ -52,6 +52,8 @@ INTLTOOL_MERGE_OPTS = $(INTLTOOL_MERGE_OPTS_$(V))
&gt;  INTLTOOL_MERGE_OPTS_0 = -q
&gt;  INTLTOOL_MERGE_OPTS_1 =
&gt;  
&gt; +ABS_TOPDIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST))))
&gt; +
&gt;  all: $(ARCHIVE) osinfo-db.spec mingw-osinfo-db.spec
&gt;  
&gt;  install: $(ARCHIVE)
&gt; @@ -121,4 +123,4 @@ update-po:
&gt;          done
&gt;  
&gt;  check: $(DATA_FILES) $(SCHEMA_FILES)
&gt; -	$(PYTHON) -m pytest
&gt; +	$(PYTHON) -m pytest $(ABS_TOPDIR)tests

Yes, the tests are found that way. I'm seeing lots of test failures
though with

$ make -C build -f ../Makefile ARCHIVE=osinfo-db.tar.xz check

make: Entering directory '/var/scratch/src/libosinfo/upstream/osinfo-db/build'
python3 -m pytest /var/scratch/src/libosinfo/upstream/osinfo-db/tests
============================= test session starts ==============================
platform linux -- Python 3.7.3rc1, pytest-3.10.1, py-1.7.0, pluggy-0.8.0
hypothesis profile 'default' -&gt; database=DirectoryBasedExampleDatabase('/var/scratch/src/libosinfo/upstream/osinfo-db/build/.hypothesis/examples')
rootdir: /var/scratch/src/libosinfo/upstream/osinfo-db, inifile:
plugins: hypothesis-3.71.11, celery-4.2.1
collected 920 items

../tests/test_devices.py ........................F..........F.FFF.....F. [  5%]
....FFFF                                                                 [  5%]
../tests/test_isoinfo.py FFFFFFFFF..FF...FFFFFFFFFF..F....FF..F..FF.FFFF [ 11%]
FFFFF......................F..FFFFFF...F.FFFFF.FFFFFF.....FFFFFFFFFFFFFF [ 18%]
FFFFFFFFFFFFFFFF....FF..FFFFFF........F.............FFFF.FFFFF.......F.. [ 26%]
.....F.......................FFFFF.......F...F..                         [ 31%]
../tests/test_resources.py ............................................. [ 36%]
.................F................FFFFFFF............................... [ 44%]
...........                                                              [ 45%]
../tests/test_schema.py ................................................ [ 51%]
........................................................................ [ 58%]
........................................................................ [ 66%]
........................................................................ [ 74%]
........................................................................ [ 82%]
........................................................................ [ 90%]
........................................................................ [ 98%]
..................                                                       [100%]

=================================== FAILURES ===================================
__________________ test_devices_duplication[rhel-atomic-7.0] ___________________

osxml = &lt;Os shortid=rhel-atomic-7.0&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=rhel-atomic-7.0&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/1af4/1000">http://pcis...ci/1af4/1000</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/1b36/0100">http://pcisig.com/pci/1b36/0100</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
_______________________ test_devices_duplication[win2k] ________________________

osxml = &lt;Os shortid=win2k&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=win2k&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/8086/2415">http://pcis...ci/8086/2415</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/1b36/0100">http://pcisig.com/pci/1b36/0100</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
________________________ test_devices_duplication[win8] ________________________

osxml = &lt;Os shortid=win8&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=win8&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/8086/2668">http://pcis...ci/8086/2668</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/8086/2668">http://pcisig.com/pci/8086/2668</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
_______________________ test_devices_duplication[win8.1] _______________________

osxml = &lt;Os shortid=win8.1&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=win8.1&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/8086/2668">http://pcis...ci/8086/2668</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/8086/2668">http://pcisig.com/pci/8086/2668</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
_______________________ test_devices_duplication[win10] ________________________

osxml = &lt;Os shortid=win10&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=win10&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/8086/2668">http://pcis...ci/8086/2668</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/8086/2668">http://pcisig.com/pci/8086/2668</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
______________________ test_devices_duplication[mageia1] _______________________

osxml = &lt;Os shortid=mageia1&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=mageia1&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/1af4/1001">http://pcis...ci/1af4/1001</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/1af4/1000">http://pcisig.com/pci/1af4/1000</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
____________________ test_devices_duplication[freebsd10.1] _____________________

osxml = &lt;Os shortid=freebsd10.1&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=freebsd10.1&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/1af4/1001">http://pcis...ci/1af4/1001</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/1af4/1000">http://pcisig.com/pci/1af4/1000</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
____________________ test_devices_duplication[freebsd10.2] _____________________

osxml = &lt;Os shortid=freebsd10.2&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=freebsd10.2&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/1af4/1001">http://pcis...ci/1af4/1001</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/1af4/1000">http://pcisig.com/pci/1af4/1000</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
____________________ test_devices_duplication[freebsd10.3] _____________________

osxml = &lt;Os shortid=freebsd10.3&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=freebsd10.3&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...ci/1af4/1001">http://pcis...ci/1af4/1001</a>'] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/1af4/1000">http://pcisig.com/pci/1af4/1000</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
____________________ test_devices_duplication[freebsd11.0] _____________________

osxml = &lt;Os shortid=freebsd11.0&gt;

    @util.os_parametrize('osxml', filter_devices=True)
    def test_devices_duplication(osxml):
&gt;       _check_duplicate_devices(osxml)

../tests/test_devices.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=freebsd11.0&gt;

    def _check_duplicate_devices(osxml):
        &quot;&quot;&quot;
        Ensure an OS doesn't list a device that's defined in the parent
        &quot;&quot;&quot;
        broken = []
        related = util.DataFiles.getosxml_related(osxml)
        for osxml2 in related:
            if osxml2.devices is not None:
                for device in osxml2.devices:
                    if device in osxml.devices:
                        broken.append(device)
&gt;       assert broken == []
E       AssertionError: assert ['<a  rel="nofollow" href="http://pcis...f4/1001">http://pcis...f4/1001</a>', ...] == []
E         Left contains more items, first extra item: '<a  rel="nofollow" href="http://pcisig.com/pci/1af4/1000">http://pcisig.com/pci/1af4/1000</a>'
E         Use -v to get the full diff

../tests/test_devices.py:23: AssertionError
______________________ test_iso_detection[alpinelinux3.5] ______________________

testdata = ('alpinelinux3.5', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.5/alpine-ext.../src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.5/alpine-standard-3.5.2-x86_64.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.5/alpine-extended-3.5.2-x86_64.iso.txt
E           Matched=[] but expected=['alpinelinux3.5']

../tests/test_isoinfo.py:63: AssertionError
______________________ test_iso_detection[alpinelinux3.6] ______________________

testdata = ('alpinelinux3.6', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.6/alpine-vir...h/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.6/alpine-vanilla-3.6.1-x86_64.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.6/alpine-virt-3.6.1-x86.iso.txt
E           Matched=[] but expected=['alpinelinux3.6']

../tests/test_isoinfo.py:63: AssertionError
______________________ test_iso_detection[alpinelinux3.7] ______________________

testdata = ('alpinelinux3.7', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.7/alpine-ext.../src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.7/alpine-standard-3.7.0-x86_64.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.7/alpine-extended-3.7.0-x86_64.iso.txt
E           Matched=[] but expected=['alpinelinux3.7']

../tests/test_isoinfo.py:63: AssertionError
______________________ test_iso_detection[alpinelinux3.8] ______________________

testdata = ('alpinelinux3.8', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.8/alpine-vir...src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.8/alpine-standard-3.8.0-ppc64le.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alpinelinux/alpinelinux3.8/alpine-virt-3.8.0-x86.iso.txt
E           Matched=[] but expected=['alpinelinux3.8']

../tests/test_isoinfo.py:63: AssertionError
__________________________ test_iso_detection[alt8.0] __________________________

testdata = ('alt8.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.0/alt-education-8.0-i586.iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.0/alt-education-8.0-x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.0/alt-education-8.0-i586.iso.txt
E           Matched=[] but expected=['alt8.0']

../tests/test_isoinfo.py:63: AssertionError
__________________________ test_iso_detection[alt8.1] __________________________

testdata = ('alt8.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.1/alt-kworkstation-8.1-install-i586....iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.1/alt-workstation-8.1-x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.1/alt-kworkstation-8.1-install-i586.iso.txt
E           Matched=[] but expected=['alt8.1']

../tests/test_isoinfo.py:63: AssertionError
__________________________ test_iso_detection[alt8.2] __________________________

testdata = ('alt8.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.2/alt-workstation-8.2-x86_64.iso.txt...iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.2/alt-server-8.2-x86_64.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt8.2/alt-workstation-8.2-x86_64.iso.txt
E           Matched=[] but expected=['alt8.2']

../tests/test_isoinfo.py:63: AssertionError
__________________________ test_iso_detection[alt.p8] __________________________

testdata = ('alt.p8', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt.p8/alt-p8-kde5-20180912-x86_64.iso.tx...t', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt.p8/alt-p8-jeos-20180912-x86_64.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt.p8/alt-p8-kde5-20180912-x86_64.iso.txt
E           Matched=[] but expected=['alt.p8']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[alt.sisyphus] _______________________

testdata = ('alt.sisyphus', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt.sisyphus/regular-xfce-20181017-.../var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt.sisyphus/regular-kde5-20181017-i586.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/alt/alt.sisyphus/regular-xfce-20181017-i586.iso.txt
E           Matched=[] but expected=['alt.sisyphus']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[altlinux4.0] ________________________

testdata = ('altlinux4.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/altlinux/altlinux4.0/altlinux-4.0.3-lite.../libosinfo/upstream/osinfo-db/tests/isodata/altlinux/altlinux4.0/altlinux-4.0.3-lite-i586-install_uk-cd.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/altlinux/altlinux4.0/altlinux-4.0.3-lite-i586-install_ru-cd.iso.txt
E           Matched=[] but expected=['altlinux4.0']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[altlinux4.1] ________________________

testdata = ('altlinux4.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/altlinux/altlinux4.1/altlinux-4.1.1-desk...src/libosinfo/upstream/osinfo-db/tests/isodata/altlinux/altlinux4.1/altlinux-4.1.1-desktop-i586-install-dvd5.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/altlinux/altlinux4.1/altlinux-4.1.1-desktop-i586-install-cd.iso.txt
E           Matched=[] but expected=['altlinux4.1']

../tests/test_isoinfo.py:63: AssertionError
_____________________ test_iso_detection[android-x86-8.1] ______________________

testdata = ('android-x86-8.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/android-x86/android-x86-8.1/android-...ar/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/android-x86/android-x86-8.1/android-x86_64-8.1-rc2.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/android-x86/android-x86-8.1/android-x86-8.1-rc2.iso.txt
E           Matched=[] but expected=['android-x86-8.1']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[archlinux] _________________________

testdata = ('archlinux', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/archlinux/archlinux/archlinux-2019.02.01-x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/archlinux/archlinux/archlinux-2019.02.01-x86_64.iso.txt
E           Matched=[] but expected=['archlinux']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[asianux4.6] ________________________

testdata = ('asianux4.6', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux4.6/asianux-4.6-i386.iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux4.6/asianux-4.6-x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux4.6/asianux-4.6-i386.iso.txt
E           Matched=[] but expected=['asianux4.6']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[asianux4.7] ________________________

testdata = ('asianux4.7', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux4.7/asianux-4.7-x86_64.iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux4.7/asianux-4.7-i386.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux4.7/asianux-4.7-x86_64.iso.txt
E           Matched=[] but expected=['asianux4.7']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[asianux7.0] ________________________

testdata = ('asianux7.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux7.0/asianux-7.0.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux7.0/asianux-7.0.iso.txt
E           Matched=[] but expected=['asianux7.0']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[asianux7.1] ________________________

testdata = ('asianux7.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux7.1/asianux-7.1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux7.1/asianux-7.1.iso.txt
E           Matched=[] but expected=['asianux7.1']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[asianux7.2] ________________________

testdata = ('asianux7.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux7.2/asianux-7.2.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/asianux/asianux7.2/asianux-7.2.iso.txt
E           Matched=[] but expected=['asianux7.2']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[caasp1.0] _________________________

testdata = ('caasp1.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/caasp/caasp1.0/SUSE-CaaS-Platform-1.0-DVD-x86_64-GM-DVD1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/caasp/caasp1.0/SUSE-CaaS-Platform-1.0-DVD-x86_64-GM-DVD1.iso.txt
E           Matched=[] but expected=['caasp1.0']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[caasp2.0] _________________________

testdata = ('caasp2.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/caasp/caasp2.0/SUSE-CaaS-Platform-2.0-DVD-x86_64-GM-DVD1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/caasp/caasp2.0/SUSE-CaaS-Platform-2.0-DVD-x86_64-GM-DVD1.iso.txt
E           Matched=[] but expected=['caasp2.0']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[caasp3.0] _________________________

testdata = ('caasp3.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/caasp/caasp3.0/SUSE-CaaS-Platform-3.0-DVD-x86_64-GM-DVD1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/caasp/caasp3.0/SUSE-CaaS-Platform-3.0-DVD-x86_64-GM-DVD1.iso.txt
E           Matched=[] but expected=['caasp3.0']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[centos6.10] ________________________

testdata = ('centos6.10', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.10/CentOS-6.10-x86_64-mini.../var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.10/CentOS-6.10-i386-bin-DVD1.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.10/CentOS-6.10-x86_64-minimal.iso.txt
E           Matched=[] but expected=['centos6.10']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[centos6.6] _________________________

testdata = ('centos6.6', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.6/CentOS-6.6-x86_64-bin-DVD...tall.iso', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.6/CentOS-6.6-i386-minimal.iso'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.6/CentOS-6.6-x86_64-bin-DVD1.iso
E           Matched=[] but expected=['centos6.6']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[centos6.7] _________________________

testdata = ('centos6.7', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.7/CentOS-6.7-i386-bin-DVD1.....iso', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.7/CentOS-6.7-i386-LiveCD.iso', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos6.7/CentOS-6.7-i386-bin-DVD1.iso
E           Matched=[] but expected=['centos6.7']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[centos7.0] _________________________

testdata = ('centos7.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos7.0/CentOS-7-x86_64-DVD.iso.t...src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos7.0/CentOS-7-x86_64-LiveGNOME-new-volume-id.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos7.0/CentOS-7-x86_64-LiveKDE.iso.txt
E           Matched=[] but expected=['centos7.0']

../tests/test_isoinfo.py:63: AssertionError
------------------------------ Captured log call -------------------------------
test_isoinfo.py             51 INFO     ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/centos/centos7.0/CentOS-7-x86_64-DVD.iso.txt' matched by OS 'centos7.0'
_________________________ test_iso_detection[debian8] __________________________

testdata = ('debian8', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/debian/debian8/debian-8.9.0-arm64-DVD-1.iso....', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/debian/debian8/debian-8.9.0-s390x-DVD-1.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/debian/debian8/debian-8.9.0-arm64-DVD-1.iso.txt
E           Matched=[] but expected=['debian8']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[debian9] __________________________

testdata = ('debian9', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/debian/debian9/debian-9.7.0-ppc64el-DVD-1.is....iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/debian/debian9/debian-9.0-armhf.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/debian/debian9/debian-9.7.0-ppc64el-DVD-1.iso.txt
E           Matched=[] but expected=['debian9']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[dragonflybsd5.0.0] _____________________

testdata = ('dragonflybsd5.0.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.0.0/dfly-x86_64-5.0.0_REL.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.0.0/dfly-x86_64-5.0.0_REL.iso.txt
E           Matched=[] but expected=['dragonflybsd5.0.0']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[dragonflybsd5.0.1] _____________________

testdata = ('dragonflybsd5.0.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.0.1/dfly-x86_64-5.0.1_REL.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.0.1/dfly-x86_64-5.0.1_REL.iso.txt
E           Matched=[] but expected=['dragonflybsd5.0.1']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[dragonflybsd5.0.2] _____________________

testdata = ('dragonflybsd5.0.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.0.2/dfly-x86_64-5.0.2_REL.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.0.2/dfly-x86_64-5.0.2_REL.iso.txt
E           Matched=[] but expected=['dragonflybsd5.0.2']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[dragonflybsd5.2.0] _____________________

testdata = ('dragonflybsd5.2.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.2.0/dfly-x86_64-5.2.0_REL.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.2.0/dfly-x86_64-5.2.0_REL.iso.txt
E           Matched=[] but expected=['dragonflybsd5.2.0']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[dragonflybsd5.2.1] _____________________

testdata = ('dragonflybsd5.2.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.2.1/dfly-x86_64-5.2.1_REL.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.2.1/dfly-x86_64-5.2.1_REL.iso.txt
E           Matched=[] but expected=['dragonflybsd5.2.1']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[dragonflybsd5.2.2] _____________________

testdata = ('dragonflybsd5.2.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.2.2/dfly-x86_64-5.2.2_REL.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.2.2/dfly-x86_64-5.2.2_REL.iso.txt
E           Matched=[] but expected=['dragonflybsd5.2.2']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[dragonflybsd5.4.0] _____________________

testdata = ('dragonflybsd5.4.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.4.0/dfly-x86_64-5.4.0_REL.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.4.0/dfly-x86_64-5.4.0_REL.iso.txt
E           Matched=[] but expected=['dragonflybsd5.4.0']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[dragonflybsd5.4.1] _____________________

testdata = ('dragonflybsd5.4.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.4.1/dfly-x86_64-5.4.1_REL.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/dragonflybsd/dragonflybsd5.4.1/dfly-x86_64-5.4.1_REL.iso.txt
E           Matched=[] but expected=['dragonflybsd5.4.1']

../tests/test_isoinfo.py:63: AssertionError
__________________________ test_iso_detection[eos3.4] __________________________

testdata = ('eos3.4', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/eos/eos3.4/eos-eos3.4-amd64-amd64.180515-0501...ch/src/libosinfo/upstream/osinfo-db/tests/isodata/eos/eos3.4/eos-eos3.4-amd64-amd64.180515-061343.es_MX.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/eos/eos3.4/eos-eos3.4-amd64-amd64.180515-050141.en.iso.txt
E           Matched=[] but expected=['eos3.4']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[fedora23] _________________________

testdata = ('fedora23', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora23/Fedora-Server-DVD-x86_64-23...h/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora23/Fedora-Live-Workstation-i686-23_Beta-1.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora23/Fedora-Workstation-netinst-i386-23_Beta.iso.txt
E           Matched=[] but expected=['fedora23']

../tests/test_isoinfo.py:63: AssertionError
------------------------------ Captured log call -------------------------------
test_isoinfo.py             51 INFO     ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora23/Fedora-Server-DVD-x86_64-23.iso.txt' matched by OS 'fedora23'
test_isoinfo.py             51 INFO     ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora23/Fedora-Server-netinst-i386-23.iso.txt' matched by OS 'fedora23'
test_isoinfo.py             51 INFO     ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora23/Fedora-Live-Workstation-x86_64-23_Beta-1.iso.txt' matched by OS 'fedora23'
_________________________ test_iso_detection[fedora26] _________________________

testdata = ('fedora26', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora26/Fedora-Server-netinst-x86_6...'/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora26/Fedora-Server-dvd-x86_64-26-1.5.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora26/Fedora-Server-netinst-x86_64-26-1.5.iso.txt
E           Matched=[] but expected=['fedora26']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[fedora27] _________________________

testdata = ('fedora27', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora27/Fedora-Server-dvd-x86_64-27...scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora27/Fedora-Workstation-Live-x86_64-27-1.6.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora27/Fedora-Server-dvd-x86_64-27-1.6.iso.txt
E           Matched=[] but expected=['fedora27']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[fedora28] _________________________

testdata = ('fedora28', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora28/Fedora-Workstation-Live-x86...'/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora28/Fedora-Server-dvd-x86_64-28-1.1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora28/Fedora-Workstation-Live-x86_64-28-1.1.iso.txt
E           Matched=[] but expected=['fedora28']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[fedora29] _________________________

testdata = ('fedora29', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora29/Fedora-Server-netinst-x86_6...atch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora29/Fedora-Workstation-netinst-x86_64-29-1.2.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/fedora29/Fedora-Server-netinst-x86_64-29-1.2.iso.txt
E           Matched=[] but expected=['fedora29']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[silverblue28] _______________________

testdata = ('silverblue28', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/silverblue28/Fedora-AtomicWorkstation-ostree-x86_64-28-1.1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/silverblue28/Fedora-AtomicWorkstation-ostree-x86_64-28-1.1.iso.txt
E           Matched=[] but expected=['silverblue28']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[silverblue29] _______________________

testdata = ('silverblue29', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/silverblue29/Fedora-Silverblue-ostree-x86_64-29-1.2.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/fedora/silverblue29/Fedora-Silverblue-ostree-x86_64-29-1.2.iso.txt
E           Matched=[] but expected=['silverblue29']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[freebsd10.4] ________________________

testdata = ('freebsd10.4', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd10.4/FreeBSD-10.4-RELEASE...ar/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd10.4/FreeBSD-10.4-RELEASE-i386-dvd1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd10.4/FreeBSD-10.4-RELEASE-amd64-dvd1.iso.txt
E           Matched=[] but expected=['freebsd10.4']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[freebsd11.1] ________________________

testdata = ('freebsd11.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd11.1/FreeBSD-11.1-RELEASE...ar/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd11.1/FreeBSD-11.1-RELEASE-i386-dvd1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd11.1/FreeBSD-11.1-RELEASE-i386-disc1.iso.txt
E           Matched=[] but expected=['freebsd11.1']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[freebsd11.2] ________________________

testdata = ('freebsd11.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd11.2/FreeBSD-11.2-RELEASE...r/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd11.2/FreeBSD-11.2-RELEASE-i386-disc1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd11.2/FreeBSD-11.2-RELEASE-amd64-disc1.iso.txt
E           Matched=[] but expected=['freebsd11.2']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[freebsd12.0] ________________________

testdata = ('freebsd12.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd12.0/FreeBSD-12.0-RELEASE...ar/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd12.0/FreeBSD-12.0-RELEASE-i386-dvd1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freebsd/freebsd12.0/FreeBSD-12.0-RELEASE-i386-disc1.iso.txt
E           Matched=[] but expected=['freebsd12.0']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[freedos1.2] ________________________

testdata = ('freedos1.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freedos/freedos1.2/FD12LGCY.iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freedos/freedos1.2/FD12CD.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/freedos/freedos1.2/FD12LGCY.iso.txt
E           Matched=[] but expected=['freedos1.2']

../tests/test_isoinfo.py:63: AssertionError
__________________________ test_iso_detection[gentoo] __________________________

testdata = ('gentoo', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/gentoo/gentoo/install-x86-minimal-20190214T18.../scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/gentoo/gentoo/install-amd64-minimal-20190212T214502Z.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/gentoo/gentoo/install-x86-minimal-20190214T185527Z.iso.txt
E           Matched=[] but expected=['gentoo']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[haikunightly] _______________________

testdata = ('haikunightly', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikunightly/haiku-nightly-anyboo...', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikunightly/haiku-nightly-anyboot-x86.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikunightly/haiku-nightly-anyboot-x86_64.iso.txt
E           Matched=[] but expected=['haikunightly']

../tests/test_isoinfo.py:63: AssertionError
______________________ test_iso_detection[haikur1alpha1] _______________________

testdata = ('haikur1alpha1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1alpha1/haiku-r1alpha1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1alpha1/haiku-r1alpha1.iso.txt
E           Matched=[] but expected=['haikur1alpha1']

../tests/test_isoinfo.py:63: AssertionError
______________________ test_iso_detection[haikur1alpha2] _______________________

testdata = ('haikur1alpha2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1alpha2/haiku-r1alpha2-sources.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1alpha2/haiku-r1alpha2-sources.iso.txt
E           Matched=[] but expected=['haikur1alpha2']

../tests/test_isoinfo.py:63: AssertionError
______________________ test_iso_detection[haikur1alpha3] _______________________

testdata = ('haikur1alpha3', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1alpha3/haiku-r1alpha3.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1alpha3/haiku-r1alpha3.iso.txt
E           Matched=[] but expected=['haikur1alpha3']

../tests/test_isoinfo.py:63: AssertionError
_____________________ test_iso_detection[haikur1alpha4.1] ______________________

testdata = ('haikur1alpha4.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1alpha4.1/haiku-r1alpha4.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1alpha4.1/haiku-r1alpha4.iso.txt
E           Matched=[] but expected=['haikur1alpha4.1']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[haikur1beta1] _______________________

testdata = ('haikur1beta1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1beta1/haiku-release-anyboo...'/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1beta1/haiku-release-anyboot-x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/haiku/haikur1beta1/haiku-release-anyboot-x86.iso.txt
E           Matched=[] but expected=['haikur1beta1']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[mageia6] __________________________

testdata = ('mageia6', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/mageia/mageia6/Mageia-6-LiveDVD-Xfce-x86_64-...var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/mageia/mageia6/Mageia-6-LiveDVD-Plasma-x86_64-DVD.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/mageia/mageia6/Mageia-6-LiveDVD-Xfce-x86_64-DVD.iso.txt
E           Matched=[] but expected=['mageia6']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[netbsd6.0] _________________________

testdata = ('netbsd6.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd6.0/NetBSD-6.0-amd64-boot-com...so.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd6.0/NetBSD-6.0-amd64-boot.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd6.0/NetBSD-6.0-amd64-boot-com.iso.txt
E           Matched=[] but expected=['netbsd6.0']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[netbsd6.1] _________________________

testdata = ('netbsd6.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd6.1/NetBSD-6.1-i386.iso.txt',...xt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd6.1/NetBSD-6.1-amd64-boot-com.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd6.1/NetBSD-6.1-i386.iso.txt
E           Matched=[] but expected=['netbsd6.1']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[netbsd7.0] _________________________

testdata = ('netbsd7.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.0/NetBSD-7.0-i386.iso.txt',...iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.0/NetBSD-7.0-i386-boot.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.0/NetBSD-7.0-i386.iso.txt
E           Matched=[] but expected=['netbsd7.0']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[netbsd7.1] _________________________

testdata = ('netbsd7.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1/NetBSD-7.1-i386.iso.txt',...oot.iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1/NetBSD-7.1-amd64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1/NetBSD-7.1-i386.iso.txt
E           Matched=[] but expected=['netbsd7.1']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[netbsd7.1.1] ________________________

testdata = ('netbsd7.1.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1.1/NetBSD-7.1.1-amd64-bo..., '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1.1/NetBSD-7.1.1-i386-boot-com.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1.1/NetBSD-7.1.1-amd64-boot.iso.txt
E           Matched=[] but expected=['netbsd7.1.1']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[netbsd7.1.2] ________________________

testdata = ('netbsd7.1.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1.2/NetBSD-7.1.2-i386-boo....iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1.2/NetBSD-7.1.2-i386.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.1.2/NetBSD-7.1.2-i386-boot-com.iso.txt
E           Matched=[] but expected=['netbsd7.1.2']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[netbsd7.2] _________________________

testdata = ('netbsd7.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.2/NetBSD-7.2-amd64-boot-com...oot.iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.2/NetBSD-7.2-amd64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd7.2/NetBSD-7.2-amd64-boot-com.iso.txt
E           Matched=[] but expected=['netbsd7.2']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[netbsd8.0] _________________________

testdata = ('netbsd8.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd8.0/NetBSD-8.0-i386-boot.iso....so.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd8.0/NetBSD-8.0-amd64-boot.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/netbsd/netbsd8.0/NetBSD-8.0-i386-boot.iso.txt
E           Matched=[] but expected=['netbsd8.0']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd4.2] ________________________

testdata = ('openbsd4.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.2/openbsd-4.2-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.2/openbsd-4.2-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.2/openbsd-4.2-amd64.txt
E           Matched=[] but expected=['openbsd4.2']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd4.3] ________________________

testdata = ('openbsd4.3', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.3/openbsd-4.3-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.3/openbsd-4.3-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.3/openbsd-4.3-amd64.txt
E           Matched=[] but expected=['openbsd4.3']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd4.4] ________________________

testdata = ('openbsd4.4', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.4/openbsd-4.4-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.4/openbsd-4.4-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.4/openbsd-4.4-amd64.txt
E           Matched=[] but expected=['openbsd4.4']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd4.5] ________________________

testdata = ('openbsd4.5', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.5/openbsd-4.5-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.5/openbsd-4.5-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.5/openbsd-4.5-amd64.txt
E           Matched=[] but expected=['openbsd4.5']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd4.8] ________________________

testdata = ('openbsd4.8', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.8/openbsd-4.8-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.8/openbsd-4.8-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.8/openbsd-4.8-amd64.txt
E           Matched=[] but expected=['openbsd4.8']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd4.9] ________________________

testdata = ('openbsd4.9', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.9/openbsd-4.9-i386.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.9/openbsd-4.9-amd64.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd4.9/openbsd-4.9-i386.txt
E           Matched=[] but expected=['openbsd4.9']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.0] ________________________

testdata = ('openbsd5.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.0/openbsd-5.0-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.0/openbsd-5.0-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.0/openbsd-5.0-amd64.txt
E           Matched=[] but expected=['openbsd5.0']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.1] ________________________

testdata = ('openbsd5.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.1/openbsd-5.1-i386.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.1/openbsd-5.1-amd64.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.1/openbsd-5.1-i386.txt
E           Matched=[] but expected=['openbsd5.1']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.2] ________________________

testdata = ('openbsd5.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.2/openbsd-5.2-i386.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.2/openbsd-5.2-amd64.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.2/openbsd-5.2-i386.txt
E           Matched=[] but expected=['openbsd5.2']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.3] ________________________

testdata = ('openbsd5.3', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.3/openbsd-5.3-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.3/openbsd-5.3-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.3/openbsd-5.3-amd64.txt
E           Matched=[] but expected=['openbsd5.3']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.4] ________________________

testdata = ('openbsd5.4', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.4/openbsd-5.4-i386.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.4/openbsd-5.4-amd64.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.4/openbsd-5.4-i386.txt
E           Matched=[] but expected=['openbsd5.4']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.5] ________________________

testdata = ('openbsd5.5', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.5/openbsd-5.5-i386.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.5/openbsd-5.5-amd64.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.5/openbsd-5.5-i386.txt
E           Matched=[] but expected=['openbsd5.5']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.6] ________________________

testdata = ('openbsd5.6', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.6/openbsd-5.6-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.6/openbsd-5.6-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.6/openbsd-5.6-amd64.txt
E           Matched=[] but expected=['openbsd5.6']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.7] ________________________

testdata = ('openbsd5.7', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.7/openbsd-5.7-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.7/openbsd-5.7-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.7/openbsd-5.7-amd64.txt
E           Matched=[] but expected=['openbsd5.7']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.8] ________________________

testdata = ('openbsd5.8', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.8/openbsd-5.8-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.8/openbsd-5.8-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.8/openbsd-5.8-amd64.txt
E           Matched=[] but expected=['openbsd5.8']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd5.9] ________________________

testdata = ('openbsd5.9', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.9/openbsd-5.9-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.9/openbsd-5.9-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd5.9/openbsd-5.9-amd64.txt
E           Matched=[] but expected=['openbsd5.9']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd6.0] ________________________

testdata = ('openbsd6.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.0/openbsd-6.0-i386.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.0/openbsd-6.0-amd64.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.0/openbsd-6.0-i386.txt
E           Matched=[] but expected=['openbsd6.0']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd6.1] ________________________

testdata = ('openbsd6.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.1/openbsd-6.1-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.1/openbsd-6.1-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.1/openbsd-6.1-amd64.txt
E           Matched=[] but expected=['openbsd6.1']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd6.2] ________________________

testdata = ('openbsd6.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.2/openbsd-6.2-amd64.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.2/openbsd-6.2-i386.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.2/openbsd-6.2-amd64.txt
E           Matched=[] but expected=['openbsd6.2']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd6.3] ________________________

testdata = ('openbsd6.3', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.3/openbsd-6.3-i386.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.3/openbsd-6.3-amd64.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.3/openbsd-6.3-i386.txt
E           Matched=[] but expected=['openbsd6.3']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[openbsd6.4] ________________________

testdata = ('openbsd6.4', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.4/openbsd-6.4-i386.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.4/openbsd-6.4-amd64.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/openbsd/openbsd6.4/openbsd-6.4-i386.txt
E           Matched=[] but expected=['openbsd6.4']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[opensuse15.0] _______________________

testdata = ('opensuse15.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse15.0/openSUSE-Leap-15....r/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse15.0/openSUSE-Leap-15.0-NET-x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse15.0/openSUSE-Leap-15.0-DVD-x86_64.iso.txt
E           Matched=['opensuse-unknown'] but expected=['opensuse15.0']

../tests/test_isoinfo.py:63: AssertionError
------------------------------ Captured log call -------------------------------
test_isoinfo.py             48 WARNING  ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse15.0/openSUSE-Leap-15.0-DVD-x86_64.iso.txt' was matched by OS 'opensuse-unknown' while it should only be matched by OS 'opensuse15.0'
test_isoinfo.py             48 WARNING  ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse15.0/openSUSE-Leap-15.0-DVD-x86_64.iso.txt' was matched by OS 'opensuse-unknown' while it should only be matched by OS 'opensuse15.0'
_______________________ test_iso_detection[opensuse15.1] _______________________

testdata = ('opensuse15.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse15.1/openSUSE-Leap-15....osinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse15.1/openSUSE-Leap-15.1-DVD-x86_64-Build438.2-Media.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse15.1/openSUSE-Leap-15.1-GNOME-Live-x86_64-Snapshot6.7-Media.iso.txt
E           Matched=[] but expected=['opensuse15.1']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[opensuse42.3] _______________________

testdata = ('opensuse42.3', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse42.3/openSUSE-Leap-42....r/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse42.3/openSUSE-Leap-42.3-DVD-x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensuse42.3/openSUSE-Leap-42.3-NET-x86_64.iso.txt
E           Matched=[] but expected=['opensuse42.3']

../tests/test_isoinfo.py:63: AssertionError
____________________ test_iso_detection[opensusetumbleweed] ____________________

testdata = ('opensusetumbleweed', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensusetumbleweed/openS...stream/osinfo-db/tests/isodata/opensuse/opensusetumbleweed/openSUSE-Tumbleweed-NET-x86_64-Snapshot20180420-Media.iso'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/opensuse/opensusetumbleweed/openSUSE-Tumbleweed-NET-i586-Snapshot20180420-Media.iso.txt
E           Matched=[] but expected=['opensusetumbleweed']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[popos17.10] ________________________

testdata = ('popos17.10', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos17.10/pop-os_amd64_nvidia_46.iso.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos17.10/pop-os_amd64_intel_57.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos17.10/pop-os_amd64_nvidia_46.iso.txt
E           Matched=[] but expected=['popos17.10']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[popos18.04] ________________________

testdata = ('popos18.04', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos18.04/pop-os_18.04_amd64_nvidi...', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos18.04/pop-os_18.04_amd64_intel_32.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos18.04/pop-os_18.04_amd64_nvidia_32.iso.txt
E           Matched=[] but expected=['popos18.04']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[popos18.10] ________________________

testdata = ('popos18.10', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos18.10/pop-os_18.10_amd64_nvidi...t', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos18.10/pop-os_18.10_amd64_intel_3.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/popos/popos18.10/pop-os_18.10_amd64_nvidia_3.iso.txt
E           Matched=[] but expected=['popos18.10']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[pureos8] __________________________

testdata = ('pureos8', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/pureos/pureos8/pureos-8.0-gnome-live_2018090...ch/src/libosinfo/upstream/osinfo-db/tests/isodata/pureos/pureos8/pureos-8.0-gnome-live_20181210-amd64.hybrid.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/pureos/pureos8/pureos-8.0-gnome-live_20180904-amd64.hybrid.iso.txt
E           Matched=[] but expected=['pureos8']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[rhel6.10] _________________________

testdata = ('rhel6.10', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel6.10/RHEL-6.10-20180525.0-Server-i.../scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel6.10/RHEL-6.10-20180525.0-Server-ppc64-dvd1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel6.10/RHEL-6.10-20180525.0-Server-i386-dvd1.iso.txt
E           Matched=[] but expected=['rhel6.10']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[rhel7.4] __________________________

testdata = ('rhel7.4', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.4/RHEL-7.4-20170711.0-Server-ppc6...ar/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.4/RHEL-7.4-20170711.0-Server-s390x-dvd1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.4/RHEL-7.4-20170711.0-Server-ppc64-dvd1.iso.txt
E           Matched=[] but expected=['rhel7.4']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[rhel7.5] __________________________

testdata = ('rhel7.5', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.5/RHEL-7.5-20180322.0-Server-ppc6.../scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.5/RHEL-7.5-20180322.0-Server-ppc64le-dvd1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.5/RHEL-7.5-20180322.0-Server-ppc64-dvd1.iso.txt
E           Matched=[] but expected=['rhel7.5']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[rhel7.6] __________________________

testdata = ('rhel7.6', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.6/RHEL-7.6-20181010.0-Workstation...tch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.6/RHEL-7.6-20181010.0-Server-ppc64le-boot.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel7.6/RHEL-7.6-20181010.0-Workstation-x86_64-dvd1.iso.txt
E           Matched=[] but expected=['rhel7.6']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[rhel8.0] __________________________

testdata = ('rhel8.0', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel8.0/RHEL-8.0-20181113.1-aarch64-dvd.../var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel8.0/RHEL-8.0-20181113.1-s390x-boot.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel8.0/RHEL-8.0-20181113.1-aarch64-dvd1.iso.txt
E           Matched=[] but expected=['rhel8.0']

../tests/test_isoinfo.py:63: AssertionError
_____________________ test_iso_detection[rhel-atomic-7.1] ______________________

testdata = ('rhel-atomic-7.1', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.1/rhel-atomic-ins...ratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.1/rhel-atomic-installer-7.1-0.x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.1/rhel-atomic-installer-7.1-1.x86_64.iso.txt
E           Matched=['rhel-atomic-7.0', 'rhel-atomic-7.1'] but expected=['rhel-atomic-7.1']

../tests/test_isoinfo.py:63: AssertionError
------------------------------ Captured log call -------------------------------
test_isoinfo.py             48 WARNING  ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.1/rhel-atomic-installer-7.1-1.x86_64.iso.txt' was matched by OS 'rhel-atomic-7.0' while it should only be matched by OS 'rhel-atomic-7.1'
test_isoinfo.py             51 INFO     ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.1/rhel-atomic-installer-7.1-1.x86_64.iso.txt' matched by OS 'rhel-atomic-7.1'
_____________________ test_iso_detection[rhel-atomic-7.2] ______________________

testdata = ('rhel-atomic-7.2', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.2/rhel-atomic-ins...atch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.2/rhel-atomic-installer-7.2-10.x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.2/rhel-atomic-installer-7.2-11.x86_64.iso.txt
E           Matched=[] but expected=['rhel-atomic-7.2']

../tests/test_isoinfo.py:63: AssertionError
_____________________ test_iso_detection[rhel-atomic-7.3] ______________________

testdata = ('rhel-atomic-7.3', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.3/rhel-atomic-ins...tch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.3/rhel-atomic-installer-7.3.1-1.x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.3/rhel-atomic-installer-7.3.0-3.x86_64.iso.txt
E           Matched=[] but expected=['rhel-atomic-7.3']

../tests/test_isoinfo.py:63: AssertionError
_____________________ test_iso_detection[rhel-atomic-7.4] ______________________

testdata = ('rhel-atomic-7.4', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.4/rhel-atomic-installer-7.4.0-1.x86_64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/rhel/rhel-atomic-7.4/rhel-atomic-installer-7.4.0-1.x86_64.iso.txt
E           Matched=[] but expected=['rhel-atomic-7.4']

../tests/test_isoinfo.py:63: AssertionError
__________________________ test_iso_detection[sle15] ___________________________

testdata = ('sle15', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/sle/sle15/SLE-15-Installer-DVD-aarch64-GM-DVD1...', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/sle/sle15/SLE-15-Installer-DVD-s390x-GM-DVD1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/sle/sle15/SLE-15-Installer-DVD-aarch64-GM-DVD1.iso.txt
E           Matched=[] but expected=['sle15']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[sled12sp3] _________________________

testdata = ('sled12sp3', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/sled/sled12sp3/SLE-12-SP3-Desktop-DVD-x86_64-GM-DVD1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/sled/sled12sp3/SLE-12-SP3-Desktop-DVD-x86_64-GM-DVD1.iso.txt
E           Matched=[] but expected=['sled12sp3']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[sles12sp3] _________________________

testdata = ('sles12sp3', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/sles/sles12sp3/SLE-12-SP3-Server-DVD-aarch...ar/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/sles/sles12sp3/SLE-12-SP3-Server-DVD-s390x-GM-DVD1.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/sles/sles12sp3/SLE-12-SP3-Server-DVD-aarch64-GM-DVD1.iso.txt
E           Matched=[] but expected=['sles12sp3']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[ubuntu17.10] ________________________

testdata = ('ubuntu17.10', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu17.10/ubuntu-17.10-server-a...', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu17.10/ubuntu-17.10-server-amd64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu17.10/ubuntu-17.10-server-arm64.iso.txt
E           Matched=[] but expected=['ubuntu17.10']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[ubuntu18.04] ________________________

testdata = ('ubuntu18.04', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu18.04/ubuntu-18.04.1.0-live...var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu18.04/ubuntu-18.04-server-amd64.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu18.04/ubuntu-18.04.1.0-live-server-amd64.iso.txt
E           Matched=[] but expected=['ubuntu18.04']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[ubuntu18.10] ________________________

testdata = ('ubuntu18.10', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu18.10/cosmic-live-server-am...o.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu18.10/cosmic-desktop-amd64.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu18.10/cosmic-live-server-amd64.iso.txt
E           Matched=[] but expected=['ubuntu18.10']

../tests/test_isoinfo.py:63: AssertionError
_______________________ test_iso_detection[ubuntu19.04] ________________________

testdata = ('ubuntu19.04', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu19.04/disco-server-arm64.is...o.txt', '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu19.04/disco-server-ppc64el.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/ubuntu/ubuntu19.04/disco-server-arm64.iso.txt
E           Matched=[] but expected=['ubuntu19.04']

../tests/test_isoinfo.py:63: AssertionError
________________________ test_iso_detection[voidlinux] _________________________

testdata = ('voidlinux', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/voidlinux/voidlinux/void-live-i686-2018111..., '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/voidlinux/voidlinux/void-live-x86_64-20181111.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/voidlinux/voidlinux/void-live-i686-20181111.iso.txt
E           Matched=[] but expected=['voidlinux']

../tests/test_isoinfo.py:63: AssertionError
_________________________ test_iso_detection[win2k16] __________________________

testdata = ('win2k16', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/win/win2k16/14393.0.161119-1705.RS1_REFRESH_...ar/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/win/win2k16/en_windows_server_2016_x64_dvd_9718492.iso.txt'])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/win/win2k16/14393.0.161119-1705.RS1_REFRESH_SERVERHYPERCORE_OEM_X64FRE_EN-US.ISO.txt
E           Matched=[] but expected=['win2k16']

../tests/test_isoinfo.py:63: AssertionError
__________________________ test_iso_detection[win10] ___________________________

testdata = ('win10', ['/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/win/win10/fr_windows_10_enterprise_version_160...libosinfo/upstream/osinfo-db/tests/isodata/win/win10/en_windows_10_enterprise_2015_ltsb_x64_dvd_6848446.iso.txt', ...])

    @pytest.mark.parametrize(&quot;testdata&quot;, _get_isodatapaths(), ids=lambda d: d[0])
    def test_iso_detection(testdata):
        osname, isodatapaths = testdata
        for isodatapath in isodatapaths:
            if isodatapath.endswith(&quot;.lng&quot;):
                # libosinfo handled these specially, we should too
                continue
    
            detected = []
            isodatamedia = isodata.get_isodatamedia(isodatapath)
            for osxml2 in util.DataFiles.oses():
                for media in osxml2.medias:
                    if isodatamedia.match(media.iso):
                        if osname != osxml2.shortid:
                            logging.warning(
                                'ISO \'%s\' was matched by OS \'%s\' while it '
                                'should only be matched by OS \'%s\'',
                                isodatamedia.filename, osxml2.shortid, osname)
                        else:
                            logging.info('ISO \'%s\' matched by OS \'%s\'',
                                         isodatamedia.filename, osxml2.shortid)
                        # For several distros we do not have the volume-size
                        # set as part of our DB, thus multiple detections may
                        # occur. Although this case is not the optimal, as long
                        # as we detect the very same distro it's okay-ish.
                        if osxml2.shortid not in detected:
                            detected.append(osxml2.shortid)
    
            if detected == [osname]:
                continue
    
            raise AssertionError(&quot;isodata: %s\nMatched=%s but expected=%s&quot; %
&gt;                   (isodatapath, detected, [osname]))
E           AssertionError: isodata: /var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/win/win10/en_windows_10_multi-edition_version_1709_updated_sept_2017_x64_dvd_100090817.iso.txt
E           Matched=[] but expected=['win10']

../tests/test_isoinfo.py:63: AssertionError
------------------------------ Captured log call -------------------------------
test_isoinfo.py             51 INFO     ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/win/win10/fr_windows_10_enterprise_version_1607_updated_jul_2016_x86_dvd_9057460.iso.txt' matched by OS 'win10'
test_isoinfo.py             51 INFO     ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/win/win10/en_windows_10_n_multiple_editions_x64_dvd_6846434.iso.txt' matched by OS 'win10'
test_isoinfo.py             51 INFO     ISO '/var/scratch/src/libosinfo/upstream/osinfo-db/tests/isodata/win/win10/en_windows_10_enterprise_n_x64_dvd_6852541.iso.txt' matched by OS 'win10'
__________________________ test_resources[centos7.0] ___________________________

osxml = &lt;Os shortid=centos7.0&gt;

    @util.os_parametrize('osxml', filter_resources=True)
    def test_resources(osxml):
        _test_resources_uniqueness_by_arch(osxml)
    
        # Ensure minimum resources are &lt;= recommended resources
        _resources_helper(osxml,
                          osxml.get_minimum_resources,
                          'minimum',
                          osxml.get_recommended_resources,
&gt;                         'recommended')

../tests/test_resources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=centos7.0&gt;
smaller_func = &lt;bound method Os.get_minimum_resources of &lt;Os shortid=centos7.0&gt;&gt;
smaller_str = 'minimum'
bigger_func = &lt;bound method Os.get_recommended_resources of &lt;Os shortid=centos7.0&gt;&gt;
bigger_str = 'recommended'

    def _resources_helper(osxml,
                          smaller_func, smaller_str,
                          bigger_func, bigger_str):
        broken = []
        for resource in osxml.resources_list:
            logging.info(&quot;resources | arch: %s&quot;, resource.get('arch'))
            smaller = smaller_func(resource)
            bigger = bigger_func(resource)
    
            if smaller is None or bigger is None:
                continue
    
            if not _resources_check(smaller, smaller_str, bigger, bigger_str):
                broken.append([smaller, bigger])
&gt;       assert broken == []
E       assert [[&lt;tests.osin...f1517af8828&gt;]] == []
E         Left contains more items, first extra item: [&lt;tests.osinfo.Resources object at 0x7f1517af87f0&gt;, &lt;tests.osinfo.Resources object at 0x7f1517af8828&gt;]
E         Use -v to get the full diff

../tests/test_resources.py:69: AssertionError
------------------------------ Captured log call -------------------------------
test_resources.py           60 INFO     resources | arch: all
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           98 WARNING  storage value of minimum should not be bigger than recommended ('10737418240' &gt; '9663676416')
___________________________ test_resources[rhel7.0] ____________________________

osxml = &lt;Os shortid=rhel7.0&gt;

    @util.os_parametrize('osxml', filter_resources=True)
    def test_resources(osxml):
        _test_resources_uniqueness_by_arch(osxml)
    
        # Ensure minimum resources are &lt;= recommended resources
        _resources_helper(osxml,
                          osxml.get_minimum_resources,
                          'minimum',
                          osxml.get_recommended_resources,
&gt;                         'recommended')

../tests/test_resources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=rhel7.0&gt;
smaller_func = &lt;bound method Os.get_minimum_resources of &lt;Os shortid=rhel7.0&gt;&gt;
smaller_str = 'minimum'
bigger_func = &lt;bound method Os.get_recommended_resources of &lt;Os shortid=rhel7.0&gt;&gt;
bigger_str = 'recommended'

    def _resources_helper(osxml,
                          smaller_func, smaller_str,
                          bigger_func, bigger_str):
        broken = []
        for resource in osxml.resources_list:
            logging.info(&quot;resources | arch: %s&quot;, resource.get('arch'))
            smaller = smaller_func(resource)
            bigger = bigger_func(resource)
    
            if smaller is None or bigger is None:
                continue
    
            if not _resources_check(smaller, smaller_str, bigger, bigger_str):
                broken.append([smaller, bigger])
&gt;       assert broken == []
E       assert [[&lt;tests.osin...f1517af8080&gt;]] == []
E         Left contains more items, first extra item: [&lt;tests.osinfo.Resources object at 0x7f1517a6e978&gt;, &lt;tests.osinfo.Resources object at 0x7f1517a6e0f0&gt;]
E         Use -v to get the full diff

../tests/test_resources.py:69: AssertionError
------------------------------ Captured log call -------------------------------
test_resources.py           60 INFO     resources | arch: ppc64
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           60 INFO     resources | arch: all
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           98 WARNING  storage value of minimum should not be bigger than recommended ('10737418240' &gt; '9663676416')
___________________________ test_resources[rhel7.1] ____________________________

osxml = &lt;Os shortid=rhel7.1&gt;

    @util.os_parametrize('osxml', filter_resources=True)
    def test_resources(osxml):
        _test_resources_uniqueness_by_arch(osxml)
    
        # Ensure minimum resources are &lt;= recommended resources
        _resources_helper(osxml,
                          osxml.get_minimum_resources,
                          'minimum',
                          osxml.get_recommended_resources,
&gt;                         'recommended')

../tests/test_resources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=rhel7.1&gt;
smaller_func = &lt;bound method Os.get_minimum_resources of &lt;Os shortid=rhel7.1&gt;&gt;
smaller_str = 'minimum'
bigger_func = &lt;bound method Os.get_recommended_resources of &lt;Os shortid=rhel7.1&gt;&gt;
bigger_str = 'recommended'

    def _resources_helper(osxml,
                          smaller_func, smaller_str,
                          bigger_func, bigger_str):
        broken = []
        for resource in osxml.resources_list:
            logging.info(&quot;resources | arch: %s&quot;, resource.get('arch'))
            smaller = smaller_func(resource)
            bigger = bigger_func(resource)
    
            if smaller is None or bigger is None:
                continue
    
            if not _resources_check(smaller, smaller_str, bigger, bigger_str):
                broken.append([smaller, bigger])
&gt;       assert broken == []
E       assert [[&lt;tests.osin...f1517a786a0&gt;]] == []
E         Left contains more items, first extra item: [&lt;tests.osinfo.Resources object at 0x7f1517a788d0&gt;, &lt;tests.osinfo.Resources object at 0x7f1517a78550&gt;]
E         Use -v to get the full diff

../tests/test_resources.py:69: AssertionError
------------------------------ Captured log call -------------------------------
test_resources.py           60 INFO     resources | arch: ppc64
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           60 INFO     resources | arch: all
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           98 WARNING  storage value of minimum should not be bigger than recommended ('10737418240' &gt; '9663676416')
___________________________ test_resources[rhel7.2] ____________________________

osxml = &lt;Os shortid=rhel7.2&gt;

    @util.os_parametrize('osxml', filter_resources=True)
    def test_resources(osxml):
        _test_resources_uniqueness_by_arch(osxml)
    
        # Ensure minimum resources are &lt;= recommended resources
        _resources_helper(osxml,
                          osxml.get_minimum_resources,
                          'minimum',
                          osxml.get_recommended_resources,
&gt;                         'recommended')

../tests/test_resources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=rhel7.2&gt;
smaller_func = &lt;bound method Os.get_minimum_resources of &lt;Os shortid=rhel7.2&gt;&gt;
smaller_str = 'minimum'
bigger_func = &lt;bound method Os.get_recommended_resources of &lt;Os shortid=rhel7.2&gt;&gt;
bigger_str = 'recommended'

    def _resources_helper(osxml,
                          smaller_func, smaller_str,
                          bigger_func, bigger_str):
        broken = []
        for resource in osxml.resources_list:
            logging.info(&quot;resources | arch: %s&quot;, resource.get('arch'))
            smaller = smaller_func(resource)
            bigger = bigger_func(resource)
    
            if smaller is None or bigger is None:
                continue
    
            if not _resources_check(smaller, smaller_str, bigger, bigger_str):
                broken.append([smaller, bigger])
&gt;       assert broken == []
E       assert [[&lt;tests.osin...f1517a871d0&gt;]] == []
E         Left contains more items, first extra item: [&lt;tests.osinfo.Resources object at 0x7f1517a87f60&gt;, &lt;tests.osinfo.Resources object at 0x7f1517a870f0&gt;]
E         Use -v to get the full diff

../tests/test_resources.py:69: AssertionError
------------------------------ Captured log call -------------------------------
test_resources.py           60 INFO     resources | arch: ppc64
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           60 INFO     resources | arch: all
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           98 WARNING  storage value of minimum should not be bigger than recommended ('10737418240' &gt; '9663676416')
___________________________ test_resources[rhel7.3] ____________________________

osxml = &lt;Os shortid=rhel7.3&gt;

    @util.os_parametrize('osxml', filter_resources=True)
    def test_resources(osxml):
        _test_resources_uniqueness_by_arch(osxml)
    
        # Ensure minimum resources are &lt;= recommended resources
        _resources_helper(osxml,
                          osxml.get_minimum_resources,
                          'minimum',
                          osxml.get_recommended_resources,
&gt;                         'recommended')

../tests/test_resources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=rhel7.3&gt;
smaller_func = &lt;bound method Os.get_minimum_resources of &lt;Os shortid=rhel7.3&gt;&gt;
smaller_str = 'minimum'
bigger_func = &lt;bound method Os.get_recommended_resources of &lt;Os shortid=rhel7.3&gt;&gt;
bigger_str = 'recommended'

    def _resources_helper(osxml,
                          smaller_func, smaller_str,
                          bigger_func, bigger_str):
        broken = []
        for resource in osxml.resources_list:
            logging.info(&quot;resources | arch: %s&quot;, resource.get('arch'))
            smaller = smaller_func(resource)
            bigger = bigger_func(resource)
    
            if smaller is None or bigger is None:
                continue
    
            if not _resources_check(smaller, smaller_str, bigger, bigger_str):
                broken.append([smaller, bigger])
&gt;       assert broken == []
E       assert [[&lt;tests.osin...f1517a78ba8&gt;]] == []
E         Left contains more items, first extra item: [&lt;tests.osinfo.Resources object at 0x7f1517a78240&gt;, &lt;tests.osinfo.Resources object at 0x7f1517a78780&gt;]
E         Use -v to get the full diff

../tests/test_resources.py:69: AssertionError
------------------------------ Captured log call -------------------------------
test_resources.py           60 INFO     resources | arch: ppc64
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           60 INFO     resources | arch: all
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           98 WARNING  storage value of minimum should not be bigger than recommended ('10737418240' &gt; '9663676416')
_______________________ test_resources[rhel-atomic-7.0] ________________________

osxml = &lt;Os shortid=rhel-atomic-7.0&gt;

    @util.os_parametrize('osxml', filter_resources=True)
    def test_resources(osxml):
        _test_resources_uniqueness_by_arch(osxml)
    
        # Ensure minimum resources are &lt;= recommended resources
        _resources_helper(osxml,
                          osxml.get_minimum_resources,
                          'minimum',
                          osxml.get_recommended_resources,
&gt;                         'recommended')

../tests/test_resources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=rhel-atomic-7.0&gt;
smaller_func = &lt;bound method Os.get_minimum_resources of &lt;Os shortid=rhel-atomic-7.0&gt;&gt;
smaller_str = 'minimum'
bigger_func = &lt;bound method Os.get_recommended_resources of &lt;Os shortid=rhel-atomic-7.0&gt;&gt;
bigger_str = 'recommended'

    def _resources_helper(osxml,
                          smaller_func, smaller_str,
                          bigger_func, bigger_str):
        broken = []
        for resource in osxml.resources_list:
            logging.info(&quot;resources | arch: %s&quot;, resource.get('arch'))
            smaller = smaller_func(resource)
            bigger = bigger_func(resource)
    
            if smaller is None or bigger is None:
                continue
    
            if not _resources_check(smaller, smaller_str, bigger, bigger_str):
                broken.append([smaller, bigger])
&gt;       assert broken == []
E       assert [[&lt;tests.osin...f1517a8fe80&gt;]] == []
E         Left contains more items, first extra item: [&lt;tests.osinfo.Resources object at 0x7f1517a8f748&gt;, &lt;tests.osinfo.Resources object at 0x7f1517a8fe80&gt;]
E         Use -v to get the full diff

../tests/test_resources.py:69: AssertionError
------------------------------ Captured log call -------------------------------
test_resources.py           60 INFO     resources | arch: all
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           98 WARNING  storage value of minimum should not be bigger than recommended ('10737418240' &gt; '9663676416')
_______________________ test_resources[rhel-atomic-7.1] ________________________

osxml = &lt;Os shortid=rhel-atomic-7.1&gt;

    @util.os_parametrize('osxml', filter_resources=True)
    def test_resources(osxml):
        _test_resources_uniqueness_by_arch(osxml)
    
        # Ensure minimum resources are &lt;= recommended resources
        _resources_helper(osxml,
                          osxml.get_minimum_resources,
                          'minimum',
                          osxml.get_recommended_resources,
&gt;                         'recommended')

../tests/test_resources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=rhel-atomic-7.1&gt;
smaller_func = &lt;bound method Os.get_minimum_resources of &lt;Os shortid=rhel-atomic-7.1&gt;&gt;
smaller_str = 'minimum'
bigger_func = &lt;bound method Os.get_recommended_resources of &lt;Os shortid=rhel-atomic-7.1&gt;&gt;
bigger_str = 'recommended'

    def _resources_helper(osxml,
                          smaller_func, smaller_str,
                          bigger_func, bigger_str):
        broken = []
        for resource in osxml.resources_list:
            logging.info(&quot;resources | arch: %s&quot;, resource.get('arch'))
            smaller = smaller_func(resource)
            bigger = bigger_func(resource)
    
            if smaller is None or bigger is None:
                continue
    
            if not _resources_check(smaller, smaller_str, bigger, bigger_str):
                broken.append([smaller, bigger])
&gt;       assert broken == []
E       assert [[&lt;tests.osin...f1517a87320&gt;]] == []
E         Left contains more items, first extra item: [&lt;tests.osinfo.Resources object at 0x7f1517a87e10&gt;, &lt;tests.osinfo.Resources object at 0x7f1517a87320&gt;]
E         Use -v to get the full diff

../tests/test_resources.py:69: AssertionError
------------------------------ Captured log call -------------------------------
test_resources.py           60 INFO     resources | arch: all
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           98 WARNING  storage value of minimum should not be bigger than recommended ('10737418240' &gt; '9663676416')
_______________________ test_resources[rhel-atomic-7.2] ________________________

osxml = &lt;Os shortid=rhel-atomic-7.2&gt;

    @util.os_parametrize('osxml', filter_resources=True)
    def test_resources(osxml):
        _test_resources_uniqueness_by_arch(osxml)
    
        # Ensure minimum resources are &lt;= recommended resources
        _resources_helper(osxml,
                          osxml.get_minimum_resources,
                          'minimum',
                          osxml.get_recommended_resources,
&gt;                         'recommended')

../tests/test_resources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

osxml = &lt;Os shortid=rhel-atomic-7.2&gt;
smaller_func = &lt;bound method Os.get_minimum_resources of &lt;Os shortid=rhel-atomic-7.2&gt;&gt;
smaller_str = 'minimum'
bigger_func = &lt;bound method Os.get_recommended_resources of &lt;Os shortid=rhel-atomic-7.2&gt;&gt;
bigger_str = 'recommended'

    def _resources_helper(osxml,
                          smaller_func, smaller_str,
                          bigger_func, bigger_str):
        broken = []
        for resource in osxml.resources_list:
            logging.info(&quot;resources | arch: %s&quot;, resource.get('arch'))
            smaller = smaller_func(resource)
            bigger = bigger_func(resource)
    
            if smaller is None or bigger is None:
                continue
    
            if not _resources_check(smaller, smaller_str, bigger, bigger_str):
                broken.append([smaller, bigger])
&gt;       assert broken == []
E       assert [[&lt;tests.osin...f1517a91630&gt;]] == []
E         Left contains more items, first extra item: [&lt;tests.osinfo.Resources object at 0x7f1517a916d8&gt;, &lt;tests.osinfo.Resources object at 0x7f1517a91630&gt;]
E         Use -v to get the full diff

../tests/test_resources.py:69: AssertionError
------------------------------ Captured log call -------------------------------
test_resources.py           60 INFO     resources | arch: all
test_resources.py           78 WARNING  cpu value of minimum should not be bigger than recommended ('1000000000' &gt; '400000000')
test_resources.py           98 WARNING  storage value of minimum should not be bigger than recommended ('10737418240' &gt; '9663676416')
=============================== warnings summary ===============================
tests/test_isoinfo.py::test_iso_detection[alpinelinux3.5]
  /var/scratch/src/libosinfo/upstream/osinfo-db/tests/osinfo.py:187: FutureWarning: Possible nested set at position 15
    return re.compile(self._get_text('volume-id', default=''))
  /var/scratch/src/libosinfo/upstream/osinfo-db/tests/osinfo.py:187: FutureWarning: Possible nested set at position 14
    return re.compile(self._get_text('volume-id', default=''))

-- Docs: <a  rel="nofollow" href="https://docs.pytest.org/en/latest/warnings.html">https://docs.pytest.org/en/latest/warnings.html</a>
============== 130 failed, 790 passed, 2 warnings in 5.95 seconds ==============
make: *** [../Makefile:126: check] Error 1
make: Leaving directory '/var/scratch/src/libosinfo/upstream/osinfo-db/build'


Cheers,
 -- Guido

_______________________________________________
Libosinfo mailing list
Libosinfo@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/libosinfo">https://www.redhat.com/mailman/listinfo/libosinfo</a>




</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg05556.html">Re:  [osinfo-db PATCH v2 7/8] debian: Add new	&lt;short-id&gt;s for several releases</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg05558.html">Re:  [osinfo-db PATCH v2 7/8] debian: Add new &lt;short-id&gt;s for several releases</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg05515.html">[osinfo-db PATCH 1/1] Fix out-of-tree build</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg05561.html">Re:  [osinfo-db PATCH 1/1] Fix out-of-tree build</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#05557"><strong>Date</strong></a></li>
<li><a href="index.html#05557"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/virt-tools/>[Virt&nbsp;Tools]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/libvirt-users/>[Libvirt&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-users/>[Fedora&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-maintainers/>[Fedora&nbsp;Maintainers]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=http://www.ske-art.com/z/biglist.html>[Big&nbsp;List&nbsp;of&nbsp;Linux&nbsp;Books]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
