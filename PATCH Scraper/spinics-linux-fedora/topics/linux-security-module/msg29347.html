<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH bpf&#45;next v9 08/10] bpf: Add a Landlock sandbox example -->
<!--X-From-R13: =?GFT&#45;8?d?[vpxn=Q3=OPy=20Enyn=Q3=PQa?= &#60;zvpNqvtvxbq.arg> -->
<!--X-Date: Tue, 25 Jun 2019 14:55:05 &#45;0700 -->
<!--X-Message-Id: 20190625215239.11136&#45;9&#45;mic@digikod.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190625215239.11136&#45;1&#45;mic@digikod.net -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Security Module, [PATCH bpf-next v9 08/10] bpf: Add a Landlock sandbox example">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Security Module -- [PATCH bpf-next v9 08/10] bpf: Add a Landlock sandbox example</title>
<link rel="alternate" type="application/rss+xml" title="Linux Security Module" href="//feeds.feedburner.com/LinuxSecurityModule">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH bpf-next v9 08/10] bpf: Add a Landlock sandbox example</h1>
[<a href="msg29346.html">Date Prev</a>][<a href="msg29348.html">Date Next</a>][<a href="msg29346.html">Thread Prev</a>][<a href="msg29348.html">Thread Next</a>][<a href="maillist.html#29347">Date Index</a>][<a href="index.html#29347">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH bpf-next v9 08/10] bpf: Add a Landlock sandbox example</li>
<li><em>From</em>: Micka&#xEB;l Sala&#xFC;n &lt;mic@xxxxxxxxxxx&gt;</li>
<li><em>Date</em>: Tue, 25 Jun 2019 23:52:37 +0200</li>
<li><em>Cc</em>: Micka&#xEB;l Sala&#xFC;n &lt;mic@xxxxxxxxxxx&gt;,        Aleksa Sarai &lt;cyphar@xxxxxxxxxx&gt;,        Alexander Viro &lt;viro@xxxxxxxxxxxxxxxxxx&gt;,        Alexei Starovoitov &lt;ast@xxxxxxxxxx&gt;,        Andrew Morton &lt;akpm@xxxxxxxxxxxxxxxxxxxx&gt;,        Andy Lutomirski &lt;luto@xxxxxxxxxxxxxx&gt;,        Arnaldo Carvalho de Melo &lt;acme@xxxxxxxxxx&gt;,        Casey Schaufler &lt;casey@xxxxxxxxxxxxxxxx&gt;,        Daniel Borkmann &lt;daniel@xxxxxxxxxxxxx&gt;,        David Drysdale &lt;drysdale@xxxxxxxxxx&gt;,        &quot;David S . Miller&quot; &lt;davem@xxxxxxxxxxxxx&gt;,        &quot;Eric W . Biederman&quot; &lt;ebiederm@xxxxxxxxxxxx&gt;,        James Morris &lt;jmorris@xxxxxxxxx&gt;, Jann Horn &lt;jann@xxxxxxxxx&gt;,        John Johansen &lt;john.johansen@xxxxxxxxxxxxx&gt;,        Jonathan Corbet &lt;corbet@xxxxxxx&gt;, Kees Cook &lt;keescook@xxxxxxxxxxxx&gt;,        Michael Kerrisk &lt;mtk.manpages@xxxxxxxxx&gt;,        Micka&#xEB;l Sala&#xFC;n &lt;mickael.salaun@xxxxxxxxxxx&gt;,        Paul Moore &lt;paul@xxxxxxxxxxxxxx&gt;, Sargun Dhillon &lt;sargun@xxxxxxxxx&gt;,        &quot;Serge E . Hallyn&quot; &lt;serge@xxxxxxxxxx&gt;, Shuah Khan &lt;shuah@xxxxxxxxxx&gt;,        Stephen Smalley &lt;sds@xxxxxxxxxxxxx&gt;, Tejun Heo &lt;tj@xxxxxxxxxx&gt;,        Tetsuo Handa &lt;penguin-kernel@xxxxxxxxxxxxxxxxxxx&gt;,        Thomas Graf &lt;tgraf@xxxxxxx&gt;, Tycho Andersen &lt;tycho@xxxxxxxx&gt;,        Will Drewry &lt;wad@xxxxxxxxxxxx&gt;, kernel-hardening@xxxxxxxxxxxxxxxxxx,        linux-api@xxxxxxxxxxxxxxx, linux-fsdevel@xxxxxxxxxxxxxxx,        linux-security-module@xxxxxxxxxxxxxxx, netdev@xxxxxxxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg29352.html">20190625215239.11136-1-mic@digikod.net</a>&gt;</li>
<li><em>References</em>: &lt;<a href="msg29352.html">20190625215239.11136-1-mic@digikod.net</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Add a basic sandbox tool to launch a command which is denied access to a
list of files and directories.

Add to the bpf_load library the ability to handle a BPF program subtype.

Signed-off-by: Micka&#xEB;l Sala&#xFC;n &lt;mic@xxxxxxxxxxx&gt;
Cc: Alexei Starovoitov &lt;ast@xxxxxxxxxx&gt;
Cc: Andy Lutomirski &lt;luto@xxxxxxxxxxxxxx&gt;
Cc: Daniel Borkmann &lt;daniel@xxxxxxxxxxxxx&gt;
Cc: David S. Miller &lt;davem@xxxxxxxxxxxxx&gt;
Cc: James Morris &lt;jmorris@xxxxxxxxx&gt;
Cc: Kees Cook &lt;keescook@xxxxxxxxxxxx&gt;
Cc: Serge E. Hallyn &lt;serge@xxxxxxxxxx&gt;
---

Changes since v8:
* rewrite the landlock1 sample which deny access to a set of files or
  directories (i.e. simple blacklist) to fit with the previous patches
* add &quot;landlock1&quot; to .gitignore
* in bpf_load.c, pass the subtype with a call to
  bpf_load_program_xattr()

Changes since v7:
* rewrite the example using an inode map
* add to bpf_load the ability to handle subtypes per program type

Changes since v6:
* check return value of load_and_attach()
* allow to write on pipes
* rename BPF_PROG_TYPE_LANDLOCK to BPF_PROG_TYPE_LANDLOCK_RULE
* rename Landlock version to ABI to better reflect its purpose
* use const variable (suggested by Kees Cook)
* remove useless definitions (suggested by Kees Cook)
* add detailed explanations (suggested by Kees Cook)

Changes since v5:
* cosmetic fixes
* rebase

Changes since v4:
* write Landlock rule in C and compiled it with LLVM
* remove cgroup handling
* remove path handling: only handle a read-only environment
* remove errno return codes

Changes since v3:
* remove seccomp and origin field: completely free from seccomp programs
* handle more FS-related hooks
* handle inode hooks and directory traversal
* add faked but consistent view thanks to ENOENT
* add /lib64 in the example
* fix spelling
* rename some types and definitions (e.g. SECCOMP_ADD_LANDLOCK_RULE)

Changes since v2:
* use BPF_PROG_ATTACH for cgroup handling
---
 samples/bpf/.gitignore       |   1 +
 samples/bpf/Makefile         |   3 +
 samples/bpf/bpf_load.c       |  76 ++++++++++++++++-
 samples/bpf/bpf_load.h       |   7 ++
 samples/bpf/landlock1.h      |   8 ++
 samples/bpf/landlock1_kern.c | 104 +++++++++++++++++++++++
 samples/bpf/landlock1_user.c | 157 +++++++++++++++++++++++++++++++++++
 7 files changed, 352 insertions(+), 4 deletions(-)
 create mode 100644 samples/bpf/landlock1.h
 create mode 100644 samples/bpf/landlock1_kern.c
 create mode 100644 samples/bpf/landlock1_user.c

diff --git a/samples/bpf/.gitignore b/samples/bpf/.gitignore
index 74d31fd3c99c..a4c9c806f739 100644
--- a/samples/bpf/.gitignore
+++ b/samples/bpf/.gitignore
@@ -2,6 +2,7 @@ cpustat
 fds_example
 hbm
 ibumad
+landlock1
 lathist
 lwt_len_hist
 map_perf_test
diff --git a/samples/bpf/Makefile b/samples/bpf/Makefile
index 0917f8cf4fab..da246eaa8bf8 100644
--- a/samples/bpf/Makefile
+++ b/samples/bpf/Makefile
@@ -53,6 +53,7 @@ hostprogs-y += task_fd_query
 hostprogs-y += xdp_sample_pkts
 hostprogs-y += ibumad
 hostprogs-y += hbm
+hostprogs-y += landlock1
 
 # Libbpf dependencies
 LIBBPF = $(TOOLS_PATH)/lib/bpf/libbpf.a
@@ -109,6 +110,7 @@ task_fd_query-objs := bpf_load.o task_fd_query_user.o $(TRACE_HELPERS)
 xdp_sample_pkts-objs := xdp_sample_pkts_user.o $(TRACE_HELPERS)
 ibumad-objs := bpf_load.o ibumad_user.o $(TRACE_HELPERS)
 hbm-objs := bpf_load.o hbm.o $(CGROUP_HELPERS)
+landlock1-objs := bpf_load.o landlock1_user.o
 
 # Tell kbuild to always build the programs
 always := $(hostprogs-y)
@@ -168,6 +170,7 @@ always += task_fd_query_kern.o
 always += xdp_sample_pkts_kern.o
 always += ibumad_kern.o
 always += hbm_out_kern.o
+always += landlock1_kern.o
 
 KBUILD_HOSTCFLAGS += -I$(objtree)/usr/include
 KBUILD_HOSTCFLAGS += -I$(srctree)/tools/lib/bpf/
diff --git a/samples/bpf/bpf_load.c b/samples/bpf/bpf_load.c
index 4574b1939e49..bf62d965f606 100644
--- a/samples/bpf/bpf_load.c
+++ b/samples/bpf/bpf_load.c
@@ -12,6 +12,7 @@
 #include &lt;stdlib.h&gt;
 #include &lt;linux/bpf.h&gt;
 #include &lt;linux/filter.h&gt;
+#include &lt;linux/landlock.h&gt;
 #include &lt;linux/perf_event.h&gt;
 #include &lt;linux/netlink.h&gt;
 #include &lt;linux/rtnetlink.h&gt;
@@ -42,6 +43,9 @@ int prog_array_fd = -1;
 struct bpf_map_data map_data[MAX_MAPS];
 int map_data_count;
 
+struct bpf_subtype_data subtype_data[MAX_PROGS];
+int subtype_data_count;
+
 static int populate_prog_array(const char *event, int prog_fd)
 {
 	int ind = atoi(event), err;
@@ -87,11 +91,15 @@ static int load_and_attach(const char *event, struct bpf_insn *prog, int size)
 	bool is_sockops = strncmp(event, &quot;sockops&quot;, 7) == 0;
 	bool is_sk_skb = strncmp(event, &quot;sk_skb&quot;, 6) == 0;
 	bool is_sk_msg = strncmp(event, &quot;sk_msg&quot;, 6) == 0;
+	bool is_landlock = strncmp(event, &quot;landlock&quot;, 8) == 0;
 	size_t insns_cnt = size / sizeof(struct bpf_insn);
 	enum bpf_prog_type prog_type;
 	char buf[256];
 	int fd, efd, err, id;
 	struct perf_event_attr attr = {};
+	union bpf_prog_subtype *st = NULL;
+	struct bpf_subtype_data *sd = NULL;
+	struct bpf_load_program_attr load_attr;
 
 	attr.type = PERF_TYPE_TRACEPOINT;
 	attr.sample_type = PERF_SAMPLE_RAW;
@@ -120,6 +128,32 @@ static int load_and_attach(const char *event, struct bpf_insn *prog, int size)
 		prog_type = BPF_PROG_TYPE_SK_SKB;
 	} else if (is_sk_msg) {
 		prog_type = BPF_PROG_TYPE_SK_MSG;
+	} else if (is_landlock) {
+		int i, prog_id;
+		const char *event_id = (event + 8);
+
+		if (!isdigit(*event_id)) {
+			printf(&quot;invalid prog number\n&quot;);
+			return -1;
+		}
+		prog_id = atoi(event_id);
+		for (i = 0; i &lt; subtype_data_count; i++) {
+			if (subtype_data[i].name &amp;&amp; strcmp(event,
+						subtype_data[i].name) == 0) {
+				/* save the prog_id for a next program */
+				sd = &amp;subtype_data[i];
+				sd-&gt;prog_id = prog_id;
+				st = &amp;sd-&gt;subtype;
+				free(sd-&gt;name);
+				sd-&gt;name = NULL;
+				break;
+			}
+		}
+		if (!st) {
+			printf(&quot;missing subtype\n&quot;);
+			return -1;
+		}
+		prog_type = BPF_PROG_TYPE_LANDLOCK_HOOK;
 	} else {
 		printf(&quot;Unknown event '%s'\n&quot;, event);
 		return -1;
@@ -128,16 +162,25 @@ static int load_and_attach(const char *event, struct bpf_insn *prog, int size)
 	if (prog_cnt == MAX_PROGS)
 		return -1;
 
-	fd = bpf_load_program(prog_type, prog, insns_cnt, license, kern_version,
-			      bpf_log_buf, BPF_LOG_BUF_SIZE);
+	memset(&amp;load_attr, 0, sizeof(struct bpf_load_program_attr));
+	load_attr.prog_type = prog_type;
+	load_attr.prog_subtype = st;
+	load_attr.insns = prog;
+	load_attr.insns_cnt = insns_cnt;
+	load_attr.license = license;
+	load_attr.kern_version = kern_version;
+	fd = bpf_load_program_xattr(&amp;load_attr, bpf_log_buf, BPF_LOG_BUF_SIZE);
 	if (fd &lt; 0) {
 		printf(&quot;bpf_load_program() err=%d\n%s&quot;, errno, bpf_log_buf);
 		return -1;
 	}
+	if (sd)
+		sd-&gt;prog_fd = fd;
 
 	prog_fd[prog_cnt++] = fd;
 
-	if (is_xdp || is_perf_event || is_cgroup_skb || is_cgroup_sk)
+	if (is_xdp || is_perf_event || is_cgroup_skb || is_cgroup_sk ||
+	    is_landlock)
 		return 0;
 
 	if (is_socket || is_sockops || is_sk_skb || is_sk_msg) {
@@ -519,6 +562,7 @@ static int do_load_bpf_file(const char *path, fixup_map_cb fixup_map)
 	kern_version = 0;
 	memset(license, 0, sizeof(license));
 	memset(processed_sec, 0, sizeof(processed_sec));
+	subtype_data_count = 0;
 
 	if (elf_version(EV_CURRENT) == EV_NONE)
 		return 1;
@@ -567,6 +611,29 @@ static int do_load_bpf_file(const char *path, fixup_map_cb fixup_map)
 			data_maps = data;
 			for (j = 0; j &lt; MAX_MAPS; j++)
 				map_data[j].fd = -1;
+		} else if (strncmp(shname, &quot;subtype&quot;, 7) == 0) {
+			processed_sec[i] = true;
+			if (*(shname + 7) != '/') {
+				printf(&quot;invalid name of subtype section&quot;);
+				return 1;
+			}
+			if (data-&gt;d_size != sizeof(union bpf_prog_subtype)) {
+				printf(&quot;invalid size of subtype section: %zd\n&quot;,
+				       data-&gt;d_size);
+				printf(&quot;ref: %zd\n&quot;,
+				       sizeof(union bpf_prog_subtype));
+				return 1;
+			}
+			if (subtype_data_count &gt;= MAX_PROGS) {
+				printf(&quot;too many subtype sections&quot;);
+				return 1;
+			}
+			memcpy(&amp;subtype_data[subtype_data_count].subtype,
+					data-&gt;d_buf,
+					sizeof(union bpf_prog_subtype));
+			subtype_data[subtype_data_count].name =
+				strdup((shname + 8));
+			subtype_data_count++;
 		} else if (shdr.sh_type == SHT_SYMTAB) {
 			strtabidx = shdr.sh_link;
 			symbols = data;
@@ -643,7 +710,8 @@ static int do_load_bpf_file(const char *path, fixup_map_cb fixup_map)
 		    memcmp(shname, &quot;cgroup/&quot;, 7) == 0 ||
 		    memcmp(shname, &quot;sockops&quot;, 7) == 0 ||
 		    memcmp(shname, &quot;sk_skb&quot;, 6) == 0 ||
-		    memcmp(shname, &quot;sk_msg&quot;, 6) == 0) {
+		    memcmp(shname, &quot;sk_msg&quot;, 6) == 0 ||
+		    memcmp(shname, &quot;landlock&quot;, 8) == 0) {
 			ret = load_and_attach(shname, data-&gt;d_buf,
 					      data-&gt;d_size);
 			if (ret != 0)
diff --git a/samples/bpf/bpf_load.h b/samples/bpf/bpf_load.h
index 814894a12974..e210b5fdf8ee 100644
--- a/samples/bpf/bpf_load.h
+++ b/samples/bpf/bpf_load.h
@@ -24,6 +24,13 @@ struct bpf_map_data {
 	struct bpf_load_map_def def;
 };
 
+struct bpf_subtype_data {
+	char *name;
+	int prog_id;
+	int prog_fd;
+	union bpf_prog_subtype subtype;
+};
+
 typedef void (*fixup_map_cb)(struct bpf_map_data *map, int idx);
 
 extern int prog_fd[MAX_PROGS];
diff --git a/samples/bpf/landlock1.h b/samples/bpf/landlock1.h
new file mode 100644
index 000000000000..53b0a9447855
--- /dev/null
+++ b/samples/bpf/landlock1.h
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Landlock sample 1 - common header
+ *
+ * Copyright &#xA9; 2018-2019 Micka&#xEB;l Sala&#xFC;n &lt;mic@xxxxxxxxxxx&gt;
+ */
+
+#define MAP_FLAG_DENY		(1ULL &lt;&lt; 0)
diff --git a/samples/bpf/landlock1_kern.c b/samples/bpf/landlock1_kern.c
new file mode 100644
index 000000000000..0298d98dd06a
--- /dev/null
+++ b/samples/bpf/landlock1_kern.c
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Landlock sample 1 - whitelist of read only or read-write file hierarchy
+ *
+ * Copyright &#xA9; 2017-2019 Micka&#xEB;l Sala&#xFC;n &lt;mic@xxxxxxxxxxx&gt;
+ */
+
+/*
+ * This file contains a function that will be compiled to eBPF bytecode thanks
+ * to LLVM/Clang.
+ *
+ * Each SEC() means that the following function or variable will be part of a
+ * custom ELF section. This sections are then processed by the userspace part
+ * (see landlock1_user.c) to extract eBPF bytecode and take into account
+ * variables describing the eBPF program subtype or its license.
+ */
+
+#include &lt;uapi/linux/bpf.h&gt;
+#include &lt;uapi/linux/landlock.h&gt;
+
+#include &quot;bpf_helpers.h&quot;
+#include &quot;landlock1.h&quot; /* MAP_FLAG_DENY */
+
+#define MAP_MAX_ENTRIES		20
+
+SEC(&quot;maps&quot;)
+struct bpf_map_def inode_map = {
+	.type = BPF_MAP_TYPE_INODE,
+	.key_size = sizeof(u32),
+	.value_size = sizeof(u64),
+	.max_entries = MAP_MAX_ENTRIES,
+};
+
+static __always_inline __u64 get_access(void *inode)
+{
+	if (bpf_inode_map_lookup(&amp;inode_map, inode) &amp; MAP_FLAG_DENY)
+		return LANDLOCK_RET_DENY;
+	return LANDLOCK_RET_ALLOW;
+}
+
+SEC(&quot;subtype/landlock1&quot;)
+static union bpf_prog_subtype _subtype1 = {
+	.landlock_hook = {
+		.type = LANDLOCK_HOOK_FS_WALK,
+	}
+};
+
+/*
+ * The function fs_walk() is a simple Landlock program enforced on a set of
+ * processes. This program will be run for each walk through a file path.
+ *
+ * The argument ctx contains the context of the program when it is run, which
+ * enable to evaluate the file path.  This context can change for each run of
+ * the program.
+ */
+SEC(&quot;landlock1&quot;)
+int fs_walk(struct landlock_ctx_fs_walk *ctx)
+{
+	return get_access((void *)ctx-&gt;inode);
+}
+
+SEC(&quot;subtype/landlock2&quot;)
+static union bpf_prog_subtype _subtype2 = {
+	.landlock_hook = {
+		.type = LANDLOCK_HOOK_FS_PICK,
+		/*
+		 * allowed:
+		 * - LANDLOCK_TRIGGER_FS_PICK_LINK
+		 * - LANDLOCK_TRIGGER_FS_PICK_LINKTO
+		 * - LANDLOCK_TRIGGER_FS_PICK_RECEIVE
+		 * - LANDLOCK_TRIGGER_FS_PICK_MOUNTON
+		 */
+		.triggers =
+			    LANDLOCK_TRIGGER_FS_PICK_APPEND |
+			    LANDLOCK_TRIGGER_FS_PICK_CHDIR |
+			    LANDLOCK_TRIGGER_FS_PICK_CHROOT |
+			    LANDLOCK_TRIGGER_FS_PICK_CREATE |
+			    LANDLOCK_TRIGGER_FS_PICK_EXECUTE |
+			    LANDLOCK_TRIGGER_FS_PICK_FCNTL |
+			    LANDLOCK_TRIGGER_FS_PICK_GETATTR |
+			    LANDLOCK_TRIGGER_FS_PICK_IOCTL |
+			    LANDLOCK_TRIGGER_FS_PICK_LOCK |
+			    LANDLOCK_TRIGGER_FS_PICK_MAP |
+			    LANDLOCK_TRIGGER_FS_PICK_OPEN |
+			    LANDLOCK_TRIGGER_FS_PICK_READ |
+			    LANDLOCK_TRIGGER_FS_PICK_READDIR |
+			    LANDLOCK_TRIGGER_FS_PICK_RENAME |
+			    LANDLOCK_TRIGGER_FS_PICK_RENAMETO |
+			    LANDLOCK_TRIGGER_FS_PICK_RMDIR |
+			    LANDLOCK_TRIGGER_FS_PICK_SETATTR |
+			    LANDLOCK_TRIGGER_FS_PICK_TRANSFER |
+			    LANDLOCK_TRIGGER_FS_PICK_UNLINK |
+			    LANDLOCK_TRIGGER_FS_PICK_WRITE,
+	}
+};
+
+SEC(&quot;landlock2&quot;)
+int fs_pick_ro(struct landlock_ctx_fs_pick *ctx)
+{
+	return get_access((void *)ctx-&gt;inode);
+}
+
+SEC(&quot;license&quot;)
+static const char _license[] = &quot;GPL&quot;;
diff --git a/samples/bpf/landlock1_user.c b/samples/bpf/landlock1_user.c
new file mode 100644
index 000000000000..aa45932d36a8
--- /dev/null
+++ b/samples/bpf/landlock1_user.c
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Landlock sample 1 - deny access to a set of directories (blacklisting)
+ *
+ * Copyright &#xA9; 2017-2019 Micka&#xEB;l Sala&#xFC;n &lt;mic@xxxxxxxxxxx&gt;
+ */
+
+#include &quot;bpf/libbpf.h&quot;
+#include &quot;bpf_load.h&quot;
+#include &quot;landlock1.h&quot; /* MAP_FLAG_DENY */
+
+#define _GNU_SOURCE
+#include &lt;errno.h&gt;
+#include &lt;fcntl.h&gt; /* open() */
+#include &lt;linux/bpf.h&gt;
+#include &lt;linux/filter.h&gt;
+#include &lt;linux/landlock.h&gt;
+#include &lt;linux/prctl.h&gt;
+#include &lt;linux/seccomp.h&gt;
+#include &lt;stddef.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sys/prctl.h&gt;
+#include &lt;sys/syscall.h&gt;
+#include &lt;unistd.h&gt;
+
+#ifndef seccomp
+static int seccomp(unsigned int op, unsigned int flags, void *args)
+{
+	errno = 0;
+	return syscall(__NR_seccomp, op, flags, args);
+}
+#endif
+
+static int apply_sandbox(int prog_fd)
+{
+	int ret = 0;
+
+	/* set up the test sandbox */
+	if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
+		perror(&quot;prctl(no_new_priv)&quot;);
+		return 1;
+	}
+	if (seccomp(SECCOMP_PREPEND_LANDLOCK_PROG, 0, &amp;prog_fd)) {
+		perror(&quot;seccomp(set_hook)&quot;);
+		ret = 1;
+	}
+	close(prog_fd);
+
+	return ret;
+}
+
+#define ENV_FS_PATH_DENY_NAME &quot;LL_PATH_DENY&quot;
+#define ENV_PATH_TOKEN &quot;:&quot;
+
+static int parse_path(char *env_path, const char ***path_list)
+{
+	int i, path_nb = 0;
+
+	if (env_path) {
+		path_nb++;
+		for (i = 0; env_path[i]; i++) {
+			if (env_path[i] == ENV_PATH_TOKEN[0])
+				path_nb++;
+		}
+	}
+	*path_list = malloc(path_nb * sizeof(**path_list));
+	for (i = 0; i &lt; path_nb; i++)
+		(*path_list)[i] = strsep(&amp;env_path, ENV_PATH_TOKEN);
+
+	return path_nb;
+}
+
+static int populate_map(const char *env_var, unsigned long long value,
+		int map_fd)
+{
+	int path_nb, ref_fd, i;
+	char *env_path_name;
+	const char **path_list = NULL;
+
+	env_path_name = getenv(env_var);
+	if (!env_path_name)
+		return 0;
+	env_path_name = strdup(env_path_name);
+	path_nb = parse_path(env_path_name, &amp;path_list);
+
+	for (i = 0; i &lt; path_nb; i++) {
+		ref_fd = open(path_list[i], O_RDONLY | O_CLOEXEC);
+		if (ref_fd &lt; 0) {
+			fprintf(stderr, &quot;Failed to open \&quot;%s\&quot;: %s\n&quot;,
+					path_list[i],
+					strerror(errno));
+			return 1;
+		}
+		if (bpf_map_update_elem(map_fd, &amp;ref_fd, &amp;value, BPF_ANY)) {
+			fprintf(stderr, &quot;Failed to update the map with&quot;
+					&quot; \&quot;%s\&quot;: %s\n&quot;, path_list[i],
+					strerror(errno));
+			return 1;
+		}
+		close(ref_fd);
+	}
+	free(env_path_name);
+	return 0;
+}
+
+int main(int argc, char * const argv[], char * const *envp)
+{
+	char filename[256];
+	char *cmd_path;
+	char * const *cmd_argv;
+	int ll_prog_walk, ll_prog_pick;
+
+	if (argc &lt; 2) {
+		fprintf(stderr, &quot;usage: %s &lt;cmd&gt; [args]...\n\n&quot;, argv[0]);
+		fprintf(stderr, &quot;Launch a command in a restricted environment.\n\n&quot;);
+		fprintf(stderr, &quot;Environment variables containing paths, each separated by a colon:\n&quot;);
+		fprintf(stderr, &quot;* %s: list of files and directories which are denied\n&quot;,
+				ENV_FS_PATH_DENY_NAME);
+		fprintf(stderr, &quot;\nexample:\n&quot;
+				&quot;%s=\&quot;${HOME}/.ssh:${HOME}/Images\&quot; &quot;
+				&quot;%s /bin/sh -i\n&quot;,
+				ENV_FS_PATH_DENY_NAME, argv[0]);
+		return 1;
+	}
+
+	snprintf(filename, sizeof(filename), &quot;%s_kern.o&quot;, argv[0]);
+	if (load_bpf_file(filename)) {
+		printf(&quot;%s&quot;, bpf_log_buf);
+		return 1;
+	}
+	ll_prog_walk = prog_fd[0]; /* fs_walk */
+	ll_prog_pick = prog_fd[1]; /* fs_pick */
+	if (!ll_prog_walk || !ll_prog_pick) {
+		if (errno)
+			printf(&quot;load_bpf_file: %s\n&quot;, strerror(errno));
+		else
+			printf(&quot;load_bpf_file: Error\n&quot;);
+		return 1;
+	}
+
+	if (populate_map(ENV_FS_PATH_DENY_NAME, MAP_FLAG_DENY, map_fd[0]))
+		return 1;
+	close(map_fd[0]);
+
+	fprintf(stderr, &quot;Launching a new sandboxed process\n&quot;);
+	if (apply_sandbox(ll_prog_walk))
+		return 1;
+	if (apply_sandbox(ll_prog_pick))
+		return 1;
+	cmd_path = argv[1];
+	cmd_argv = argv + 1;
+	execve(cmd_path, cmd_argv, envp);
+	perror(&quot;Failed to call execve&quot;);
+	return 1;
+}
-- 
2.20.1



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="29352" href="msg29352.html">[PATCH bpf-next v9 00/10] Landlock LSM: Toward unprivileged sandboxing</a></strong>
<ul><li><em>From:</em> Micka&#xEB;l Sala&#xFC;n</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg29346.html">[PATCH bpf-next v9 03/10] bpf,landlock: Define an eBPF program type for Landlock hooks</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg29348.html">[PATCH bpf-next v9 10/10] landlock: Add user and kernel documentation for Landlock</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg29346.html">[PATCH bpf-next v9 03/10] bpf,landlock: Define an eBPF program type for Landlock hooks</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg29348.html">[PATCH bpf-next v9 10/10] landlock: Add user and kernel documentation for Landlock</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#29347"><strong>Date</strong></a></li>
<li><a href="index.html#29347"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-users/>[Fedora&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
