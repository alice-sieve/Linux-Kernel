<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH v4 15/23] LSM: Specify which LSM to display -->
<!--X-From-R13: Qnfrl Epunhsyre &#60;pnfrlNfpunhsyre&#45;pn.pbz> -->
<!--X-Date: Fri, 28 Jun 2019 09:15:48 &#45;0700 -->
<!--X-Message-Id: 7944672e&#45;a590&#45;44a3&#45;743a&#45;48c1785a5464@schaufler&#45;ca.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190626192234.11725&#45;1&#45;casey@schaufler&#45;ca.com -->
<!--X-Reference: 20190626192234.11725&#45;16&#45;casey@schaufler&#45;ca.com -->
<!--X-Reference: 89561452&#45;86f9&#45;fd9a&#45;1390&#45;0cd4bde1fd62@tycho.nsa.gov -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Security Module, Re: [PATCH v4 15/23] LSM: Specify which LSM to display">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Security Module -- Re: [PATCH v4 15/23] LSM: Specify which LSM to display</title>
<link rel="alternate" type="application/rss+xml" title="Linux Security Module" href="//feeds.feedburner.com/LinuxSecurityModule">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH v4 15/23] LSM: Specify which LSM to display</h1>
[<a href="msg29564.html">Date Prev</a>][<a href="msg29566.html">Date Next</a>][<a href="msg29546.html">Thread Prev</a>][<a href="msg29571.html">Thread Next</a>][<a href="maillist.html#29565">Date Index</a>][<a href="index.html#29565">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH v4 15/23] LSM: Specify which LSM to display</li>
<li><em>From</em>: Casey Schaufler &lt;casey@xxxxxxxxxxxxxxxx&gt;</li>
<li><em>Date</em>: Fri, 28 Jun 2019 09:15:00 -0700</li>
<li><em>Cc</em>: keescook@xxxxxxxxxxxx, john.johansen@xxxxxxxxxxxxx,        penguin-kernel@xxxxxxxxxxxxxxxxxxx, paul@xxxxxxxxxxxxxx,        casey@xxxxxxxxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg29546.html">89561452-86f9-fd9a-1390-0cd4bde1fd62@tycho.nsa.gov</a>&gt;</li>
<li><em>Openpgp</em>: preference=signencrypt</li>
<li><em>References</em>: &lt;<a href="msg29370.html">20190626192234.11725-1-casey@schaufler-ca.com</a>&gt; &lt;<a href="msg29385.html">20190626192234.11725-16-casey@schaufler-ca.com</a>&gt; &lt;<a href="msg29546.html">89561452-86f9-fd9a-1390-0cd4bde1fd62@tycho.nsa.gov</a>&gt;</li>
<li><em>User-agent</em>: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:60.0) Gecko/20100101 Thunderbird/60.7.2</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On 6/28/2019 7:45 AM, Stephen Smalley wrote:
&gt; On 6/26/19 3:22 PM, Casey Schaufler wrote:
&gt;&gt; Create a new entry &quot;display&quot; in /proc/.../attr for controlling
&gt;&gt; which LSM security information is displayed for a process.
&gt;&gt; The name of an active LSM that supplies hooks for human readable
&gt;&gt; data may be written to &quot;display&quot; to set the value. The name of
&gt;&gt; the LSM currently in use can be read from &quot;display&quot;.
&gt;&gt; At this point there can only be one LSM capable of display
&gt;&gt; active.
&gt;
&gt; IIUC, presently, at the end of the entire series,
&gt;
&gt; 1) Any process can change its display attribute to any enabled security module, and no security module can veto that change.

That is correct. If a security module could hoard the display it
could prevent user space from functioning in a multiple module
environment.

&gt; 2) The display attribute is inherited across fork and exec, even execs that change credentials, and again no security module has control over the inheritance of this attribute.

Also correct. Scripts don't work otherwise.

&gt;
&gt; 3) Setting the display attribute affects more than just the contexts read or written by the process itself:
&gt; - Contexts reported in audit logs,
&gt; - Contexts passed across binder (generated in sender context, delivered to receiver),
&gt; - Contexts passed to NFS servers for new files,
&gt; - Contexts returned by NFS servers for existing files,
&gt; - Netlink-related contexts (?possibly generated in sender context rather than receiver context?),
&gt; - This list may not be complete.

Any of which can be changed should a more rational behavior be proposed.
One possibility is to use lsm='value',lsm='value' encoding for internal
communications, but there's been considerable resistance to anything
like that.

&gt; 4) A security_secid_to_secctx() in one process' context (e.g. sender) or with one display value followed later by a security_secctx_to_secid() call in a different process' context (e.g. receiver) or with a different display value may ask a different security module to perform the reverse translation of the context than the forward translation.

Do you have an example of where this might happen?
Contexts are rarely used within the kernel. The usual
behavior is to generate them, send them out to user space,
and delete them. They get cached in some networking code,
but not in cases where more than one (existing) security
module will ever use them. Binder may be an exception, but
only SELinux (currently) supports binder.


&gt; Is that correct?&#xA0; If so, it seems problematic.

Balancing backward compatibility with new behavior is hard!
What would you suggest for audit logs? Should we put all LSM
data in every record? Is NFS a concern for anyone not using
SELinux?

There is no user space that uses display, and it's going
to take some time to work out all the kinks before we even
think about teaching systemd about it.

&gt; &#xA0;&#xA0;&#xA0;&#xA0;
&gt;&gt;
&gt;&gt; Signed-off-by: Casey Schaufler &lt;casey@xxxxxxxxxxxxxxxx&gt;
&gt;&gt; ---
&gt;&gt; &#xA0; fs/proc/base.c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; |&#xA0;&#xA0; 1 +
&gt;&gt; &#xA0; security/security.c | 129 ++++++++++++++++++++++++++++++++++++++------
&gt;&gt; &#xA0; 2 files changed, 113 insertions(+), 17 deletions(-)
&gt;&gt;
&gt;&gt; diff --git a/fs/proc/base.c b/fs/proc/base.c
&gt;&gt; index ddef482f1334..7bf70e041315 100644
&gt;&gt; --- a/fs/proc/base.c
&gt;&gt; +++ b/fs/proc/base.c
&gt;&gt; @@ -2618,6 +2618,7 @@ static const struct pid_entry attr_dir_stuff[] = {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ATTR(NULL, &quot;fscreate&quot;,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 0666),
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ATTR(NULL, &quot;keycreate&quot;,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 0666),
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ATTR(NULL, &quot;sockcreate&quot;,&#xA0;&#xA0;&#xA0; 0666),
&gt;&gt; +&#xA0;&#xA0;&#xA0; ATTR(NULL, &quot;display&quot;,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 0666),
&gt;&gt; &#xA0; #ifdef CONFIG_SECURITY_SMACK
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; DIR(&quot;smack&quot;,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 0555,
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; proc_smack_attr_dir_inode_ops, proc_smack_attr_dir_ops),
&gt;&gt; diff --git a/security/security.c b/security/security.c
&gt;&gt; index 3180a6f30625..82e29c477fa4 100644
&gt;&gt; --- a/security/security.c
&gt;&gt; +++ b/security/security.c
&gt;&gt; @@ -46,7 +46,9 @@ static struct kmem_cache *lsm_file_cache;
&gt;&gt; &#xA0; static struct kmem_cache *lsm_inode_cache;
&gt;&gt; &#xA0; &#xA0; char *lsm_names;
&gt;&gt; -static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;
&gt;&gt; +static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init = {
&gt;&gt; +&#xA0;&#xA0;&#xA0; .lbs_task = sizeof(int),&#xA0;&#xA0;&#xA0; /* slot number for the &quot;display&quot; LSM */
&gt;&gt; +};
&gt;&gt; &#xA0; &#xA0; /* Boot-time LSM user choice */
&gt;&gt; &#xA0; static __initdata const char *chosen_lsm_order;
&gt;&gt; @@ -423,8 +425,10 @@ static int lsm_append(const char *new, char **result)
&gt;&gt; &#xA0; &#xA0; /*
&gt;&gt; &#xA0;&#xA0; * Current index to use while initializing the lsmblob secid list.
&gt;&gt; + * Pointers to the LSM id structures for local use.
&gt;&gt; &#xA0;&#xA0; */
&gt;&gt; &#xA0; static int lsm_slot;
&gt;&gt; +static struct lsm_id *lsm_slotlist[LSMBLOB_ENTRIES];
&gt;&gt; &#xA0; &#xA0; /**
&gt;&gt; &#xA0;&#xA0; * security_add_hooks - Add a modules hooks to the hook lists.
&gt;&gt; @@ -444,6 +448,7 @@ void __init security_add_hooks(struct security_hook_list *hooks, int count,
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (lsmid-&gt;slot == LSMBLOB_NEEDED) {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (lsm_slot &gt;= LSMBLOB_ENTRIES)
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; panic(&quot;%s Too many LSMs registered.\n&quot;, __func__);
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; lsm_slotlist[lsm_slot] = lsmid;
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; lsmid-&gt;slot = lsm_slot++;
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; init_debug(&quot;%s assigned lsmblob slot %d\n&quot;, lsmid-&gt;lsm,
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; lsmid-&gt;slot);
&gt;&gt; @@ -564,6 +569,8 @@ int lsm_inode_alloc(struct inode *inode)
&gt;&gt; &#xA0;&#xA0; */
&gt;&gt; &#xA0; static int lsm_task_alloc(struct task_struct *task)
&gt;&gt; &#xA0; {
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *display;
&gt;&gt; +
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (blob_sizes.lbs_task == 0) {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; task-&gt;security = NULL;
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return 0;
&gt;&gt; @@ -572,6 +579,15 @@ static int lsm_task_alloc(struct task_struct *task)
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; task-&gt;security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (task-&gt;security == NULL)
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return -ENOMEM;
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0; /*
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0; * The start of the task blob contains the &quot;display&quot; LSM slot number.
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0; * Start with it set to the invalid slot number, indicating that the
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0; * default first registered LSM be displayed.
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0; */
&gt;&gt; +&#xA0;&#xA0;&#xA0; display = task-&gt;security;
&gt;&gt; +&#xA0;&#xA0;&#xA0; *display = LSMBLOB_INVALID;
&gt;&gt; +
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return 0;
&gt;&gt; &#xA0; }
&gt;&gt; &#xA0; @@ -1563,14 +1579,24 @@ int security_file_open(struct file *file)
&gt;&gt; &#xA0; &#xA0; int security_task_alloc(struct task_struct *task, unsigned long clone_flags)
&gt;&gt; &#xA0; {
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *odisplay = current-&gt;security;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *ndisplay;
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int rc = lsm_task_alloc(task);
&gt;&gt; &#xA0; -&#xA0;&#xA0;&#xA0; if (rc)
&gt;&gt; +&#xA0;&#xA0;&#xA0; if (unlikely(rc))
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return rc;
&gt;&gt; +
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; rc = call_int_hook(task_alloc, 0, task, clone_flags);
&gt;&gt; -&#xA0;&#xA0;&#xA0; if (unlikely(rc))
&gt;&gt; +&#xA0;&#xA0;&#xA0; if (unlikely(rc)) {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; security_task_free(task);
&gt;&gt; -&#xA0;&#xA0;&#xA0; return rc;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return rc;
&gt;&gt; +&#xA0;&#xA0;&#xA0; }
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0; ndisplay = task-&gt;security;
&gt;&gt; +&#xA0;&#xA0;&#xA0; if (ndisplay &amp;&amp; odisplay)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; *ndisplay = *odisplay;
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0; return 0;
&gt;&gt; &#xA0; }
&gt;&gt; &#xA0; &#xA0; void security_task_free(struct task_struct *task)
&gt;&gt; @@ -1967,10 +1993,29 @@ int security_getprocattr(struct task_struct *p, const char *lsm, char *name,
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; char **value)
&gt;&gt; &#xA0; {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct security_hook_list *hp;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *display = current-&gt;security;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int slot = 0;
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0; if (!strcmp(name, &quot;display&quot;)) {
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /*
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; * lsm_slot will be 0 if there are no displaying modules.
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; */
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (lsm_slot == 0)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return -EINVAL;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (*display != LSMBLOB_INVALID)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; slot = *display;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; *value = kstrdup(lsm_slotlist[slot]-&gt;lsm, GFP_KERNEL);
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (*value)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return strlen(*value);
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return -ENOMEM;
&gt;&gt; +&#xA0;&#xA0;&#xA0; }
&gt;&gt; &#xA0; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; hlist_for_each_entry(hp, &amp;security_hook_heads.getprocattr, list) {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (lsm != NULL &amp;&amp; strcmp(lsm, hp-&gt;lsmid-&gt;lsm))
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; continue;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (lsm == NULL &amp;&amp; *display != LSMBLOB_INVALID &amp;&amp;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; *display != hp-&gt;lsmid-&gt;slot)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; continue;
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return hp-&gt;hook.getprocattr(p, name, value);
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return -EINVAL;
&gt;&gt; @@ -1980,10 +2025,46 @@ int security_setprocattr(const char *lsm, const char *name, void *value,
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; size_t size)
&gt;&gt; &#xA0; {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct security_hook_list *hp;
&gt;&gt; +&#xA0;&#xA0;&#xA0; char *term;
&gt;&gt; +&#xA0;&#xA0;&#xA0; char *cp;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *display = current-&gt;security;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int rc = -EINVAL;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int slot = 0;
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0; if (!strcmp(name, &quot;display&quot;)) {
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /*
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; * lsm_slot will be 0 if there are no displaying modules.
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; */
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (lsm_slot == 0 || size == 0)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return -EINVAL;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; cp = kzalloc(size + 1, GFP_KERNEL);
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (cp == NULL)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return -ENOMEM;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; memcpy(cp, value, size);
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; term = strchr(cp, ' ');
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (term == NULL)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; term = strchr(cp, '\n');
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (term != NULL)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; *term = '\0';
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; for (slot = 0; slot &lt; lsm_slot; slot++)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (!strcmp(cp, lsm_slotlist[slot]-&gt;lsm)) {
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; *display = lsm_slotlist[slot]-&gt;slot;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; rc = size;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; break;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; kfree(cp);
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return rc;
&gt;&gt; +&#xA0;&#xA0;&#xA0; }
&gt;&gt; &#xA0; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; hlist_for_each_entry(hp, &amp;security_hook_heads.setprocattr, list) {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (lsm != NULL &amp;&amp; strcmp(lsm, hp-&gt;lsmid-&gt;lsm))
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; continue;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (lsm == NULL &amp;&amp; *display != LSMBLOB_INVALID &amp;&amp;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; *display != hp-&gt;lsmid-&gt;slot)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; continue;
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return hp-&gt;hook.setprocattr(name, value, size);
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return -EINVAL;
&gt;&gt; @@ -2003,15 +2084,15 @@ EXPORT_SYMBOL(security_ismaclabel);
&gt;&gt; &#xA0; int security_secid_to_secctx(struct lsmblob *blob, char **secdata, u32 *seclen)
&gt;&gt; &#xA0; {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct security_hook_list *hp;
&gt;&gt; -&#xA0;&#xA0;&#xA0; int rc;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *display = current-&gt;security;
&gt;&gt; &#xA0; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; hlist_for_each_entry(hp, &amp;security_hook_heads.secid_to_secctx, list) {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (WARN_ON(hp-&gt;lsmid-&gt;slot &lt; 0 || hp-&gt;lsmid-&gt;slot &gt;= lsm_slot))
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; continue;
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; rc = hp-&gt;hook.secid_to_secctx(blob-&gt;secid[hp-&gt;lsmid-&gt;slot],
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; secdata, seclen);
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (rc != 0)
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return rc;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (*display == LSMBLOB_INVALID || *display == hp-&gt;lsmid-&gt;slot)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return hp-&gt;hook.secid_to_secctx(
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; blob-&gt;secid[hp-&gt;lsmid-&gt;slot],
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; secdata, seclen);
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return 0;
&gt;&gt; &#xA0; }
&gt;&gt; @@ -2021,16 +2102,15 @@ int security_secctx_to_secid(const char *secdata, u32 seclen,
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct lsmblob *blob)
&gt;&gt; &#xA0; {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct security_hook_list *hp;
&gt;&gt; -&#xA0;&#xA0;&#xA0; int rc;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *display = current-&gt;security;
&gt;&gt; &#xA0; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; lsmblob_init(blob, 0);
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; hlist_for_each_entry(hp, &amp;security_hook_heads.secctx_to_secid, list) {
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (WARN_ON(hp-&gt;lsmid-&gt;slot &lt; 0 || hp-&gt;lsmid-&gt;slot &gt;= lsm_slot))
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; continue;
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; rc = hp-&gt;hook.secctx_to_secid(secdata, seclen,
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &amp;blob-&gt;secid[hp-&gt;lsmid-&gt;slot]);
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (rc != 0)
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return rc;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (*display == LSMBLOB_INVALID || *display == hp-&gt;lsmid-&gt;slot)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return hp-&gt;hook.secctx_to_secid(secdata, seclen,
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &amp;blob-&gt;secid[hp-&gt;lsmid-&gt;slot]);
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return 0;
&gt;&gt; &#xA0; }
&gt;&gt; @@ -2038,7 +2118,15 @@ EXPORT_SYMBOL(security_secctx_to_secid);
&gt;&gt; &#xA0; &#xA0; void security_release_secctx(char *secdata, u32 seclen)
&gt;&gt; &#xA0; {
&gt;&gt; -&#xA0;&#xA0;&#xA0; call_void_hook(release_secctx, secdata, seclen);
&gt;&gt; +&#xA0;&#xA0;&#xA0; struct security_hook_list *hp;
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *display = current-&gt;security;
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0; hlist_for_each_entry(hp, &amp;security_hook_heads.release_secctx, list)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (*display == LSMBLOB_INVALID ||
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; *display == hp-&gt;lsmid-&gt;slot) {
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; hp-&gt;hook.release_secctx(secdata, seclen);
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return;
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt; &#xA0; }
&gt;&gt; &#xA0; EXPORT_SYMBOL(security_release_secctx);
&gt;&gt; &#xA0; @@ -2163,8 +2251,15 @@ EXPORT_SYMBOL(security_sock_rcv_skb);
&gt;&gt; &#xA0; int security_socket_getpeersec_stream(struct socket *sock, char __user *optval,
&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int __user *optlen, unsigned len)
&gt;&gt; &#xA0; {
&gt;&gt; -&#xA0;&#xA0;&#xA0; return call_int_hook(socket_getpeersec_stream, -ENOPROTOOPT, sock,
&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; optval, optlen, len);
&gt;&gt; +&#xA0;&#xA0;&#xA0; int *display = current-&gt;security;
&gt;&gt; +&#xA0;&#xA0;&#xA0; struct security_hook_list *hp;
&gt;&gt; +
&gt;&gt; +&#xA0;&#xA0;&#xA0; hlist_for_each_entry(hp, &amp;security_hook_heads.socket_getpeersec_stream,
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; list)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (*display == LSMBLOB_INVALID || *display == hp-&gt;lsmid-&gt;slot)
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return hp-&gt;hook.socket_getpeersec_stream(sock, optval,
&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; optlen, len);
&gt;&gt; +&#xA0;&#xA0;&#xA0; return -ENOPROTOOPT;
&gt;&gt; &#xA0; }
&gt;&gt; &#xA0; &#xA0; int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb,
&gt;&gt;
&gt;



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="29571" href="msg29571.html">Re: [PATCH v4 15/23] LSM: Specify which LSM to display</a></strong>
<ul><li><em>From:</em> John Johansen</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="29370" href="msg29370.html">[PATCH v4 00/23] LSM: Module stacking for AppArmor</a></strong>
<ul><li><em>From:</em> Casey Schaufler</li></ul></li>
<li><strong><a name="29385" href="msg29385.html">[PATCH v4 15/23] LSM: Specify which LSM to display</a></strong>
<ul><li><em>From:</em> Casey Schaufler</li></ul></li>
<li><strong><a name="29546" href="msg29546.html">Re: [PATCH v4 15/23] LSM: Specify which LSM to display</a></strong>
<ul><li><em>From:</em> Stephen Smalley</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg29564.html">[PATCH 6/6] Add sample notification program [ver #5]</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg29566.html">Re: [RFC PATCH v4 10/12] security/selinux: Add enclave_load() implementation</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg29546.html">Re: [PATCH v4 15/23] LSM: Specify which LSM to display</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg29571.html">Re: [PATCH v4 15/23] LSM: Specify which LSM to display</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#29565"><strong>Date</strong></a></li>
<li><a href="index.html#29565"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-users/>[Fedora&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
