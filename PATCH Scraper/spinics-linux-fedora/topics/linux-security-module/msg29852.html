<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications -->
<!--X-From-R13: Qnfrl Epunhsyre &#60;pnfrlNfpunhsyre&#45;pn.pbz> -->
<!--X-Date: Wed, 10 Jul 2019 13:10:19 &#45;0700 -->
<!--X-Message-Id: cf77e582&#45;b6d8&#45;091c&#45;f760&#45;e349574e3224@schaufler&#45;ca.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190710133403.855&#45;1&#45;acgoide@tycho.nsa.gov -->
<!--X-Reference: 4fd98c88&#45;61a6&#45;a155&#45;5028&#45;db22a778d3c1@schaufler&#45;ca.com -->
<!--X-Reference: 8edfc3d7&#45;9944&#45;9aed&#45;061b&#45;b81f54ebddc3@tycho.nsa.gov -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Linux Security Module, Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux Security Module -- Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications</title>
<link rel="alternate" type="application/rss+xml" title="Linux Security Module" href="//feeds.feedburner.com/LinuxSecurityModule">
</head>
<body vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications</h1>
[<a href="msg29851.html">Date Prev</a>][<a href="msg29853.html">Date Next</a>][<a href="msg29850.html">Thread Prev</a>][<a href="msg29884.html">Thread Next</a>][<a href="maillist.html#29852">Date Index</a>][<a href="index.html#29852">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications</li>
<li><em>From</em>: Casey Schaufler &lt;casey@xxxxxxxxxxxxxxxx&gt;</li>
<li><em>Date</em>: Wed, 10 Jul 2019 13:09:53 -0700</li>
<li><em>Cc</em>: selinux@xxxxxxxxxxxxxxx, linux-security-module@xxxxxxxxxxxxxxx,        linux-fsdevel@xxxxxxxxxxxxxxx, dhowells@xxxxxxxxxx, jack@xxxxxxx,        amir73il@xxxxxxxxx, jmorris@xxxxxxxxx, linux-kernel@xxxxxxxxxxxxxxx,        casey@xxxxxxxxxxxxxxxx</li>
<li><em>In-reply-to</em>: &lt;<a href="msg29850.html">8edfc3d7-9944-9aed-061b-b81f54ebddc3@tycho.nsa.gov</a>&gt;</li>
<li><em>Openpgp</em>: preference=signencrypt</li>
<li><em>References</em>: &lt;<a href="msg29834.html">20190710133403.855-1-acgoide@tycho.nsa.gov</a>&gt; &lt;<a href="msg29839.html">4fd98c88-61a6-a155-5028-db22a778d3c1@schaufler-ca.com</a>&gt; &lt;<a href="msg29850.html">8edfc3d7-9944-9aed-061b-b81f54ebddc3@tycho.nsa.gov</a>&gt;</li>
<li><em>User-agent</em>: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:60.0) Gecko/20100101 Thunderbird/60.7.2</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On 7/10/2019 11:39 AM, Stephen Smalley wrote:
&gt; On 7/10/19 12:38 PM, Casey Schaufler wrote:
&gt;&gt; On 7/10/2019 6:34 AM, Aaron Goidel wrote:
&gt;&gt;&gt; As of now, setting watches on filesystem objects has, at most, applied a
&gt;&gt;&gt; check for read access to the inode, and in the case of fanotify, requires
&gt;&gt;&gt; CAP_SYS_ADMIN. No specific security hook or permission check has been
&gt;&gt;&gt; provided to control the setting of watches. Using any of inotify, dnotify,
&gt;&gt;&gt; or fanotify, it is possible to observe, not only write-like operations, but
&gt;&gt;&gt; even read access to a file. Modeling the watch as being merely a read from
&gt;&gt;&gt; the file is insufficient.
&gt;&gt;
&gt;&gt; That's a very model-specific viewpoint. It is true for
&gt;&gt; a fine-grained model such as SELinux, but not necessarily
&gt;&gt; for a model with more traditional object definitions.
&gt;&gt; I'm not saying you're wrong, I'm saying that stating it
&gt;&gt; as a given assumes your model. You can do that all you want
&gt;&gt; within SELinux, but it doesn't hold when you're talking
&gt;&gt; about the LSM infrastructure.
&gt;
&gt; I think you'll find that even for Smack, merely checking read access to the watched inode is insufficient for your purposes, because the watch permits more than just observing changes to the state of the inode.&#xA0; The absence of a hook is a gap in LSM coverage, regardless of security model.&#xA0; If you are just objecting to the wording choice, then I suppose that can be amended to &quot;is insufficient for SELinux&quot; or &quot;is insufficient for some needs&quot; or something.

More an objection to the assumption of model than anything else.
There are enough differing viewpoints on what is necessary and/or
sufficient that I wouldn't want the assumption to be a bone of
contention later on.

&gt;
&gt;&gt; Have you coordinated this with the work that David Howells
&gt;&gt; is doing on generic notifications?
&gt;
&gt; We're following that work but to date it hasn't appeared to address dnotify/inotify/fanotify IIUC.&#xA0; I think it is complementary; we are adding LSM control over an existing kernel notification mechanism while he is adding a new notification facility for other kinds of events along with corresponding LSM hooks.&#xA0; It is consistent in that it provides a way to control setting of watches based on the watched object.

All true. My hope is that LSM controls on notification mechanisms
have some sort of coordination. I'd rather have one hook that's used
in multiple places than yet another set of disparate hooks that do
mostly the same thing.

&gt;
&gt;&gt;&gt; Furthermore, fanotify watches grant more power to
&gt;&gt;&gt; an application in the form of permission events. While notification events
&gt;&gt;&gt; are solely, unidirectional (i.e. they only pass information to the
&gt;&gt;&gt; receiving application), permission events are blocking. Permission events
&gt;&gt;&gt; make a request to the receiving application which will then reply with a
&gt;&gt;&gt; decision as to whether or not that action may be completed.
&gt;&gt;
&gt;&gt; You're not saying why this is an issue.
&gt;
&gt; It allows the watching application control over the process that is attempting the access.&#xA0; Are you just asking for that to be stated more explicitly?

Yes, that would be good.

&gt;
&gt;&gt;&gt; In order to solve these issues, a new LSM hook is implemented and has been
&gt;&gt;&gt; placed within the system calls for marking filesystem objects with inotify,
&gt;&gt;&gt; fanotify, and dnotify watches. These calls to the hook are placed at the
&gt;&gt;&gt; point at which the target inode has been resolved and are provided with
&gt;&gt;&gt; both the inode and the mask of requested notification events. The mask has
&gt;&gt;&gt; already been translated into common FS_* values shared by the entirety of
&gt;&gt;&gt; the fs notification infrastructure.
&gt;&gt;&gt;
&gt;&gt;&gt; This only provides a hook at the point of setting a watch, and presumes
&gt;&gt;&gt; that permission to set a particular watch implies the ability to receive
&gt;&gt;&gt; all notification about that object which match the mask. This is all that
&gt;&gt;&gt; is required for SELinux. If other security modules require additional hooks
&gt;&gt;&gt; or infrastructure to control delivery of notification, these can be added
&gt;&gt;&gt; by them. It does not make sense for us to propose hooks for which we have
&gt;&gt;&gt; no implementation. The understanding that all notifications received by the
&gt;&gt;&gt; requesting application are all strictly of a type for which the application
&gt;&gt;&gt; has been granted permission shows that this implementation is sufficient in
&gt;&gt;&gt; its coverage.
&gt;&gt;
&gt;&gt; A reasonable approach. It would be *nice* if you had
&gt;&gt; a look at the other security modules to see what they
&gt;&gt; might need from such a hook or hook set.
&gt;&gt;
&gt;&gt;&gt; Fanotify further has the issue that it returns a file descriptor with the
&gt;&gt;&gt; file mode specified during fanotify_init() to the watching process on
&gt;&gt;&gt; event. This is already covered by the LSM security_file_open hook if the
&gt;&gt;&gt; security module implements checking of the requested file mode there.
&gt;&gt;
&gt;&gt; How is this relevant?
&gt;
&gt; It is part of ensuring complete control over fanotify.&#xA0; Some existing security modules (like Smack, for example) currently do not perform this checking of the requested file mode and therefore are subject to this privilege escalation scenario through fanotify.&#xA0; A watcher that only has read access to the file can get a read-write descriptor to it in this manner.&#xA0; You may argue that this doesn't matter because fanotify requires CAP_SYS_ADMIN but even for Smack that isn't the same as CAP_MAC_OVERRIDE.

Yes, there's a difference in the assumptions security modules
make about the privilege escalation. Again the point is that
it isn't a good idea to include a single module's policy regarding
that in the argument for the generic hook. It's enough to explain
why SELinux needs it.

&gt;
&gt;&gt;
&gt;&gt;&gt; The selinux_inode_notify hook implementation works by adding three new
&gt;&gt;&gt; file permissions: watch, watch_reads, and watch_with_perm (descriptions
&gt;&gt;&gt; about which will follow). The hook then decides which subset of these
&gt;&gt;&gt; permissions must be held by the requesting application based on the
&gt;&gt;&gt; contents of the provided mask. The selinux_file_open hook already checks
&gt;&gt;&gt; the requested file mode and therefore ensures that a watching process
&gt;&gt;&gt; cannot escalate its access through fanotify.
&gt;&gt;
&gt;&gt; Thereby increasing the granularity of control available.
&gt;
&gt; It isn't merely a question of granularity but also completeness and preventing privilege escalation.

I was simply making an observation.

&gt;
&gt;&gt;&gt; The watch permission is the baseline permission for setting a watch on an
&gt;&gt;&gt; object and is a requirement for any watch to be set whatsoever. It should
&gt;&gt;&gt; be noted that having either of the other two permissions (watch_reads and
&gt;&gt;&gt; watch_with_perm) does not imply the watch permission, though this could be
&gt;&gt;&gt; changed if need be.
&gt;&gt;&gt;
&gt;&gt;&gt; The watch_reads permission is required to receive notifications from
&gt;&gt;&gt; read-exclusive events on filesystem objects. These events include accessing
&gt;&gt;&gt; a file for the purpose of reading and closing a file which has been opened
&gt;&gt;&gt; read-only. This distinction has been drawn in order to provide a direct
&gt;&gt;&gt; indication in the policy for this otherwise not obvious capability. Read
&gt;&gt;&gt; access to a file should not necessarily imply the ability to observe read
&gt;&gt;&gt; events on a file.
&gt;&gt;&gt;
&gt;&gt;&gt; Finally, watch_with_perm only applies to fanotify masks since it is the
&gt;&gt;&gt; only way to set a mask which allows for the blocking, permission event.
&gt;&gt;&gt; This permission is needed for any watch which is of this type. Though
&gt;&gt;&gt; fanotify requires CAP_SYS_ADMIN, this is insufficient as it gives implicit
&gt;&gt;&gt; trust to root, which we do not do, and does not support least privilege.
&gt;&gt;&gt;
&gt;&gt;&gt; Signed-off-by: Aaron Goidel &lt;acgoide@xxxxxxxxxxxxx&gt;
&gt;&gt;&gt; ---
&gt;&gt;&gt; &#xA0; fs/notify/dnotify/dnotify.c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | 14 +++++++++++---
&gt;&gt;&gt; &#xA0; fs/notify/fanotify/fanotify_user.c&#xA0; | 11 +++++++++--
&gt;&gt;&gt; &#xA0; fs/notify/inotify/inotify_user.c&#xA0;&#xA0;&#xA0; | 12 ++++++++++--
&gt;&gt;&gt; &#xA0; include/linux/lsm_hooks.h&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; |&#xA0; 2 ++
&gt;&gt;&gt; &#xA0; include/linux/security.h&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; |&#xA0; 7 +++++++
&gt;&gt;&gt; &#xA0; security/security.c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; |&#xA0; 5 +++++
&gt;&gt;&gt; &#xA0; security/selinux/hooks.c&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | 22 ++++++++++++++++++++++
&gt;&gt;&gt; &#xA0; security/selinux/include/classmap.h |&#xA0; 2 +-
&gt;&gt;&gt; &#xA0; 8 files changed, 67 insertions(+), 8 deletions(-)
&gt;&gt;&gt;
&gt;&gt;&gt; diff --git a/fs/notify/dnotify/dnotify.c b/fs/notify/dnotify/dnotify.c
&gt;&gt;&gt; index 250369d6901d..e91ce092efb1 100644
&gt;&gt;&gt; --- a/fs/notify/dnotify/dnotify.c
&gt;&gt;&gt; +++ b/fs/notify/dnotify/dnotify.c
&gt;&gt;&gt; @@ -22,6 +22,7 @@
&gt;&gt;&gt; &#xA0; #include &lt;linux/sched/signal.h&gt;
&gt;&gt;&gt; &#xA0; #include &lt;linux/dnotify.h&gt;
&gt;&gt;&gt; &#xA0; #include &lt;linux/init.h&gt;
&gt;&gt;&gt; +#include &lt;linux/security.h&gt;
&gt;&gt;&gt; &#xA0; #include &lt;linux/spinlock.h&gt;
&gt;&gt;&gt; &#xA0; #include &lt;linux/slab.h&gt;
&gt;&gt;&gt; &#xA0; #include &lt;linux/fdtable.h&gt;
&gt;&gt;&gt; @@ -288,6 +289,16 @@ int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; goto out_err;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt;&gt; &#xA0; +&#xA0;&#xA0;&#xA0; /*
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0; * convert the userspace DN_* &quot;arg&quot; to the internal FS_*
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0; * defined in fsnotify
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0; */
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; mask = convert_arg(arg);
&gt;&gt;&gt; +
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; error = security_inode_notify(inode, mask);
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; if (error)
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; goto out_err;
&gt;&gt;&gt; +
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /* expect most fcntl to add new rather than augment old */
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; dn = kmem_cache_alloc(dnotify_struct_cache, GFP_KERNEL);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (!dn) {
&gt;&gt;&gt; @@ -302,9 +313,6 @@ int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; goto out_err;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt;&gt; &#xA0; -&#xA0;&#xA0;&#xA0; /* convert the userspace DN_* &quot;arg&quot; to the internal FS_* defines in fsnotify */
&gt;&gt;&gt; -&#xA0;&#xA0;&#xA0; mask = convert_arg(arg);
&gt;&gt;&gt; -
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /* set up the new_fsn_mark and new_dn_mark */
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; new_fsn_mark = &amp;new_dn_mark-&gt;fsn_mark;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; fsnotify_init_mark(new_fsn_mark, dnotify_group);
&gt;&gt;&gt; diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
&gt;&gt;&gt; index a90bb19dcfa2..c0d9fa998377 100644
&gt;&gt;&gt; --- a/fs/notify/fanotify/fanotify_user.c
&gt;&gt;&gt; +++ b/fs/notify/fanotify/fanotify_user.c
&gt;&gt;&gt; @@ -528,7 +528,7 @@ static const struct file_operations fanotify_fops = {
&gt;&gt;&gt; &#xA0; };
&gt;&gt;&gt; &#xA0; &#xA0; static int fanotify_find_path(int dfd, const char __user *filename,
&gt;&gt;&gt; -&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct path *path, unsigned int flags)
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct path *path, unsigned int flags, __u64 mask)
&gt;&gt;&gt; &#xA0; {
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int ret;
&gt;&gt;&gt; &#xA0; @@ -567,8 +567,15 @@ static int fanotify_find_path(int dfd, const char __user *filename,
&gt;&gt;&gt; &#xA0; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /* you can only watch an inode if you have read permissions on it */
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ret = inode_permission(path-&gt;dentry-&gt;d_inode, MAY_READ);
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; if (ret) {
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; path_put(path);
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; goto out;
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; }
&gt;&gt;&gt; +
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; ret = security_inode_notify(path-&gt;dentry-&gt;d_inode, mask);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (ret)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; path_put(path);
&gt;&gt;&gt; +
&gt;&gt;&gt; &#xA0; out:
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return ret;
&gt;&gt;&gt; &#xA0; }
&gt;&gt;&gt; @@ -1014,7 +1021,7 @@ static int do_fanotify_mark(int fanotify_fd, unsigned int flags, __u64 mask,
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; goto fput_and_out;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; }
&gt;&gt;&gt; &#xA0; -&#xA0;&#xA0;&#xA0; ret = fanotify_find_path(dfd, pathname, &amp;path, flags);
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; ret = fanotify_find_path(dfd, pathname, &amp;path, flags, mask);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (ret)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; goto fput_and_out;
&gt;&gt;&gt; &#xA0; diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
&gt;&gt;&gt; index 7b53598c8804..47b079f20aad 100644
&gt;&gt;&gt; --- a/fs/notify/inotify/inotify_user.c
&gt;&gt;&gt; +++ b/fs/notify/inotify/inotify_user.c
&gt;&gt;&gt; @@ -39,6 +39,7 @@
&gt;&gt;&gt; &#xA0; #include &lt;linux/poll.h&gt;
&gt;&gt;&gt; &#xA0; #include &lt;linux/wait.h&gt;
&gt;&gt;&gt; &#xA0; #include &lt;linux/memcontrol.h&gt;
&gt;&gt;&gt; +#include &lt;linux/security.h&gt;
&gt;&gt;&gt; &#xA0; &#xA0; #include &quot;inotify.h&quot;
&gt;&gt;&gt; &#xA0; #include &quot;../fdinfo.h&quot;
&gt;&gt;&gt; @@ -342,7 +343,8 @@ static const struct file_operations inotify_fops = {
&gt;&gt;&gt; &#xA0; /*
&gt;&gt;&gt; &#xA0;&#xA0; * find_inode - resolve a user-given path to a specific inode
&gt;&gt;&gt; &#xA0;&#xA0; */
&gt;&gt;&gt; -static int inotify_find_inode(const char __user *dirname, struct path *path, unsigned flags)
&gt;&gt;&gt; +static int inotify_find_inode(const char __user *dirname, struct path *path,
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; unsigned int flags, __u64 mask)
&gt;&gt;&gt; &#xA0; {
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int error;
&gt;&gt;&gt; &#xA0; @@ -351,8 +353,14 @@ static int inotify_find_inode(const char __user *dirname, struct path *path, uns
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return error;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; /* you can only watch an inode if you have read permissions on it */
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; error = inode_permission(path-&gt;dentry-&gt;d_inode, MAY_READ);
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; if (error) {
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; path_put(path);
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return error;
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; }
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; error = security_inode_notify(path-&gt;dentry-&gt;d_inode, mask);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (error)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; path_put(path);
&gt;&gt;&gt; +
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return error;
&gt;&gt;&gt; &#xA0; }
&gt;&gt;&gt; &#xA0; @@ -744,7 +752,7 @@ SYSCALL_DEFINE3(inotify_add_watch, int, fd, const char __user *, pathname,
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (mask &amp; IN_ONLYDIR)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; flags |= LOOKUP_DIRECTORY;
&gt;&gt;&gt; &#xA0; -&#xA0;&#xA0;&#xA0; ret = inotify_find_inode(pathname, &amp;path, flags);
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; ret = inotify_find_inode(pathname, &amp;path, flags, mask);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; if (ret)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; goto fput_and_out;
&gt;&gt;&gt; &#xA0; diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
&gt;&gt;&gt; index 47f58cfb6a19..ef6b74938dd8 100644
&gt;&gt;&gt; --- a/include/linux/lsm_hooks.h
&gt;&gt;&gt; +++ b/include/linux/lsm_hooks.h
&gt;&gt;
&gt;&gt; Hook description comment is missing.
&gt;&gt;
&gt;&gt;&gt; @@ -1571,6 +1571,7 @@ union security_list_options {
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int (*inode_getxattr)(struct dentry *dentry, const char *name);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int (*inode_listxattr)(struct dentry *dentry);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int (*inode_removexattr)(struct dentry *dentry, const char *name);
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; int (*inode_notify)(struct inode *inode, u64 mask);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int (*inode_need_killpriv)(struct dentry *dentry);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int (*inode_killpriv)(struct dentry *dentry);
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; int (*inode_getsecurity)(struct inode *inode, const char *name,
&gt;&gt;&gt; @@ -1881,6 +1882,7 @@ struct security_hook_heads {
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct hlist_head inode_getxattr;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct hlist_head inode_listxattr;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct hlist_head inode_removexattr;
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; struct hlist_head inode_notify;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct hlist_head inode_need_killpriv;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct hlist_head inode_killpriv;
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct hlist_head inode_getsecurity;
&gt;&gt;&gt; diff --git a/include/linux/security.h b/include/linux/security.h
&gt;&gt;&gt; index 659071c2e57c..50106fb9eef9 100644
&gt;&gt;&gt; --- a/include/linux/security.h
&gt;&gt;&gt; +++ b/include/linux/security.h
&gt;&gt;&gt; @@ -301,6 +301,7 @@ int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer
&gt;&gt;&gt; &#xA0; void security_inode_getsecid(struct inode *inode, u32 *secid);
&gt;&gt;&gt; &#xA0; int security_inode_copy_up(struct dentry *src, struct cred **new);
&gt;&gt;&gt; &#xA0; int security_inode_copy_up_xattr(const char *name);
&gt;&gt;&gt; +int security_inode_notify(struct inode *inode, u64 mask);
&gt;&gt;&gt; &#xA0; int security_kernfs_init_security(struct kernfs_node *kn_dir,
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; struct kernfs_node *kn);
&gt;&gt;&gt; &#xA0; int security_file_permission(struct file *file, int mask);
&gt;&gt;&gt; @@ -392,6 +393,7 @@ void security_inode_invalidate_secctx(struct inode *inode);
&gt;&gt;&gt; &#xA0; int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen);
&gt;&gt;&gt; &#xA0; int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen);
&gt;&gt;&gt; &#xA0; int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen);
&gt;&gt;&gt; +
&gt;&gt;
&gt;&gt; Please don't change whitespace unless it's directly adjacent to your code.
&gt;&gt;
&gt;&gt;&gt; &#xA0; #else /* CONFIG_SECURITY */
&gt;&gt;&gt; &#xA0; &#xA0; static inline int call_lsm_notifier(enum lsm_event event, void *data)
&gt;&gt;&gt; @@ -776,6 +778,11 @@ static inline int security_inode_removexattr(struct dentry *dentry,
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return cap_inode_removexattr(dentry, name);
&gt;&gt;&gt; &#xA0; }
&gt;&gt;&gt; &#xA0; +static inline int security_inode_notify(struct inode *inode, u64 mask)
&gt;&gt;&gt; +{
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; return 0;
&gt;&gt;&gt; +}
&gt;&gt;&gt; +
&gt;&gt;&gt; &#xA0; static inline int security_inode_need_killpriv(struct dentry *dentry)
&gt;&gt;&gt; &#xA0; {
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return cap_inode_need_killpriv(dentry);
&gt;&gt;&gt; diff --git a/security/security.c b/security/security.c
&gt;&gt;&gt; index 613a5c00e602..57b2a96c1991 100644
&gt;&gt;&gt; --- a/security/security.c
&gt;&gt;&gt; +++ b/security/security.c
&gt;&gt;&gt; @@ -1251,6 +1251,11 @@ int security_inode_removexattr(struct dentry *dentry, const char *name)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return evm_inode_removexattr(dentry, name);
&gt;&gt;&gt; &#xA0; }
&gt;&gt;&gt; &#xA0; +int security_inode_notify(struct inode *inode, u64 mask)
&gt;&gt;&gt; +{
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; return call_int_hook(inode_notify, 0, inode, mask);
&gt;&gt;&gt; +}
&gt;&gt;&gt; +
&gt;&gt;&gt; &#xA0; int security_inode_need_killpriv(struct dentry *dentry)
&gt;&gt;&gt; &#xA0; {
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return call_int_hook(inode_need_killpriv, 0, dentry);
&gt;&gt;&gt; diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
&gt;&gt;&gt; index c61787b15f27..1a37966c2978 100644
&gt;&gt;&gt; --- a/security/selinux/hooks.c
&gt;&gt;&gt; +++ b/security/selinux/hooks.c
&gt;&gt;&gt; @@ -92,6 +92,7 @@
&gt;&gt;&gt; &#xA0; #include &lt;linux/kernfs.h&gt;
&gt;&gt;&gt; &#xA0; #include &lt;linux/stringhash.h&gt;&#xA0;&#xA0;&#xA0; /* for hashlen_string() */
&gt;&gt;&gt; &#xA0; #include &lt;uapi/linux/mount.h&gt;
&gt;&gt;&gt; +#include &lt;linux/fsnotify.h&gt;
&gt;&gt;&gt; &#xA0; &#xA0; #include &quot;avc.h&quot;
&gt;&gt;&gt; &#xA0; #include &quot;objsec.h&quot;
&gt;&gt;&gt; @@ -3261,6 +3262,26 @@ static int selinux_inode_removexattr(struct dentry *dentry, const char *name)
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; return -EACCES;
&gt;&gt;&gt; &#xA0; }
&gt;&gt;&gt; &#xA0; +static int selinux_inode_notify(struct inode *inode, u64 mask)
&gt;&gt;&gt; +{
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; u32 perm = FILE__WATCH; // basic permission, can a watch be set?
&gt;&gt;
&gt;&gt; We don't use // comments in the Linux kernel.
&gt;&gt;
&gt;&gt;&gt; +
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; struct common_audit_data ad;
&gt;&gt;&gt; +
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; ad.type = LSM_AUDIT_DATA_INODE;
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; ad.u.inode = inode;
&gt;&gt;&gt; +
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; // check if the mask is requesting ability to set a blocking watch
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; if (mask &amp; (FS_OPEN_PERM | FS_OPEN_EXEC_PERM | FS_ACCESS_PERM))
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; perm |= FILE__WATCH_WITH_PERM; // if so, check that permission
&gt;&gt;&gt; +
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; // is the mask asking to watch file reads?
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; if (mask &amp; (FS_ACCESS | FS_ACCESS_PERM | FS_CLOSE_NOWRITE))
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; perm |= FILE__WATCH_READS; // check that permission as well
&gt;&gt;&gt; +
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; return inode_has_perm(current_cred(), inode, perm, &amp;ad);
&gt;&gt;&gt; +}
&gt;&gt;&gt; +
&gt;&gt;&gt; &#xA0; /*
&gt;&gt;&gt; &#xA0;&#xA0; * Copy the inode security context value to the user.
&gt;&gt;&gt; &#xA0;&#xA0; *
&gt;&gt;&gt; @@ -6797,6 +6818,7 @@ static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LSM_HOOK_INIT(inode_getsecid, selinux_inode_getsecid),
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LSM_HOOK_INIT(inode_copy_up, selinux_inode_copy_up),
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LSM_HOOK_INIT(inode_copy_up_xattr, selinux_inode_copy_up_xattr),
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; LSM_HOOK_INIT(inode_notify, selinux_inode_notify),
&gt;&gt;&gt; &#xA0; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; LSM_HOOK_INIT(kernfs_init_security, selinux_kernfs_init_security),
&gt;&gt;&gt; &#xA0; diff --git a/security/selinux/include/classmap.h b/security/selinux/include/classmap.h
&gt;&gt;&gt; index 201f7e588a29..0654dd2fbebf 100644
&gt;&gt;&gt; --- a/security/selinux/include/classmap.h
&gt;&gt;&gt; +++ b/security/selinux/include/classmap.h
&gt;&gt;&gt; @@ -7,7 +7,7 @@
&gt;&gt;&gt; &#xA0; &#xA0; #define COMMON_FILE_PERMS COMMON_FILE_SOCK_PERMS, &quot;unlink&quot;, &quot;link&quot;, \
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &quot;rename&quot;, &quot;execute&quot;, &quot;quotaon&quot;, &quot;mounton&quot;, &quot;audit_access&quot;, \
&gt;&gt;&gt; -&#xA0;&#xA0;&#xA0; &quot;open&quot;, &quot;execmod&quot;
&gt;&gt;&gt; +&#xA0;&#xA0;&#xA0; &quot;open&quot;, &quot;execmod&quot;, &quot;watch&quot;, &quot;watch_with_perm&quot;, &quot;watch_reads&quot;
&gt;&gt;&gt; &#xA0; &#xA0; #define COMMON_SOCK_PERMS COMMON_FILE_SOCK_PERMS, &quot;bind&quot;, &quot;connect&quot;, \
&gt;&gt;&gt; &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &quot;listen&quot;, &quot;accept&quot;, &quot;getopt&quot;, &quot;setopt&quot;, &quot;shutdown&quot;, &quot;recvfrom&quot;,&#xA0; \
&gt;&gt;
&gt;




</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="29834" href="msg29834.html">[RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications</a></strong>
<ul><li><em>From:</em> Aaron Goidel</li></ul></li>
<li><strong><a name="29839" href="msg29839.html">Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications</a></strong>
<ul><li><em>From:</em> Casey Schaufler</li></ul></li>
<li><strong><a name="29850" href="msg29850.html">Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications</a></strong>
<ul><li><em>From:</em> Stephen Smalley</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg29851.html">Re: [GIT PULL] Keys: Set 4 - Key ACLs for 5.3</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg29853.html">Re: [GIT PULL] Keys: Set 4 - Key ACLs for 5.3</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg29850.html">Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg29884.html">Re: [RFC PATCH] fanotify, inotify, dnotify, security: add security hook for fs notifications</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#29852"><strong>Date</strong></a></li>
<li><a href="index.html#29852"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-users/>[Fedora&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-desktop/>[Fedora&nbsp;Desktop]</a>
&nbsp;
&nbsp;
<a href=/lists/fedora-selinux/>[Fedora&nbsp;SELinux]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kde/>[KDE&nbsp;Users]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
