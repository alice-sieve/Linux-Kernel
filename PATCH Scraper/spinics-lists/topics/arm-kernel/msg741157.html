<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH AUTOSEL 5.2 082/249] perf cs&#45;etm: Properly set the value of 'old' and 'head' in snapshot mode -->
<!--X-From-R13: Enfun Zriva &#60;fnfunyNxreary.bet> -->
<!--X-Date: Mon, 15 Jul 2019 06:51:36 &#45;0700 -->
<!--X-Message-Id: 20190715134655.4076&#45;82&#45;sashal@kernel.org -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190715134655.4076&#45;1&#45;sashal@kernel.org -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<meta name="description" content="Linux ARM, OMAP, Xscale Kernel: [PATCH AUTOSEL 5.2 082/249] perf cs-etm: Properly set the value of 'old' and 'head' in snapshot mode">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>[PATCH AUTOSEL 5.2 082/249] perf cs-etm: Properly set the value of 'old' and 'head' in snapshot mode &mdash; ARM, OMAP, Xscale Linux Kernel</title>
<link rel="alternate" type="application/rss+xml" title="Linux ARM Kernel" href="//feedproxy.google.com/LinuxArmKernel">
<link rel="alternate" type="application/rss+xml" title="Linux ARM Kernel" href="//feeds.feedburner.com/LinuxArmxscaleEtc">
<link rel="alternate" type="application/rss+xml" title="Fedora ARM" href="//feeds.feedburner.com/FedoraArm">
<link rel="alternate" type="application/rss+xml" title="Linux for OMAP" href="//feedproxy.google.com/LinuxOmap">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<td align=right><form action="//www.google.com/cse" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:isdiegq275o" />
    <input type="hidden" name="ie" value="ISO-8859-1" />
    <input type="text" name="q" size="37" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&amp;lang=en" async></script>
<h1 itemprop="name">[PATCH AUTOSEL 5.2 082/249] perf cs-etm: Properly set the value of 'old' and 'head' in snapshot mode</h1>
[<a href="msg741156.html">Date Prev</a>][<a href="msg741158.html">Date Next</a>][<a href="msg741133.html">Thread Prev</a>][<a href="msg741158.html">Thread Next</a>][<a href="maillist.html#741157">Date Index</a>][<a href="threads.html#741157">Thread Index</a>] 
<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH AUTOSEL 5.2 082/249] perf cs-etm: Properly set the value of 'old' and 'head' in snapshot mode</li>
<li><em>From</em>: Sasha Levin &lt;sashal@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Mon, 15 Jul 2019 09:44:07 -0400</li>
<li><em>In-reply-to</em>: &lt;20190715134655.4076-1-sashal@kernel.org&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>From: Mathieu Poirier &lt;mathieu.poirier@xxxxxxxxxx&gt;

[ Upstream commit e45c48a9a4d20ebc7b639a62c3ef8f4b08007027 ]

This patch adds the necessary intelligence to properly compute the value
of 'old' and 'head' when operating in snapshot mode.  That way we can
get the latest information in the AUX buffer and be compatible with the
generic AUX ring buffer mechanic.

Tester notes:

&gt;<i> Leo, have you had the chance to test/review this one? Suzuki?</i>

Sure.  I applied this patch on the perf/core branch (with latest
commit 3e4fbf36c1e3 'perf augmented_raw_syscalls: Move reading
filename to the loop') and passed testing with below steps:

  # perf record -e cs_etm/@tmc_etr0/ -S -m,64 --per-thread ./sort &amp;
  [1] 19097
  Bubble sorting array of 30000 elements

  # kill -USR2 19097
  # kill -USR2 19097
  # kill -USR2 19097
  [ perf record: Woken up 4 times to write data ]
  [ perf record: Captured and wrote 0.753 MB perf.data ]

Signed-off-by: Mathieu Poirier &lt;mathieu.poirier@xxxxxxxxxx&gt;
Tested-by: Leo Yan &lt;leo.yan@xxxxxxxxxx&gt;
Cc: Alexander Shishkin &lt;alexander.shishkin@xxxxxxxxxxxxxxx&gt;
Cc: Jiri Olsa &lt;jolsa@xxxxxxxxxx&gt;
Cc: Peter Zijlstra &lt;peterz@xxxxxxxxxxxxx&gt;
Cc: Suzuki Poulouse &lt;suzuki.poulose@xxxxxxx&gt;
Cc: linux-arm-kernel@xxxxxxxxxxxxxxxxxxx
Link: <a  rel="nofollow" href="http://lkml.kernel.org/r/20190605161633.12245-1-mathieu.poirier@xxxxxxxxxx">http://lkml.kernel.org/r/20190605161633.12245-1-mathieu.poirier@xxxxxxxxxx</a>
Signed-off-by: Arnaldo Carvalho de Melo &lt;acme@xxxxxxxxxx&gt;
Signed-off-by: Sasha Levin &lt;sashal@xxxxxxxxxx&gt;
---
 tools/perf/arch/arm/util/cs-etm.c | 127 +++++++++++++++++++++++++++++-
 1 file changed, 123 insertions(+), 4 deletions(-)

diff --git a/tools/perf/arch/arm/util/cs-etm.c b/tools/perf/arch/arm/util/cs-etm.c
index 911426721170..0a278bbcaba6 100644
--- a/tools/perf/arch/arm/util/cs-etm.c
+++ b/tools/perf/arch/arm/util/cs-etm.c
@@ -31,6 +31,8 @@ struct cs_etm_recording {
 	struct auxtrace_record	itr;
 	struct perf_pmu		*cs_etm_pmu;
 	struct perf_evlist	*evlist;
+	int			wrapped_cnt;
+	bool			*wrapped;
 	bool			snapshot_mode;
 	size_t			snapshot_size;
 };
@@ -536,16 +538,131 @@ static int cs_etm_info_fill(struct auxtrace_record *itr,
 	return 0;
 }
 
-static int cs_etm_find_snapshot(struct auxtrace_record *itr __maybe_unused,
+static int cs_etm_alloc_wrapped_array(struct cs_etm_recording *ptr, int idx)
+{
+	bool *wrapped;
+	int cnt = ptr-&gt;wrapped_cnt;
+
+	/* Make @ptr-&gt;wrapped as big as @idx */
+	while (cnt &lt;= idx)
+		cnt++;
+
+	/*
+	 * Free'ed in cs_etm_recording_free().  Using realloc() to avoid
+	 * cross compilation problems where the host's system supports
+	 * reallocarray() but not the target.
+	 */
+	wrapped = realloc(ptr-&gt;wrapped, cnt * sizeof(bool));
+	if (!wrapped)
+		return -ENOMEM;
+
+	wrapped[cnt - 1] = false;
+	ptr-&gt;wrapped_cnt = cnt;
+	ptr-&gt;wrapped = wrapped;
+
+	return 0;
+}
+
+static bool cs_etm_buffer_has_wrapped(unsigned char *buffer,
+				      size_t buffer_size, u64 head)
+{
+	u64 i, watermark;
+	u64 *buf = (u64 *)buffer;
+	size_t buf_size = buffer_size;
+
+	/*
+	 * We want to look the very last 512 byte (chosen arbitrarily) in
+	 * the ring buffer.
+	 */
+	watermark = buf_size - 512;
+
+	/*
+	 * @head is continuously increasing - if its value is equal or greater
+	 * than the size of the ring buffer, it has wrapped around.
+	 */
+	if (head &gt;= buffer_size)
+		return true;
+
+	/*
+	 * The value of @head is somewhere within the size of the ring buffer.
+	 * This can be that there hasn't been enough data to fill the ring
+	 * buffer yet or the trace time was so long that @head has numerically
+	 * wrapped around.  To find we need to check if we have data at the very
+	 * end of the ring buffer.  We can reliably do this because mmap'ed
+	 * pages are zeroed out and there is a fresh mapping with every new
+	 * session.
+	 */
+
+	/* @head is less than 512 byte from the end of the ring buffer */
+	if (head &gt; watermark)
+		watermark = head;
+
+	/*
+	 * Speed things up by using 64 bit transactions (see &quot;u64 *buf&quot; above)
+	 */
+	watermark &gt;&gt;= 3;
+	buf_size &gt;&gt;= 3;
+
+	/*
+	 * If we find trace data at the end of the ring buffer, @head has
+	 * been there and has numerically wrapped around at least once.
+	 */
+	for (i = watermark; i &lt; buf_size; i++)
+		if (buf[i])
+			return true;
+
+	return false;
+}
+
+static int cs_etm_find_snapshot(struct auxtrace_record *itr,
 				int idx, struct auxtrace_mmap *mm,
-				unsigned char *data __maybe_unused,
+				unsigned char *data,
 				u64 *head, u64 *old)
 {
+	int err;
+	bool wrapped;
+	struct cs_etm_recording *ptr =
+			container_of(itr, struct cs_etm_recording, itr);
+
+	/*
+	 * Allocate memory to keep track of wrapping if this is the first
+	 * time we deal with this *mm.
+	 */
+	if (idx &gt;= ptr-&gt;wrapped_cnt) {
+		err = cs_etm_alloc_wrapped_array(ptr, idx);
+		if (err)
+			return err;
+	}
+
+	/*
+	 * Check to see if *head has wrapped around.  If it hasn't only the
+	 * amount of data between *head and *old is snapshot'ed to avoid
+	 * bloating the perf.data file with zeros.  But as soon as *head has
+	 * wrapped around the entire size of the AUX ring buffer it taken.
+	 */
+	wrapped = ptr-&gt;wrapped[idx];
+	if (!wrapped &amp;&amp; cs_etm_buffer_has_wrapped(data, mm-&gt;len, *head)) {
+		wrapped = true;
+		ptr-&gt;wrapped[idx] = true;
+	}
+
 	pr_debug3(&quot;%s: mmap index %d old head %zu new head %zu size %zu\n&quot;,
 		  __func__, idx, (size_t)*old, (size_t)*head, mm-&gt;len);
 
-	*old = *head;
-	*head += mm-&gt;len;
+	/* No wrap has occurred, we can just use *head and *old. */
+	if (!wrapped)
+		return 0;
+
+	/*
+	 * *head has wrapped around - adjust *head and *old to pickup the
+	 * entire content of the AUX buffer.
+	 */
+	if (*head &gt;= mm-&gt;len) {
+		*old = *head - mm-&gt;len;
+	} else {
+		*head += mm-&gt;len;
+		*old = *head - mm-&gt;len;
+	}
 
 	return 0;
 }
@@ -586,6 +703,8 @@ static void cs_etm_recording_free(struct auxtrace_record *itr)
 {
 	struct cs_etm_recording *ptr =
 			container_of(itr, struct cs_etm_recording, itr);
+
+	zfree(&amp;ptr-&gt;wrapped);
 	free(ptr);
 }
 
-- 
2.20.1


_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@xxxxxxxxxxxxxxxxxxx
<a  rel="nofollow" href="http://lists.infradead.org/mailman/listinfo/linux-arm-kernel">http://lists.infradead.org/mailman/listinfo/linux-arm-kernel</a>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg741156.html">Re: [RFC] Add virtual SDEI support in qemu</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg741158.html">[PATCH AUTOSEL 5.2 096/249] media: s5p-mfc: fix reading min scratch buffer size on MFC v6/v7</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg741133.html">[PATCH] MIPS: fix some more fall through errors in arch/mips</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg741158.html">[PATCH AUTOSEL 5.2 096/249] media: s5p-mfc: fix reading min scratch buffer size on MFC v6/v7</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#741157"><strong>Date</strong></a></li>
<li><a href="threads.html#741157"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/kernel/>[Linux&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm/>[Linux&nbsp;ARM&nbsp;(vger)]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm-msm/>[Linux&nbsp;ARM&nbsp;MSM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;Omap]</a>
&nbsp;
&nbsp;
<a href=/lists/centos-arm-devel/>[CentOS&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/arm/>[Linux&nbsp;Arm]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-tegra/>[Linux&nbsp;Tegra]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-arm/>[Fedora&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-samsung-soc/>[Linux&nbsp;for&nbsp;Samsung&nbsp;SOC]</a>
&nbsp;
&nbsp;
<a href=/lists/ecos/>[eCos]</a>
&nbsp;
&nbsp;
<a href=/lists/fastboot/>[Linux&nbsp;Fastboot]</a>
&nbsp;
&nbsp;
<a href=/lists/gcchelp/>[Gcc&nbsp;Help]</a>
&nbsp;
&nbsp;
<a href=/lists/git/>[Git]</a>
&nbsp;
&nbsp;
<a href=/lists/dccp/>[DCCP]</a>
&nbsp;
&nbsp;
<a href=/lists/ietf-ann>[IETF&nbsp;Announce]</a>
&nbsp;
&nbsp;
<a href=/lists/security/>[Security]</a>
&nbsp;
&nbsp;
<a href=/lists/mips/>[Linux&nbsp;MIPS]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }

initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
