<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH 3/5] media: platform: Add jpeg enc feature -->
<!--X-From-R13: Jvn Xvnat &#60;kvn.wvnatNzrqvngrx.pbz> -->
<!--X-Date: Wed, 17 Jul 2019 02:32:43 &#45;0700 -->
<!--X-Message-Id: 20190717093034.22826&#45;4&#45;xia.jiang@mediatek.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190717093034.22826&#45;1&#45;xia.jiang@mediatek.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<meta name="description" content="Linux ARM, OMAP, Xscale Kernel: [PATCH 3/5] media: platform: Add jpeg enc feature">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>[PATCH 3/5] media: platform: Add jpeg enc feature &mdash; ARM, OMAP, Xscale Linux Kernel</title>
<link rel="alternate" type="application/rss+xml" title="Linux ARM Kernel" href="//feedproxy.google.com/LinuxArmKernel">
<link rel="alternate" type="application/rss+xml" title="Linux ARM Kernel" href="//feeds.feedburner.com/LinuxArmxscaleEtc">
<link rel="alternate" type="application/rss+xml" title="Fedora ARM" href="//feeds.feedburner.com/FedoraArm">
<link rel="alternate" type="application/rss+xml" title="Linux for OMAP" href="//feedproxy.google.com/LinuxOmap">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<td align=right><form action="//www.google.com/cse" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:isdiegq275o" />
    <input type="hidden" name="ie" value="ISO-8859-1" />
    <input type="text" name="q" size="37" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&amp;lang=en" async></script>
<h1 itemprop="name">[PATCH 3/5] media: platform: Add jpeg enc feature</h1>
[<a href="msg741528.html">Date Prev</a>][<a href="msg741530.html">Date Next</a>][<a href="msg741528.html">Thread Prev</a>][<a href="msg741530.html">Thread Next</a>][<a href="maillist.html#741529">Date Index</a>][<a href="threads.html#741529">Thread Index</a>] 
<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH 3/5] media: platform: Add jpeg enc feature</li>
<li><em>From</em>: Xia Jiang &lt;xia.jiang@xxxxxxxxxxxx&gt;</li>
<li><em>Date</em>: Wed, 17 Jul 2019 17:30:32 +0800</li>
<li><em>In-reply-to</em>: &lt;<a href="msg741522.html">20190717093034.22826-1-xia.jiang@mediatek.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Add mtk jpeg encode v4l2 driver based on jpeg decode, because that jpeg
decode and encode have great similarities with function operation.
add EXIF enable control for jpeg encode.

Change-Id: I38bf86a372f69d42a4680c4d772b64a30e81d7be
Signed-off-by: Xia Jiang &lt;xia.jiang@xxxxxxxxxxxx&gt;
---
 drivers/media/platform/mtk-jpeg/Makefile      |   5 +-
 .../media/platform/mtk-jpeg/mtk_jpeg_core.c   | 740 ++++++++++++++----
 .../media/platform/mtk-jpeg/mtk_jpeg_core.h   | 114 ++-
 .../media/platform/mtk-jpeg/mtk_jpeg_dec_hw.h |   7 +-
 .../media/platform/mtk-jpeg/mtk_jpeg_enc_hw.c | 175 +++++
 .../media/platform/mtk-jpeg/mtk_jpeg_enc_hw.h |  60 ++
 .../platform/mtk-jpeg/mtk_jpeg_enc_reg.h      |  49 ++
 drivers/media/v4l2-core/v4l2-ctrls.c          |   1 +
 include/uapi/linux/v4l2-controls.h            |   2 +
 9 files changed, 986 insertions(+), 167 deletions(-)
 create mode 100644 drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_hw.c
 create mode 100644 drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_hw.h
 create mode 100644 drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_reg.h

diff --git a/drivers/media/platform/mtk-jpeg/Makefile b/drivers/media/platform/mtk-jpeg/Makefile
index 994fcd66069c..c2d7774e59fb 100644
--- a/drivers/media/platform/mtk-jpeg/Makefile
+++ b/drivers/media/platform/mtk-jpeg/Makefile
@@ -1,2 +1,5 @@
-mtk_jpeg-objs := mtk_jpeg_core.o mtk_jpeg_dec_hw.o mtk_jpeg_dec_parse.o
+mtk_jpeg-objs := mtk_jpeg_core.o \
+		 mtk_jpeg_dec_hw.o \
+		 mtk_jpeg_dec_parse.o \
+		 mtk_jpeg_enc_hw.o
 obj-$(CONFIG_VIDEO_MEDIATEK_JPEG) += mtk_jpeg.o
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
index 49e3b5284006..b2d6537e8c34 100644
--- a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
@@ -2,6 +2,7 @@
  * Copyright (c) 2016 MediaTek Inc.
  * Author: Ming Hsiu Tsai &lt;minghsiu.tsai@xxxxxxxxxxxx&gt;
  *         Rick Chang &lt;rick.chang@xxxxxxxxxxxx&gt;
+ *         Xia Jiang &lt;xia.jiang@xxxxxxxxxxxx&gt;
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -31,6 +32,7 @@
 #include &lt;media/videobuf2-dma-contig.h&gt;
 #include &lt;soc/mediatek/smi.h&gt;
 
+#include &quot;mtk_jpeg_enc_hw.h&quot;
 #include &quot;mtk_jpeg_dec_hw.h&quot;
 #include &quot;mtk_jpeg_core.h&quot;
 #include &quot;mtk_jpeg_dec_parse.h&quot;
@@ -39,7 +41,8 @@ static struct mtk_jpeg_fmt mtk_jpeg_formats[] = {
 	{
 		.fourcc		= V4L2_PIX_FMT_JPEG,
 		.colplanes	= 1,
-		.flags		= MTK_JPEG_FMT_FLAG_DEC_OUTPUT,
+		.flags		= MTK_JPEG_FMT_FLAG_DEC_OUTPUT |
+					MTK_JPEG_FMT_FLAG_ENC_CAPTURE,
 	},
 	{
 		.fourcc		= V4L2_PIX_FMT_YUV420M,
@@ -59,6 +62,42 @@ static struct mtk_jpeg_fmt mtk_jpeg_formats[] = {
 		.v_align	= 3,
 		.flags		= MTK_JPEG_FMT_FLAG_DEC_CAPTURE,
 	},
+	{
+		.fourcc		= V4L2_PIX_FMT_NV12M,
+		.h_sample	= {4, 2, 2},
+		.v_sample	= {4, 2, 2},
+		.colplanes	= 2,
+		.h_align	= 4,
+		.v_align	= 4,
+		.flags		= MTK_JPEG_FMT_FLAG_ENC_OUTPUT,
+	},
+	{
+		.fourcc		= V4L2_PIX_FMT_NV21M,
+		.h_sample	= {4, 2, 2},
+		.v_sample	= {4, 2, 2},
+		.colplanes	= 2,
+		.h_align	= 4,
+		.v_align	= 4,
+		.flags		= MTK_JPEG_FMT_FLAG_ENC_OUTPUT,
+	},
+	{
+		.fourcc		= V4L2_PIX_FMT_YUYV,
+		.h_sample	= {4, 2, 2},
+		.v_sample	= {4, 4, 4},
+		.colplanes	= 1,
+		.h_align	= 4,
+		.v_align	= 3,
+		.flags		= MTK_JPEG_FMT_FLAG_ENC_OUTPUT,
+	},
+	{
+		.fourcc		= V4L2_PIX_FMT_YVYU,
+		.h_sample	= {4, 2, 2},
+		.v_sample	= {4, 4, 4},
+		.colplanes	= 1,
+		.h_align	= 4,
+		.v_align	= 3,
+		.flags		= MTK_JPEG_FMT_FLAG_ENC_OUTPUT,
+	},
 };
 
 #define MTK_JPEG_NUM_FORMATS ARRAY_SIZE(mtk_jpeg_formats)
@@ -73,11 +112,19 @@ struct mtk_jpeg_src_buf {
 	struct list_head list;
 	int flags;
 	struct mtk_jpeg_dec_param dec_param;
+	struct mtk_jpeg_enc_param enc_param;
 };
 
+#define MTK_MAX_CTRLS_HINT	20
+
 static int debug;
 module_param(debug, int, 0644);
 
+static inline struct mtk_jpeg_ctx *ctrl_to_ctx(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl-&gt;handler, struct mtk_jpeg_ctx, ctrl_hdl);
+}
+
 static inline struct mtk_jpeg_ctx *mtk_jpeg_fh_to_ctx(struct v4l2_fh *fh)
 {
 	return container_of(fh, struct mtk_jpeg_ctx, fh);
@@ -94,10 +141,81 @@ static int mtk_jpeg_querycap(struct file *file, void *priv,
 {
 	struct mtk_jpeg_dev *jpeg = video_drvdata(file);
 
-	strscpy(cap-&gt;driver, MTK_JPEG_NAME &quot; decoder&quot;, sizeof(cap-&gt;driver));
-	strscpy(cap-&gt;card, MTK_JPEG_NAME &quot; decoder&quot;, sizeof(cap-&gt;card));
-	snprintf(cap-&gt;bus_info, sizeof(cap-&gt;bus_info), &quot;platform:%s&quot;,
-		 dev_name(jpeg-&gt;dev));
+	strscpy(cap-&gt;driver, MTK_JPEG_NAME, sizeof(cap-&gt;driver));
+	if (jpeg-&gt;mode ==  MTK_JPEG_ENC)
+		strscpy(cap-&gt;card, MTK_JPEG_NAME &quot; encoder&quot;, sizeof(cap-&gt;card));
+	else
+		strscpy(cap-&gt;card, MTK_JPEG_NAME &quot; decoder&quot;, sizeof(cap-&gt;card));
+		snprintf(cap-&gt;bus_info, sizeof(cap-&gt;bus_info), &quot;platform:%s&quot;,
+			 dev_name(jpeg-&gt;dev));
+
+	return 0;
+}
+
+static int vidioc_jpeg_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);
+	struct jpeg_enc_param *p = &amp;ctx-&gt;jpeg_param;
+	struct mtk_jpeg_dev *jpeg = ctx-&gt;jpeg;
+	int ret = 0;
+
+	switch (ctrl-&gt;id) {
+	case V4L2_CID_JPEG_RESTART_INTERVAL:
+		p-&gt;restart_interval = ctrl-&gt;val;
+		break;
+	case V4L2_CID_JPEG_COMPRESSION_QUALITY:
+		p-&gt;enc_quality = ctrl-&gt;val;
+		break;
+	case V4L2_CID_JPEG_ENABLE_EXIF:
+		p-&gt;enable_exif = ctrl-&gt;val;
+		break;
+	}
+
+	v4l2_dbg(2, debug, &amp;jpeg-&gt;v4l2_dev, &quot;%s val = %d&quot;,
+		 v4l2_ctrl_get_name(ctrl-&gt;id), ctrl-&gt;val);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops mtk_jpeg_ctrl_ops = {
+	.s_ctrl = vidioc_jpeg_s_ctrl,
+};
+
+int mtk_jpeg_ctrls_setup(struct mtk_jpeg_ctx *ctx)
+{
+	const struct v4l2_ctrl_ops *ops = &amp;mtk_jpeg_ctrl_ops;
+	struct v4l2_ctrl_handler *handler = &amp;ctx-&gt;ctrl_hdl;
+	struct mtk_jpeg_dev *jpeg = ctx-&gt;jpeg;
+
+	v4l2_ctrl_handler_init(handler, MTK_MAX_CTRLS_HINT);
+
+	if (jpeg-&gt;mode == MTK_JPEG_ENC) {
+		v4l2_ctrl_new_std(handler, ops, V4L2_CID_JPEG_RESTART_INTERVAL,
+				  0, 100, 1, 0);
+		if (handler-&gt;error) {
+			v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;V4L2_CID_JPEG_RESTART_INTERVAL Init&quot;,
+				 &quot;control handler fail %d\n&quot;, handler-&gt;error);
+			return handler-&gt;error;
+		}
+		v4l2_ctrl_new_std(handler, ops,
+				  V4L2_CID_JPEG_COMPRESSION_QUALITY, 48, 100, 1,
+				  90);
+		if (handler-&gt;error) {
+			v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;V4L2_CID_JPEG_COMPRESSION_QUALITY&quot;,
+				 &quot;Init control handler fail %d\n&quot;,
+				 handler-&gt;error);
+			return handler-&gt;error;
+		}
+		v4l2_ctrl_new_std(handler, ops, V4L2_CID_JPEG_ENABLE_EXIF, 0,
+				  1, 1, 0);
+		if (handler-&gt;error) {
+			v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;V4L2_CID_JPEG_ENABLE_EXIF Init&quot;,
+				 &quot;control handler fail %d\n&quot;, handler-&gt;error);
+			return handler-&gt;error;
+		}
+	}
+
+	v4l2_ctrl_handler_setup(&amp;ctx-&gt;ctrl_hdl);
 
 	return 0;
 }
@@ -126,23 +244,29 @@ static int mtk_jpeg_enum_fmt(struct mtk_jpeg_fmt *mtk_jpeg_formats, int n,
 static int mtk_jpeg_enum_fmt_vid_cap(struct file *file, void *priv,
 				     struct v4l2_fmtdesc *f)
 {
+	struct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);
+
 	return mtk_jpeg_enum_fmt(mtk_jpeg_formats, MTK_JPEG_NUM_FORMATS, f,
+				 ctx-&gt;jpeg-&gt;mode == MTK_JPEG_ENC ?
+				 MTK_JPEG_FMT_FLAG_ENC_CAPTURE :
 				 MTK_JPEG_FMT_FLAG_DEC_CAPTURE);
 }
 
 static int mtk_jpeg_enum_fmt_vid_out(struct file *file, void *priv,
 				     struct v4l2_fmtdesc *f)
 {
+	struct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);
+
 	return mtk_jpeg_enum_fmt(mtk_jpeg_formats, MTK_JPEG_NUM_FORMATS, f,
+				 ctx-&gt;jpeg-&gt;mode == MTK_JPEG_ENC ?
+				 MTK_JPEG_FMT_FLAG_ENC_OUTPUT :
 				 MTK_JPEG_FMT_FLAG_DEC_OUTPUT);
 }
 
-static struct mtk_jpeg_q_data *mtk_jpeg_get_q_data(struct mtk_jpeg_ctx *ctx,
-						   enum v4l2_buf_type type)
+static struct mtk_jpeg_q_data *
+mtk_jpeg_get_q_data(struct mtk_jpeg_ctx *ctx, enum v4l2_buf_type type)
 {
-	if (V4L2_TYPE_IS_OUTPUT(type))
-		return &amp;ctx-&gt;out_q;
-	return &amp;ctx-&gt;cap_q;
+	return V4L2_TYPE_IS_OUTPUT(type) ? &amp;ctx-&gt;out_q : &amp;ctx-&gt;cap_q;
 }
 
 static struct mtk_jpeg_fmt *mtk_jpeg_find_format(struct mtk_jpeg_ctx *ctx,
@@ -151,9 +275,14 @@ static struct mtk_jpeg_fmt *mtk_jpeg_find_format(struct mtk_jpeg_ctx *ctx,
 {
 	unsigned int k, fmt_flag;
 
-	fmt_flag = (fmt_type == MTK_JPEG_FMT_TYPE_OUTPUT) ?
-		   MTK_JPEG_FMT_FLAG_DEC_OUTPUT :
-		   MTK_JPEG_FMT_FLAG_DEC_CAPTURE;
+	if (ctx-&gt;jpeg-&gt;mode ==  MTK_JPEG_ENC)
+		fmt_flag = (fmt_type == MTK_JPEG_FMT_TYPE_OUTPUT) ?
+			   MTK_JPEG_FMT_FLAG_ENC_OUTPUT :
+			   MTK_JPEG_FMT_FLAG_ENC_CAPTURE;
+	else
+		fmt_flag = (fmt_type == MTK_JPEG_FMT_TYPE_OUTPUT) ?
+			   MTK_JPEG_FMT_FLAG_DEC_OUTPUT :
+			   MTK_JPEG_FMT_FLAG_DEC_CAPTURE;
 
 	for (k = 0; k &lt; MTK_JPEG_NUM_FORMATS; k++) {
 		struct mtk_jpeg_fmt *fmt = &amp;mtk_jpeg_formats[k];
@@ -210,7 +339,7 @@ static int mtk_jpeg_try_fmt_mplane(struct v4l2_format *f,
 {
 	struct v4l2_pix_format_mplane *pix_mp = &amp;f-&gt;fmt.pix_mp;
 	struct mtk_jpeg_dev *jpeg = ctx-&gt;jpeg;
-	int i;
+	int i, align_w, align_h;
 
 	memset(pix_mp-&gt;reserved, 0, sizeof(pix_mp-&gt;reserved));
 	pix_mp-&gt;field = V4L2_FIELD_NONE;
@@ -224,36 +353,111 @@ static int mtk_jpeg_try_fmt_mplane(struct v4l2_format *f,
 	pix_mp-&gt;pixelformat = fmt-&gt;fourcc;
 
 	if (q_type == MTK_JPEG_FMT_TYPE_OUTPUT) {
-		struct v4l2_plane_pix_format *pfmt = &amp;pix_mp-&gt;plane_fmt[0];
-
-		mtk_jpeg_bound_align_image(&amp;pix_mp-&gt;width, MTK_JPEG_MIN_WIDTH,
-					   MTK_JPEG_MAX_WIDTH, 0,
-					   &amp;pix_mp-&gt;height, MTK_JPEG_MIN_HEIGHT,
-					   MTK_JPEG_MAX_HEIGHT, 0);
+		if (jpeg-&gt;mode == MTK_JPEG_ENC) {
+			pix_mp-&gt;height = clamp(pix_mp-&gt;height,
+					       MTK_JPEG_MIN_HEIGHT,
+					       MTK_JPEG_MAX_HEIGHT);
+			pix_mp-&gt;width = clamp(pix_mp-&gt;width,
+					      MTK_JPEG_MIN_WIDTH,
+					      MTK_JPEG_MAX_WIDTH);
+			align_w = pix_mp-&gt;width;
+			align_h = pix_mp-&gt;height;
+			align_w = round_up(align_w, 2);
+			if (pix_mp-&gt;num_planes == 1U) {
+				align_w = align_w &lt;&lt; 1;
+				mtk_jpeg_bound_align_image(&amp;align_w,
+							   MTK_JPEG_MIN_WIDTH,
+							   MTK_JPEG_MAX_WIDTH,
+							   5, &amp;align_h,
+							   MTK_JPEG_MIN_HEIGHT,
+							   MTK_JPEG_MAX_HEIGHT,
+							   3);
+				pix_mp-&gt;plane_fmt[0].bytesperline = align_w;
+				pix_mp-&gt;plane_fmt[0].sizeimage =
+					align_w * align_h;
+			} else if (pix_mp-&gt;num_planes == 2U) {
+				mtk_jpeg_bound_align_image(&amp;align_w,
+							   MTK_JPEG_MIN_WIDTH,
+							   MTK_JPEG_MAX_WIDTH,
+							   4, &amp;align_h,
+							   MTK_JPEG_MIN_HEIGHT,
+							   MTK_JPEG_MAX_HEIGHT,
+							   4);
+				pix_mp-&gt;plane_fmt[0].bytesperline = align_w;
+				pix_mp-&gt;plane_fmt[0].sizeimage =
+					align_w * align_h;
+				pix_mp-&gt;plane_fmt[1].bytesperline = align_w;
+				pix_mp-&gt;plane_fmt[1].sizeimage =
+					(align_w * align_h) / 2;
+			} else {
+				v4l2_err(&amp;ctx-&gt;jpeg-&gt;v4l2_dev,
+					 &quot;Unsupport num planes = %d\n&quot;,
+					 pix_mp-&gt;num_planes);
+			}
+			goto end;
+		} else {
+			struct v4l2_plane_pix_format *pfmt =
+						&amp;pix_mp-&gt;plane_fmt[0];
+
+			mtk_jpeg_bound_align_image(&amp;pix_mp-&gt;width,
+						   MTK_JPEG_MIN_WIDTH,
+						   MTK_JPEG_MAX_WIDTH, 0,
+						   &amp;pix_mp-&gt;height,
+						   MTK_JPEG_MIN_HEIGHT,
+						   MTK_JPEG_MAX_HEIGHT, 0);
 
-		memset(pfmt-&gt;reserved, 0, sizeof(pfmt-&gt;reserved));
 		pfmt-&gt;bytesperline = 0;
 		/* Source size must be aligned to 128 */
 		pfmt-&gt;sizeimage = mtk_jpeg_align(pfmt-&gt;sizeimage, 128);
 		if (pfmt-&gt;sizeimage == 0)
 			pfmt-&gt;sizeimage = MTK_JPEG_DEFAULT_SIZEIMAGE;
+
 		goto end;
 	}
+	}
 
 	/* type is MTK_JPEG_FMT_TYPE_CAPTURE */
-	mtk_jpeg_bound_align_image(&amp;pix_mp-&gt;width, MTK_JPEG_MIN_WIDTH,
-				   MTK_JPEG_MAX_WIDTH, fmt-&gt;h_align,
-				   &amp;pix_mp-&gt;height, MTK_JPEG_MIN_HEIGHT,
-				   MTK_JPEG_MAX_HEIGHT, fmt-&gt;v_align);
+	if (jpeg-&gt;mode == MTK_JPEG_ENC) {
+		mtk_jpeg_bound_align_image(&amp;pix_mp-&gt;width, MTK_JPEG_MIN_WIDTH,
+					   MTK_JPEG_MAX_WIDTH, 0,
+					   &amp;pix_mp-&gt;height, MTK_JPEG_MIN_HEIGHT,
+					   MTK_JPEG_MAX_HEIGHT, 0);
 
-	for (i = 0; i &lt; fmt-&gt;colplanes; i++) {
-		struct v4l2_plane_pix_format *pfmt = &amp;pix_mp-&gt;plane_fmt[i];
-		u32 stride = pix_mp-&gt;width * fmt-&gt;h_sample[i] / 4;
-		u32 h = pix_mp-&gt;height * fmt-&gt;v_sample[i] / 4;
+		if (fmt-&gt;fourcc == V4L2_PIX_FMT_JPEG) {
+			pix_mp-&gt;plane_fmt[0].bytesperline = 0;
+			pix_mp-&gt;plane_fmt[0].sizeimage =
+				mtk_jpeg_align(pix_mp-&gt;plane_fmt[0].sizeimage,
+					       128);
+			if (pix_mp-&gt;plane_fmt[0].sizeimage == 0)
+				pix_mp-&gt;plane_fmt[0].sizeimage =
+					MTK_JPEG_DEFAULT_SIZEIMAGE;
+		}
+	} else {
+		pix_mp-&gt;height = clamp(pix_mp-&gt;height, MTK_JPEG_MIN_HEIGHT,
+				       MTK_JPEG_MAX_HEIGHT);
+		pix_mp-&gt;width = clamp(pix_mp-&gt;width, MTK_JPEG_MIN_WIDTH,
+				      MTK_JPEG_MAX_WIDTH);
+		mtk_jpeg_bound_align_image(&amp;pix_mp-&gt;width, MTK_JPEG_MIN_WIDTH,
+					   MTK_JPEG_MAX_WIDTH, fmt-&gt;h_align,
+					   &amp;pix_mp-&gt;height,
+					   MTK_JPEG_MIN_HEIGHT,
+					   MTK_JPEG_MAX_HEIGHT, fmt-&gt;v_align);
+
+		for (i = 0; i &lt; fmt-&gt;colplanes; i++) {
+			struct v4l2_plane_pix_format *pfmt =
+					&amp;pix_mp-&gt;plane_fmt[i];
+			u32 stride = pix_mp-&gt;width * fmt-&gt;h_sample[i] / 4;
+			u32 h = pix_mp-&gt;height * fmt-&gt;v_sample[i] / 4;
+
+			pfmt-&gt;bytesperline = stride;
+			pfmt-&gt;sizeimage = stride * h;
+		}
+	}
 
+	for (i = 0; i &lt; fmt-&gt;colplanes; i++) {
+		struct v4l2_plane_pix_format *pfmt =
+				&amp;pix_mp-&gt;plane_fmt[i];
 		memset(pfmt-&gt;reserved, 0, sizeof(pfmt-&gt;reserved));
-		pfmt-&gt;bytesperline = stride;
-		pfmt-&gt;sizeimage = stride * h;
 	}
 end:
 	v4l2_dbg(2, debug, &amp;jpeg-&gt;v4l2_dev, &quot;wxh:%ux%u\n&quot;,
@@ -454,9 +658,9 @@ static int mtk_jpeg_subscribe_event(struct v4l2_fh *fh,
 	switch (sub-&gt;type) {
 	case V4L2_EVENT_SOURCE_CHANGE:
 		return v4l2_src_change_event_subscribe(fh, sub);
-	default:
-		return -EINVAL;
 	}
+
+	return v4l2_ctrl_subscribe_event(fh, sub);
 }
 
 static int mtk_jpeg_g_selection(struct file *file, void *priv,
@@ -579,6 +783,13 @@ static int mtk_jpeg_queue_setup(struct vb2_queue *q,
 	if (!q_data)
 		return -EINVAL;
 
+	if (*num_planes) {
+		for (i = 0; i &lt; *num_planes; i++)
+			if (sizes[i] &lt; q_data-&gt;sizeimage[i])
+				return -EINVAL;
+		return 0;
+	}
+
 	*num_planes = q_data-&gt;fmt-&gt;colplanes;
 	for (i = 0; i &lt; q_data-&gt;fmt-&gt;colplanes; i++) {
 		sizes[i] = q_data-&gt;sizeimage[i];
@@ -659,10 +870,92 @@ static void mtk_jpeg_set_queue_data(struct mtk_jpeg_ctx *ctx,
 		 param-&gt;dec_w, param-&gt;dec_h);
 }
 
+static void mtk_jpeg_set_param(struct mtk_jpeg_ctx *ctx,
+			       struct mtk_jpeg_enc_param *param)
+{
+	struct mtk_jpeg_q_data *q_data_src = &amp;ctx-&gt;out_q;
+	struct jpeg_enc_param *jpeg_params = &amp;ctx-&gt;jpeg_param;
+	struct mtk_jpeg_dev *jpeg = ctx-&gt;jpeg;
+	u32 width_even;
+	u32 is_420;
+	u32 padding_width;
+	u32 padding_height;
+
+	switch (q_data_src-&gt;fmt-&gt;fourcc) {
+	case V4L2_PIX_FMT_YUYV:
+		param-&gt;enc_format = JPEG_YUV_FORMAT_YUYV;
+		break;
+	case V4L2_PIX_FMT_YVYU:
+		param-&gt;enc_format = JPEG_YUV_FORMAT_YVYU;
+		break;
+	case V4L2_PIX_FMT_NV12M:
+		param-&gt;enc_format = JPEG_YUV_FORMAT_NV12;
+		break;
+	case V4L2_PIX_FMT_NV21M:
+		param-&gt;enc_format = JPEG_YUV_FORMAT_NV12;
+		break;
+	default:
+		v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;Unsupport fourcc =%d\n&quot;,
+			 q_data_src-&gt;fmt-&gt;fourcc);
+		break;
+	}
+	param-&gt;enc_w = q_data_src-&gt;w;
+	param-&gt;enc_h = q_data_src-&gt;h;
+
+	if (jpeg_params-&gt;enc_quality &gt;= 97)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q97;
+	else if (jpeg_params-&gt;enc_quality &gt;= 95)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q95;
+	else if (jpeg_params-&gt;enc_quality &gt;= 92)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q92;
+	else if (jpeg_params-&gt;enc_quality &gt;= 90)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q90;
+	else if (jpeg_params-&gt;enc_quality &gt;= 87)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q87;
+	else if (jpeg_params-&gt;enc_quality &gt;= 84)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q84;
+	else if (jpeg_params-&gt;enc_quality &gt;= 80)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q80;
+	else if (jpeg_params-&gt;enc_quality &gt;= 74)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q74;
+	else if (jpeg_params-&gt;enc_quality &gt;= 64)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q64;
+	else if (jpeg_params-&gt;enc_quality &gt;= 60)
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q60;
+	else
+		param-&gt;enc_quality = JPEG_ENCODE_QUALITY_Q48;
+
+	param-&gt;enable_exif = jpeg_params-&gt;enable_exif;
+	param-&gt;restart_interval = jpeg_params-&gt;restart_interval;
+
+	width_even = ((param-&gt;enc_w + 1) &gt;&gt; 1) &lt;&lt; 1;
+	is_420 = (param-&gt;enc_format == JPEG_YUV_FORMAT_NV12 ||
+		  param-&gt;enc_format == JPEG_YUV_FORMAT_NV12) ? 1 : 0;
+	padding_width = mtk_jpeg_align(param-&gt;enc_w, 16);
+	padding_height = mtk_jpeg_align(param-&gt;enc_h, is_420 ? 16 : 8);
+	if (!is_420)
+		width_even = width_even &lt;&lt; 1;
+
+	param-&gt;img_stride = mtk_jpeg_align(width_even, (is_420 ? 16 : 32));
+	param-&gt;mem_stride = mtk_jpeg_align(width_even, (is_420 ? 16 : 32));
+	param-&gt;total_encdu =
+		((padding_width &gt;&gt; 4) * (padding_height &gt;&gt; (is_420 ? 4 : 3)) *
+		(is_420 ? 6 : 4)) - 1;
+
+	v4l2_dbg(0, 2, &amp;jpeg-&gt;v4l2_dev, &quot;fmt %d, w,h %d,%d, enable_exif %d,&quot;,
+		 &quot;enc_quality %d, restart_interval %d,img_stride %d,&quot;,
+		 &quot;mem_stride %d,totalEncDu %d\n&quot;,
+		 param-&gt;enc_format, param-&gt;enc_w, param-&gt;enc_h,
+		 param-&gt;enable_exif, param-&gt;enc_quality,
+		 param-&gt;restart_interval, param-&gt;img_stride,
+		 param-&gt;mem_stride, param-&gt;total_encdu);
+}
+
 static void mtk_jpeg_buf_queue(struct vb2_buffer *vb)
 {
 	struct mtk_jpeg_ctx *ctx = vb2_get_drv_priv(vb-&gt;vb2_queue);
 	struct mtk_jpeg_dec_param *param;
+	struct mtk_jpeg_enc_param *enc_param;
 	struct mtk_jpeg_dev *jpeg = ctx-&gt;jpeg;
 	struct mtk_jpeg_src_buf *jpeg_src_buf;
 	bool header_valid;
@@ -674,29 +967,45 @@ static void mtk_jpeg_buf_queue(struct vb2_buffer *vb)
 		goto end;
 
 	jpeg_src_buf = mtk_jpeg_vb2_to_srcbuf(vb);
-	param = &amp;jpeg_src_buf-&gt;dec_param;
-	memset(param, 0, sizeof(*param));
-
-	if (jpeg_src_buf-&gt;flags &amp; MTK_JPEG_BUF_FLAGS_LAST_FRAME) {
-		v4l2_dbg(1, debug, &amp;jpeg-&gt;v4l2_dev, &quot;Got eos\n&quot;);
-		goto end;
-	}
-	header_valid = mtk_jpeg_parse(param, (u8 *)vb2_plane_vaddr(vb, 0),
-				      vb2_get_plane_payload(vb, 0));
-	if (!header_valid) {
-		v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;Header invalid.\n&quot;);
-		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
-		return;
-	}
-
-	if (ctx-&gt;state == MTK_JPEG_INIT) {
-		struct vb2_queue *dst_vq = v4l2_m2m_get_vq(
-			ctx-&gt;fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	if (jpeg-&gt;mode ==  MTK_JPEG_ENC) {
+		enc_param = &amp;jpeg_src_buf-&gt;enc_param;
+		memset(enc_param, 0, sizeof(*enc_param));
+		mtk_jpeg_set_param(ctx, enc_param);
+		if (jpeg_src_buf-&gt;flags &amp; MTK_JPEG_BUF_FLAGS_LAST_FRAME) {
+			v4l2_dbg(1, debug, &amp;jpeg-&gt;v4l2_dev, &quot;Got eos&quot;);
+			goto end;
+		}
+		if (ctx-&gt;state == MTK_JPEG_INIT)
+			ctx-&gt;state = MTK_JPEG_RUNNING;
+	} else {
+		param = &amp;jpeg_src_buf-&gt;dec_param;
+		memset(param, 0, sizeof(*param));
+
+		if (jpeg_src_buf-&gt;flags &amp; MTK_JPEG_BUF_FLAGS_LAST_FRAME) {
+			v4l2_dbg(1, debug, &amp;jpeg-&gt;v4l2_dev, &quot;Got eos\n&quot;);
+			goto end;
+		}
+		header_valid = mtk_jpeg_parse(param,
+					      (u8 *)vb2_plane_vaddr(vb, 0),
+					      vb2_get_plane_payload(vb, 0));
+		if (!header_valid) {
+			v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;Header invalid.\n&quot;);
+			vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+			return;
+		}
 
-		mtk_jpeg_queue_src_chg_event(ctx);
-		mtk_jpeg_set_queue_data(ctx, param);
-		ctx-&gt;state = vb2_is_streaming(dst_vq) ?
-				MTK_JPEG_SOURCE_CHANGE : MTK_JPEG_RUNNING;
+		if (ctx-&gt;state == MTK_JPEG_INIT) {
+			struct vb2_queue *dst_vq;
+
+			dst_vq = v4l2_m2m_get_vq
+					(ctx-&gt;fh.m2m_ctx,
+					 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+			mtk_jpeg_queue_src_chg_event(ctx);
+			mtk_jpeg_set_queue_data(ctx, param);
+			ctx-&gt;state = vb2_is_streaming(dst_vq) ?
+					MTK_JPEG_SOURCE_CHANGE :
+					MTK_JPEG_RUNNING;
+		}
 	}
 end:
 	v4l2_m2m_buf_queue(ctx-&gt;fh.m2m_ctx, to_vb2_v4l2_buffer(vb));
@@ -739,16 +1048,16 @@ static void mtk_jpeg_stop_streaming(struct vb2_queue *q)
 	 * subsampling. Update capture queue when the stream is off.
 	 */
 	if (ctx-&gt;state == MTK_JPEG_SOURCE_CHANGE &amp;&amp;
-	    !V4L2_TYPE_IS_OUTPUT(q-&gt;type)) {
+	    !V4L2_TYPE_IS_OUTPUT(q-&gt;type) &amp;&amp;
+	    ctx-&gt;jpeg-&gt;mode == MTK_JPEG_DEC) {
 		struct mtk_jpeg_src_buf *src_buf;
 
 		vb = v4l2_m2m_next_src_buf(ctx-&gt;fh.m2m_ctx);
 		src_buf = mtk_jpeg_vb2_to_srcbuf(&amp;vb-&gt;vb2_buf);
 		mtk_jpeg_set_queue_data(ctx, &amp;src_buf-&gt;dec_param);
 		ctx-&gt;state = MTK_JPEG_RUNNING;
-	} else if (V4L2_TYPE_IS_OUTPUT(q-&gt;type)) {
+	} else if (V4L2_TYPE_IS_OUTPUT(q-&gt;type))
 		ctx-&gt;state = MTK_JPEG_INIT;
-	}
 
 	while ((vb = mtk_jpeg_buf_remove(ctx, q-&gt;type)))
 		v4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);
@@ -803,6 +1112,28 @@ static int mtk_jpeg_set_dec_dst(struct mtk_jpeg_ctx *ctx,
 	return 0;
 }
 
+static void mtk_jpeg_set_enc_dst(struct mtk_jpeg_ctx *ctx,
+				 struct vb2_buffer *dst_buf,
+				 struct mtk_jpeg_enc_bs *bs)
+{
+	bs-&gt;dma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0) &amp;
+		      (~JPEG_ENC_DST_ADDR_OFFSET_MASK);
+	bs-&gt;dma_addr_offset = 0;
+	bs-&gt;dma_addr_offsetmask = bs-&gt;dma_addr &amp; JPEG_ENC_DST_ADDR_OFFSET_MASK;
+	bs-&gt;size = mtk_jpeg_align(vb2_plane_size(dst_buf, 0), 128);
+}
+
+static void mtk_jpeg_set_enc_src(struct mtk_jpeg_ctx *ctx,
+				 struct vb2_buffer *src_buf,
+				 struct mtk_jpeg_enc_fb *fb)
+{
+	int i;
+
+	for (i = 0; i &lt; src_buf-&gt;num_planes; i++)
+		fb-&gt;fb_addr[i].dma_addr =
+			vb2_dma_contig_plane_dma_addr(src_buf, i);
+}
+
 static void mtk_jpeg_device_run(void *priv)
 {
 	struct mtk_jpeg_ctx *ctx = priv;
@@ -813,6 +1144,8 @@ static void mtk_jpeg_device_run(void *priv)
 	struct mtk_jpeg_src_buf *jpeg_src_buf;
 	struct mtk_jpeg_bs bs;
 	struct mtk_jpeg_fb fb;
+	struct mtk_jpeg_enc_bs enc_bs;
+	struct mtk_jpeg_enc_fb enc_fb;
 	int i;
 
 	src_buf = v4l2_m2m_next_src_buf(ctx-&gt;fh.m2m_ctx);
@@ -823,30 +1156,45 @@ static void mtk_jpeg_device_run(void *priv)
 		for (i = 0; i &lt; dst_buf-&gt;vb2_buf.num_planes; i++)
 			vb2_set_plane_payload(&amp;dst_buf-&gt;vb2_buf, i, 0);
 		buf_state = VB2_BUF_STATE_DONE;
-		goto dec_end;
+		goto device_run_end;
 	}
 
-	if (mtk_jpeg_check_resolution_change(ctx, &amp;jpeg_src_buf-&gt;dec_param)) {
-		mtk_jpeg_queue_src_chg_event(ctx);
-		ctx-&gt;state = MTK_JPEG_SOURCE_CHANGE;
-		v4l2_m2m_job_finish(jpeg-&gt;m2m_dev, ctx-&gt;fh.m2m_ctx);
-		return;
-	}
+	if (jpeg-&gt;mode == MTK_JPEG_ENC) {
+		mtk_jpeg_set_enc_dst(ctx, &amp;dst_buf-&gt;vb2_buf, &amp;enc_bs);
+		mtk_jpeg_set_enc_src(ctx, &amp;src_buf-&gt;vb2_buf, &amp;enc_fb);
+
+		spin_lock_irqsave(&amp;jpeg-&gt;hw_lock, flags);
+		mtk_jpeg_enc_reset(jpeg-&gt;reg_base);
+		mtk_jpeg_enc_set_config(jpeg-&gt;reg_base,
+					&amp;jpeg_src_buf-&gt;enc_param, &amp;enc_bs,
+					&amp;enc_fb);
+
+		mtk_jpeg_enc_start(jpeg-&gt;reg_base);
+	} else {
+		if (mtk_jpeg_check_resolution_change
+			(ctx, &amp;jpeg_src_buf-&gt;dec_param)) {
+			mtk_jpeg_queue_src_chg_event(ctx);
+			ctx-&gt;state = MTK_JPEG_SOURCE_CHANGE;
+			v4l2_m2m_job_finish(jpeg-&gt;m2m_dev, ctx-&gt;fh.m2m_ctx);
+			return;
+		}
 
-	mtk_jpeg_set_dec_src(ctx, &amp;src_buf-&gt;vb2_buf, &amp;bs);
-	if (mtk_jpeg_set_dec_dst(ctx, &amp;jpeg_src_buf-&gt;dec_param, &amp;dst_buf-&gt;vb2_buf, &amp;fb))
-		goto dec_end;
+		mtk_jpeg_set_dec_src(ctx, &amp;src_buf-&gt;vb2_buf, &amp;bs);
+		if (mtk_jpeg_set_dec_dst(ctx, &amp;jpeg_src_buf-&gt;dec_param,
+					 &amp;dst_buf-&gt;vb2_buf, &amp;fb))
+			goto device_run_end;
 
-	spin_lock_irqsave(&amp;jpeg-&gt;hw_lock, flags);
-	mtk_jpeg_dec_reset(jpeg-&gt;dec_reg_base);
-	mtk_jpeg_dec_set_config(jpeg-&gt;dec_reg_base,
-				&amp;jpeg_src_buf-&gt;dec_param, &amp;bs, &amp;fb);
+		spin_lock_irqsave(&amp;jpeg-&gt;hw_lock, flags);
+		mtk_jpeg_dec_reset(jpeg-&gt;reg_base);
+		mtk_jpeg_dec_set_config(jpeg-&gt;reg_base,
+					&amp;jpeg_src_buf-&gt;dec_param, &amp;bs, &amp;fb);
 
-	mtk_jpeg_dec_start(jpeg-&gt;dec_reg_base);
+		mtk_jpeg_dec_start(jpeg-&gt;reg_base);
+	}
 	spin_unlock_irqrestore(&amp;jpeg-&gt;hw_lock, flags);
 	return;
 
-dec_end:
+device_run_end:
 	v4l2_m2m_src_buf_remove(ctx-&gt;fh.m2m_ctx);
 	v4l2_m2m_dst_buf_remove(ctx-&gt;fh.m2m_ctx);
 	v4l2_m2m_buf_done(src_buf, buf_state);
@@ -906,30 +1254,30 @@ static void mtk_jpeg_clk_on(struct mtk_jpeg_dev *jpeg)
 	ret = mtk_smi_larb_get(jpeg-&gt;larb);
 	if (ret)
 		dev_err(jpeg-&gt;dev, &quot;mtk_smi_larb_get larbvdec fail %d\n&quot;, ret);
-	clk_prepare_enable(jpeg-&gt;clk_jdec_smi);
-	clk_prepare_enable(jpeg-&gt;clk_jdec);
+	if (jpeg-&gt;mode == MTK_JPEG_DEC)
+		clk_prepare_enable(jpeg-&gt;clk_jpeg_smi);
+	clk_prepare_enable(jpeg-&gt;clk_jpeg);
 }
 
 static void mtk_jpeg_clk_off(struct mtk_jpeg_dev *jpeg)
 {
-	clk_disable_unprepare(jpeg-&gt;clk_jdec);
-	clk_disable_unprepare(jpeg-&gt;clk_jdec_smi);
+	clk_disable_unprepare(jpeg-&gt;clk_jpeg);
+	if (jpeg-&gt;mode == MTK_JPEG_DEC)
+		clk_disable_unprepare(jpeg-&gt;clk_jpeg_smi);
 	mtk_smi_larb_put(jpeg-&gt;larb);
 }
 
-static irqreturn_t mtk_jpeg_dec_irq(int irq, void *priv)
+static irqreturn_t mtk_jpeg_irq(int irq, void *priv)
 {
 	struct mtk_jpeg_dev *jpeg = priv;
 	struct mtk_jpeg_ctx *ctx;
 	struct vb2_v4l2_buffer *src_buf, *dst_buf;
 	struct mtk_jpeg_src_buf *jpeg_src_buf;
 	enum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;
-	u32	dec_irq_ret;
-	u32 dec_ret;
+	u32	irq_ret;
+	u32 ret, result_size;
 	int i;
 
-	dec_ret = mtk_jpeg_dec_get_int_status(jpeg-&gt;dec_reg_base);
-	dec_irq_ret = mtk_jpeg_dec_enum_result(dec_ret);
 	ctx = v4l2_m2m_get_curr_priv(jpeg-&gt;m2m_dev);
 	if (!ctx) {
 		v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;Context is NULL\n&quot;);
@@ -940,21 +1288,42 @@ static irqreturn_t mtk_jpeg_dec_irq(int irq, void *priv)
 	dst_buf = v4l2_m2m_dst_buf_remove(ctx-&gt;fh.m2m_ctx);
 	jpeg_src_buf = mtk_jpeg_vb2_to_srcbuf(&amp;src_buf-&gt;vb2_buf);
 
-	if (dec_irq_ret &gt;= MTK_JPEG_DEC_RESULT_UNDERFLOW)
-		mtk_jpeg_dec_reset(jpeg-&gt;dec_reg_base);
+	if (jpeg-&gt;mode == MTK_JPEG_ENC) {
+		ret = mtk_jpeg_enc_get_int_status(jpeg-&gt;reg_base);
+		irq_ret = mtk_jpeg_enc_enum_result(jpeg-&gt;reg_base, ret,
+						   &amp;result_size);
 
-	if (dec_irq_ret != MTK_JPEG_DEC_RESULT_EOF_DONE) {
-		dev_err(jpeg-&gt;dev, &quot;decode failed\n&quot;);
-		goto dec_end;
-	}
+		if (irq_ret &gt;= MTK_JPEG_ENC_RESULT_STALL)
+			mtk_jpeg_enc_reset(jpeg-&gt;reg_base);
+
+		if (irq_ret != MTK_JPEG_ENC_RESULT_DONE) {
+			dev_err(jpeg-&gt;dev, &quot;encode failed\n&quot;);
+			goto irq_end;
+		}
+
+		vb2_set_plane_payload(&amp;dst_buf-&gt;vb2_buf, 0,
+				      result_size);
+	} else {
+		ret = mtk_jpeg_dec_get_int_status(jpeg-&gt;reg_base);
+		irq_ret = mtk_jpeg_dec_enum_result(ret);
 
-	for (i = 0; i &lt; dst_buf-&gt;vb2_buf.num_planes; i++)
-		vb2_set_plane_payload(&amp;dst_buf-&gt;vb2_buf, i,
-				      jpeg_src_buf-&gt;dec_param.comp_size[i]);
+		if (irq_ret &gt;= MTK_JPEG_DEC_RESULT_UNDERFLOW)
+			mtk_jpeg_dec_reset(jpeg-&gt;reg_base);
+
+		if (irq_ret != MTK_JPEG_DEC_RESULT_EOF_DONE) {
+			dev_err(jpeg-&gt;dev, &quot;decode failed\n&quot;);
+			goto irq_end;
+		}
+
+		for (i = 0; i &lt; dst_buf-&gt;vb2_buf.num_planes; i++)
+			vb2_set_plane_payload
+				(&amp;dst_buf-&gt;vb2_buf, i,
+				 jpeg_src_buf-&gt;dec_param.comp_size[i]);
+		}
 
 	buf_state = VB2_BUF_STATE_DONE;
 
-dec_end:
+irq_end:
 	v4l2_m2m_buf_done(src_buf, buf_state);
 	v4l2_m2m_buf_done(dst_buf, buf_state);
 	v4l2_m2m_job_finish(jpeg-&gt;m2m_dev, ctx-&gt;fh.m2m_ctx);
@@ -964,32 +1333,72 @@ static irqreturn_t mtk_jpeg_dec_irq(int irq, void *priv)
 static void mtk_jpeg_set_default_params(struct mtk_jpeg_ctx *ctx)
 {
 	struct mtk_jpeg_q_data *q = &amp;ctx-&gt;out_q;
-	int i;
+	int i, align_w, align_h;
+
+	ctx-&gt;fh.ctrl_handler = &amp;ctx-&gt;ctrl_hdl;
 
 	ctx-&gt;colorspace = V4L2_COLORSPACE_JPEG,
 	ctx-&gt;ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
 	ctx-&gt;quantization = V4L2_QUANTIZATION_DEFAULT;
 	ctx-&gt;xfer_func = V4L2_XFER_FUNC_DEFAULT;
 
-	q-&gt;fmt = mtk_jpeg_find_format(ctx, V4L2_PIX_FMT_JPEG,
+	if (ctx-&gt;jpeg-&gt;mode == MTK_JPEG_ENC) {
+		q-&gt;w = MTK_JPEG_MIN_WIDTH;
+		q-&gt;h = MTK_JPEG_MIN_HEIGHT;
+
+		q-&gt;fmt = mtk_jpeg_find_format(ctx, V4L2_PIX_FMT_YUYV,
+					      MTK_JPEG_FMT_TYPE_OUTPUT);
+
+		align_w = q-&gt;w;
+		align_h = q-&gt;h;
+		align_w = round_up(align_w, 2);
+		align_w = align_w &lt;&lt; 1;
+		v4l_bound_align_image(&amp;align_w,
+				      MTK_JPEG_MIN_WIDTH,
+				      MTK_JPEG_MAX_WIDTH, 5,
+				      &amp;align_h,
+				      MTK_JPEG_MIN_HEIGHT,
+				      MTK_JPEG_MAX_HEIGHT, 3, 0);
+
+		if (align_w &lt; MTK_JPEG_MIN_WIDTH &amp;&amp;
+		    (align_w + 32) &lt;= MTK_JPEG_MAX_WIDTH)
+			align_w += 32;
+		if (align_h &lt; MTK_JPEG_MIN_HEIGHT &amp;&amp;
+		    (align_h + 8) &lt;= MTK_JPEG_MAX_HEIGHT)
+			align_h += 8;
+
+		q-&gt;sizeimage[0] = align_w * align_h;
+		q-&gt;bytesperline[0] = align_w;
+	} else {
+		q-&gt;fmt = mtk_jpeg_find_format(ctx, V4L2_PIX_FMT_JPEG,
 					      MTK_JPEG_FMT_TYPE_OUTPUT);
-	q-&gt;w = MTK_JPEG_MIN_WIDTH;
-	q-&gt;h = MTK_JPEG_MIN_HEIGHT;
-	q-&gt;bytesperline[0] = 0;
-	q-&gt;sizeimage[0] = MTK_JPEG_DEFAULT_SIZEIMAGE;
+		q-&gt;w = MTK_JPEG_MIN_WIDTH;
+		q-&gt;h = MTK_JPEG_MIN_HEIGHT;
+		q-&gt;bytesperline[0] = 0;
+		q-&gt;sizeimage[0] = MTK_JPEG_DEFAULT_SIZEIMAGE;
+	}
 
 	q = &amp;ctx-&gt;cap_q;
-	q-&gt;fmt = mtk_jpeg_find_format(ctx, V4L2_PIX_FMT_YUV420M,
+	if (ctx-&gt;jpeg-&gt;mode == MTK_JPEG_ENC) {
+		q-&gt;w = MTK_JPEG_MIN_WIDTH;
+		q-&gt;h = MTK_JPEG_MIN_HEIGHT;
+		q-&gt;fmt = mtk_jpeg_find_format(ctx, V4L2_PIX_FMT_JPEG,
+					      MTK_JPEG_FMT_TYPE_CAPTURE);
+		q-&gt;bytesperline[0] = 0;
+		q-&gt;sizeimage[0] = MTK_JPEG_DEFAULT_SIZEIMAGE;
+	} else {
+		q-&gt;fmt = mtk_jpeg_find_format(ctx, V4L2_PIX_FMT_YUV420M,
 					      MTK_JPEG_FMT_TYPE_CAPTURE);
-	q-&gt;w = MTK_JPEG_MIN_WIDTH;
-	q-&gt;h = MTK_JPEG_MIN_HEIGHT;
+		q-&gt;w = MTK_JPEG_MIN_WIDTH;
+		q-&gt;h = MTK_JPEG_MIN_HEIGHT;
 
-	for (i = 0; i &lt; q-&gt;fmt-&gt;colplanes; i++) {
-		u32 stride = q-&gt;w * q-&gt;fmt-&gt;h_sample[i] / 4;
-		u32 h = q-&gt;h * q-&gt;fmt-&gt;v_sample[i] / 4;
+		for (i = 0; i &lt; q-&gt;fmt-&gt;colplanes; i++) {
+			u32 stride = q-&gt;w * q-&gt;fmt-&gt;h_sample[i] / 4;
+			u32 h = q-&gt;h * q-&gt;fmt-&gt;v_sample[i] / 4;
 
-		q-&gt;bytesperline[i] = stride;
-		q-&gt;sizeimage[i] = stride * h;
+			q-&gt;bytesperline[i] = stride;
+			q-&gt;sizeimage[i] = stride * h;
+		}
 	}
 }
 
@@ -1021,6 +1430,13 @@ static int mtk_jpeg_open(struct file *file)
 		goto error;
 	}
 
+	ret = mtk_jpeg_ctrls_setup(ctx);
+	if (ret) {
+		v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;Failed to setup controls() (%d)\n&quot;,
+			 ret);
+		goto error;
+	}
+
 	mtk_jpeg_set_default_params(ctx);
 	mutex_unlock(&amp;jpeg-&gt;lock);
 	return 0;
@@ -1041,6 +1457,7 @@ static int mtk_jpeg_release(struct file *file)
 
 	mutex_lock(&amp;jpeg-&gt;lock);
 	v4l2_m2m_ctx_release(ctx-&gt;fh.m2m_ctx);
+	v4l2_ctrl_handler_free(&amp;ctx-&gt;ctrl_hdl);
 	v4l2_fh_del(&amp;ctx-&gt;fh);
 	v4l2_fh_exit(&amp;ctx-&gt;fh);
 	kfree(ctx);
@@ -1065,6 +1482,7 @@ static int mtk_jpeg_clk_init(struct mtk_jpeg_dev *jpeg)
 	node = of_parse_phandle(jpeg-&gt;dev-&gt;of_node, &quot;mediatek,larb&quot;, 0);
 	if (!node)
 		return -EINVAL;
+
 	pdev = of_find_device_by_node(node);
 	if (WARN_ON(!pdev)) {
 		of_node_put(node);
@@ -1074,19 +1492,24 @@ static int mtk_jpeg_clk_init(struct mtk_jpeg_dev *jpeg)
 
 	jpeg-&gt;larb = &amp;pdev-&gt;dev;
 
-	jpeg-&gt;clk_jdec = devm_clk_get(jpeg-&gt;dev, &quot;jpgdec&quot;);
-	if (IS_ERR(jpeg-&gt;clk_jdec))
-		return PTR_ERR(jpeg-&gt;clk_jdec);
+	if (jpeg-&gt;mode == MTK_JPEG_ENC) {
+		jpeg-&gt;clk_jpeg = devm_clk_get(jpeg-&gt;dev, &quot;jpgenc&quot;);
+		return PTR_ERR_OR_ZERO(jpeg-&gt;clk_jpeg);
+	}
 
-	jpeg-&gt;clk_jdec_smi = devm_clk_get(jpeg-&gt;dev, &quot;jpgdec-smi&quot;);
-	return PTR_ERR_OR_ZERO(jpeg-&gt;clk_jdec_smi);
+	jpeg-&gt;clk_jpeg = devm_clk_get(jpeg-&gt;dev, &quot;jpgdec&quot;);
+	if (IS_ERR(jpeg-&gt;clk_jpeg))
+		return PTR_ERR(jpeg-&gt;clk_jpeg);
+
+	jpeg-&gt;clk_jpeg_smi = devm_clk_get(jpeg-&gt;dev, &quot;jpgdec-smi&quot;);
+	return PTR_ERR_OR_ZERO(jpeg-&gt;clk_jpeg_smi);
 }
 
 static int mtk_jpeg_probe(struct platform_device *pdev)
 {
 	struct mtk_jpeg_dev *jpeg;
 	struct resource *res;
-	int dec_irq;
+	int jpeg_irq;
 	int ret;
 
 	jpeg = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*jpeg), GFP_KERNEL);
@@ -1096,28 +1519,26 @@ static int mtk_jpeg_probe(struct platform_device *pdev)
 	mutex_init(&amp;jpeg-&gt;lock);
 	spin_lock_init(&amp;jpeg-&gt;hw_lock);
 	jpeg-&gt;dev = &amp;pdev-&gt;dev;
+	jpeg-&gt;mode = (enum mtk_jpeg_mode)of_device_get_match_data(jpeg-&gt;dev);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	jpeg-&gt;dec_reg_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
-	if (IS_ERR(jpeg-&gt;dec_reg_base)) {
-		ret = PTR_ERR(jpeg-&gt;dec_reg_base);
+	jpeg-&gt;reg_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
+	if (IS_ERR(jpeg-&gt;reg_base)) {
+		ret = PTR_ERR(jpeg-&gt;reg_base);
 		return ret;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	dec_irq = platform_get_irq(pdev, 0);
-	if (!res || dec_irq &lt; 0) {
-		dev_err(&amp;pdev-&gt;dev, &quot;Failed to get dec_irq %d.\n&quot;, dec_irq);
-		ret = -EINVAL;
-		return ret;
+	jpeg_irq = platform_get_irq(pdev, 0);
+	if (jpeg_irq &lt; 0) {
+		dev_err(&amp;pdev-&gt;dev, &quot;Failed to get jpeg_irq %d.\n&quot;, jpeg_irq);
+		return jpeg_irq;
 	}
 
-	ret = devm_request_irq(&amp;pdev-&gt;dev, dec_irq, mtk_jpeg_dec_irq, 0,
+	ret = devm_request_irq(&amp;pdev-&gt;dev, jpeg_irq, mtk_jpeg_irq, 0,
 			       pdev-&gt;name, jpeg);
 	if (ret) {
-		dev_err(&amp;pdev-&gt;dev, &quot;Failed to request dec_irq %d (%d)\n&quot;,
-			dec_irq, ret);
-		ret = -EINVAL;
+		dev_err(&amp;pdev-&gt;dev, &quot;Failed to request jpeg_irq %d (%d)\n&quot;,
+			jpeg_irq, ret);
 		goto err_req_irq;
 	}
 
@@ -1141,33 +1562,35 @@ static int mtk_jpeg_probe(struct platform_device *pdev)
 		goto err_m2m_init;
 	}
 
-	jpeg-&gt;dec_vdev = video_device_alloc();
-	if (!jpeg-&gt;dec_vdev) {
+	jpeg-&gt;vfd_jpeg = video_device_alloc();
+	if (!jpeg-&gt;vfd_jpeg) {
 		ret = -ENOMEM;
-		goto err_dec_vdev_alloc;
+		goto err_vfd_jpeg_alloc;
 	}
-	snprintf(jpeg-&gt;dec_vdev-&gt;name, sizeof(jpeg-&gt;dec_vdev-&gt;name),
-		 &quot;%s-dec&quot;, MTK_JPEG_NAME);
-	jpeg-&gt;dec_vdev-&gt;fops = &amp;mtk_jpeg_fops;
-	jpeg-&gt;dec_vdev-&gt;ioctl_ops = &amp;mtk_jpeg_ioctl_ops;
-	jpeg-&gt;dec_vdev-&gt;minor = -1;
-	jpeg-&gt;dec_vdev-&gt;release = video_device_release;
-	jpeg-&gt;dec_vdev-&gt;lock = &amp;jpeg-&gt;lock;
-	jpeg-&gt;dec_vdev-&gt;v4l2_dev = &amp;jpeg-&gt;v4l2_dev;
-	jpeg-&gt;dec_vdev-&gt;vfl_dir = VFL_DIR_M2M;
-	jpeg-&gt;dec_vdev-&gt;device_caps = V4L2_CAP_STREAMING |
+	snprintf(jpeg-&gt;vfd_jpeg-&gt;name, sizeof(jpeg-&gt;vfd_jpeg-&gt;name),
+		 &quot;%s-%s&quot;, MTK_JPEG_NAME,
+		 jpeg-&gt;mode == MTK_JPEG_ENC ? &quot;enc&quot; : &quot;dec&quot;);
+	jpeg-&gt;vfd_jpeg-&gt;fops = &amp;mtk_jpeg_fops;
+	jpeg-&gt;vfd_jpeg-&gt;ioctl_ops = &amp;mtk_jpeg_ioctl_ops;
+	jpeg-&gt;vfd_jpeg-&gt;minor = -1;
+	jpeg-&gt;vfd_jpeg-&gt;release = video_device_release;
+	jpeg-&gt;vfd_jpeg-&gt;lock = &amp;jpeg-&gt;lock;
+	jpeg-&gt;vfd_jpeg-&gt;v4l2_dev = &amp;jpeg-&gt;v4l2_dev;
+	jpeg-&gt;vfd_jpeg-&gt;vfl_dir = VFL_DIR_M2M;
+	jpeg-&gt;vfd_jpeg-&gt;device_caps = V4L2_CAP_STREAMING |
 				      V4L2_CAP_VIDEO_M2M_MPLANE;
 
-	ret = video_register_device(jpeg-&gt;dec_vdev, VFL_TYPE_GRABBER, 3);
+	ret = video_register_device(jpeg-&gt;vfd_jpeg, VFL_TYPE_GRABBER, -1);
 	if (ret) {
 		v4l2_err(&amp;jpeg-&gt;v4l2_dev, &quot;Failed to register video device\n&quot;);
-		goto err_dec_vdev_register;
+		goto err_vfd_jpeg_register;
 	}
 
-	video_set_drvdata(jpeg-&gt;dec_vdev, jpeg);
+	video_set_drvdata(jpeg-&gt;vfd_jpeg, jpeg);
 	v4l2_info(&amp;jpeg-&gt;v4l2_dev,
-		  &quot;decoder device registered as /dev/video%d (%d,%d)\n&quot;,
-		  jpeg-&gt;dec_vdev-&gt;num, VIDEO_MAJOR, jpeg-&gt;dec_vdev-&gt;minor);
+		  &quot;jpeg device %d registered as /dev/video%d (%d,%d)\n&quot;,
+		  jpeg-&gt;mode, jpeg-&gt;vfd_jpeg-&gt;num, VIDEO_MAJOR,
+		  jpeg-&gt;vfd_jpeg-&gt;minor);
 
 	platform_set_drvdata(pdev, jpeg);
 
@@ -1175,10 +1598,10 @@ static int mtk_jpeg_probe(struct platform_device *pdev)
 
 	return 0;
 
-err_dec_vdev_register:
-	video_device_release(jpeg-&gt;dec_vdev);
+err_vfd_jpeg_register:
+	video_device_release(jpeg-&gt;vfd_jpeg);
 
-err_dec_vdev_alloc:
+err_vfd_jpeg_alloc:
 	v4l2_m2m_release(jpeg-&gt;m2m_dev);
 
 err_m2m_init:
@@ -1198,8 +1621,8 @@ static int mtk_jpeg_remove(struct platform_device *pdev)
 	struct mtk_jpeg_dev *jpeg = platform_get_drvdata(pdev);
 
 	pm_runtime_disable(&amp;pdev-&gt;dev);
-	video_unregister_device(jpeg-&gt;dec_vdev);
-	video_device_release(jpeg-&gt;dec_vdev);
+	video_unregister_device(jpeg-&gt;vfd_jpeg);
+	video_device_release(jpeg-&gt;vfd_jpeg);
 	v4l2_m2m_release(jpeg-&gt;m2m_dev);
 	v4l2_device_unregister(&amp;jpeg-&gt;v4l2_dev);
 
@@ -1210,7 +1633,11 @@ static __maybe_unused int mtk_jpeg_pm_suspend(struct device *dev)
 {
 	struct mtk_jpeg_dev *jpeg = dev_get_drvdata(dev);
 
-	mtk_jpeg_dec_reset(jpeg-&gt;dec_reg_base);
+	if (jpeg-&gt;mode == MTK_JPEG_ENC)
+		mtk_jpeg_enc_reset(jpeg-&gt;reg_base);
+	else
+		mtk_jpeg_dec_reset(jpeg-&gt;reg_base);
+
 	mtk_jpeg_clk_off(jpeg);
 
 	return 0;
@@ -1221,7 +1648,10 @@ static __maybe_unused int mtk_jpeg_pm_resume(struct device *dev)
 	struct mtk_jpeg_dev *jpeg = dev_get_drvdata(dev);
 
 	mtk_jpeg_clk_on(jpeg);
-	mtk_jpeg_dec_reset(jpeg-&gt;dec_reg_base);
+	if (jpeg-&gt;mode == MTK_JPEG_ENC)
+		mtk_jpeg_enc_reset(jpeg-&gt;reg_base);
+	else
+		mtk_jpeg_dec_reset(jpeg-&gt;reg_base);
 
 	return 0;
 }
@@ -1257,11 +1687,15 @@ static const struct dev_pm_ops mtk_jpeg_pm_ops = {
 static const struct of_device_id mtk_jpeg_match[] = {
 	{
 		.compatible = &quot;mediatek,mt8173-jpgdec&quot;,
-		.data       = NULL,
+		.data       = (void *)MTK_JPEG_DEC,
 	},
 	{
 		.compatible = &quot;mediatek,mt2701-jpgdec&quot;,
-		.data       = NULL,
+		.data       = (void *)MTK_JPEG_DEC,
+	},
+	{
+		.compatible = &quot;mediatek,mtk-jpgenc&quot;,
+		.data       = (void *)MTK_JPEG_ENC,
 	},
 	{},
 };
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
index 1a6cdfd4ea70..65ef920651a5 100644
--- a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
@@ -2,6 +2,7 @@
  * Copyright (c) 2016 MediaTek Inc.
  * Author: Ming Hsiu Tsai &lt;minghsiu.tsai@xxxxxxxxxxxx&gt;
  *         Rick Chang &lt;rick.chang@xxxxxxxxxxxx&gt;
+ *         Xia Jiang &lt;xia.jiang@xxxxxxxxxxxx&gt;
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -25,6 +26,8 @@
 
 #define MTK_JPEG_FMT_FLAG_DEC_OUTPUT	BIT(0)
 #define MTK_JPEG_FMT_FLAG_DEC_CAPTURE	BIT(1)
+#define MTK_JPEG_FMT_FLAG_ENC_OUTPUT	BIT(2)
+#define MTK_JPEG_FMT_FLAG_ENC_CAPTURE	BIT(3)
 
 #define MTK_JPEG_FMT_TYPE_OUTPUT	1
 #define MTK_JPEG_FMT_TYPE_CAPTURE	2
@@ -36,12 +39,63 @@
 
 #define MTK_JPEG_DEFAULT_SIZEIMAGE	(1 * 1024 * 1024)
 
+#define MTK_JPEG_ENCODE		0
+#define MTK_JPEG_DECODE		1
+
+/**
+ * enum mtk_jpeg_ctx_state - contex state of jpeg
+ */
 enum mtk_jpeg_ctx_state {
 	MTK_JPEG_INIT = 0,
 	MTK_JPEG_RUNNING,
 	MTK_JPEG_SOURCE_CHANGE,
 };
 
+/**
+ * enum mtk_jpeg_mode - mode of jpeg
+ */
+enum mtk_jpeg_mode {
+	MTK_JPEG_ENC,
+	MTK_JPEG_DEC,
+};
+
+/**
+ * enum jpeg_enc_yuv_fmt - yuv format of jpeg enc
+ */
+enum jpeg_enc_yuv_fmt {
+	JPEG_YUV_FORMAT_YUYV = 0,
+	JPEG_YUV_FORMAT_YVYU = 1,
+	JPEG_YUV_FORMAT_NV12 = 2,
+	JEPG_YUV_FORMAT_NV21 = 3,
+};
+
+/**
+ * enum JPEG_ENCODE_QUALITY_ENUM - number of jpeg encoder quality
+ */
+enum JPEG_ENCODE_QUALITY_ENUM {
+	JPEG_ENCODE_QUALITY_Q60 = 0x0,
+	JPEG_ENCODE_QUALITY_Q80 = 0x1,
+	JPEG_ENCODE_QUALITY_Q90 = 0x2,
+	JPEG_ENCODE_QUALITY_Q95 = 0x3,
+
+	JPEG_ENCODE_QUALITY_Q39 = 0x4,
+	JPEG_ENCODE_QUALITY_Q68 = 0x5,
+	JPEG_ENCODE_QUALITY_Q84 = 0x6,
+	JPEG_ENCODE_QUALITY_Q92 = 0x7,
+
+	JPEG_ENCODE_QUALITY_Q48 = 0x8,
+	JPEG_ENCODE_QUALITY_Q74 = 0xA,
+	JPEG_ENCODE_QUALITY_Q87 = 0xB,
+
+	JPEG_ENCODE_QUALITY_Q34 = 0xC,
+	JPEG_ENCODE_QUALITY_Q64 = 0xE,
+	JPEG_ENCODE_QUALITY_Q82 = 0xF,
+
+	JPEG_ENCODE_QUALITY_Q97 = 0x10,
+
+	JPEG_ENCODE_QUALITY_ALL = 0xFFFFFFFF
+};
+
 /**
  * struct mt_jpeg - JPEG IP abstraction
  * @lock:		the mutex protecting this structure
@@ -51,11 +105,12 @@ enum mtk_jpeg_ctx_state {
  * @v4l2_dev:		v4l2 device for mem2mem mode
  * @m2m_dev:		v4l2 mem2mem device data
  * @alloc_ctx:		videobuf2 memory allocator's context
- * @dec_vdev:		video device node for decoder mem2mem mode
- * @dec_reg_base:	JPEG registers mapping
- * @clk_jdec:		JPEG hw working clock
- * @clk_jdec_smi:	JPEG SMI bus clock
+ * @vfd_jpeg:		video device node for jpeg mem2mem mode
+ * @reg_base:		JPEG registers mapping
+ * @clk_jpeg:		JPEG hw working clock
+ * @clk_jpeg_smi:	JPEG SMI bus clock
  * @larb:		SMI device
+ * @mode:		compression (encode) operation or decompression (decode)
  */
 struct mtk_jpeg_dev {
 	struct mutex		lock;
@@ -65,11 +120,12 @@ struct mtk_jpeg_dev {
 	struct v4l2_device	v4l2_dev;
 	struct v4l2_m2m_dev	*m2m_dev;
 	void			*alloc_ctx;
-	struct video_device	*dec_vdev;
-	void __iomem		*dec_reg_base;
-	struct clk		*clk_jdec;
-	struct clk		*clk_jdec_smi;
+	struct video_device	*vfd_jpeg;
+	void __iomem		*reg_base;
+	struct clk		*clk_jpeg;
+	struct clk		*clk_jpeg_smi;
 	struct device		*larb;
+	enum mtk_jpeg_mode	mode;
 };
 
 /**
@@ -109,15 +165,51 @@ struct mtk_jpeg_q_data {
 	u32			sizeimage[VIDEO_MAX_PLANES];
 };
 
+/**
+ * jpeg_enc_param - parameters of jpeg encode control
+ * @enable_exif:	EXIF enable for jpeg encode mode
+ * @enc_quality:	destination image quality in encode mode
+ * @restart_interval:	JPEG restart interval for JPEG encoding
+ */
+struct jpeg_enc_param {
+	u32 enable_exif;
+	u32 enc_quality;
+	u32 restart_interval;
+};
+
+/**
+ * mtk_jpeg_enc_param:  General jpeg encoding parameters
+ * @enc_w:		image width
+ * @enc_h:		image height
+ * @enable_exif:	EXIF enable for jpeg encode mode
+ * @enc_quality:	destination image quality in encode mode
+ * @enc_format:		input image format
+ * @restart_interval:	JPEG restart interval for JPEG encoding
+ * @img_stride:		jpeg encoder image stride
+ * @mem_stride:		jpeg encoder memory stride
+ * @total_encdu:	total 8x8 block number
+ */
+struct mtk_jpeg_enc_param {
+	u32 enc_w;
+	u32 enc_h;
+	u32 enable_exif;
+	u32 enc_quality;
+	u32 enc_format;
+	u32 restart_interval;
+	u32 img_stride;
+	u32 mem_stride;
+	u32 total_encdu;
+};
+
 /**
  * mtk_jpeg_ctx - the device context data
  * @jpeg:		JPEG IP device for this context
  * @out_q:		source (output) queue information
  * @cap_q:		destination (capture) queue queue information
  * @fh:			V4L2 file handle
- * @dec_param		parameters for HW decoding
  * @state:		state of the context
- * @header_valid:	set if header has been parsed and valid
+ * @jpeg_param:		jpeg encode parameters
+ * @ctrl_hdl:		controls handler
  * @colorspace: enum v4l2_colorspace; supplemental to pixelformat
  * @ycbcr_enc: enum v4l2_ycbcr_encoding, Y'CbCr encoding
  * @quantization: enum v4l2_quantization, colorspace quantization
@@ -129,6 +221,8 @@ struct mtk_jpeg_ctx {
 	struct mtk_jpeg_q_data		cap_q;
 	struct v4l2_fh			fh;
 	enum mtk_jpeg_ctx_state		state;
+	struct jpeg_enc_param		jpeg_param;
+	struct v4l2_ctrl_handler	ctrl_hdl;
 
 	enum v4l2_colorspace colorspace;
 	enum v4l2_ycbcr_encoding ycbcr_enc;
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_dec_hw.h b/drivers/media/platform/mtk-jpeg/mtk_jpeg_dec_hw.h
index bff6a4aab57a..725ce94fd58f 100644
--- a/drivers/media/platform/mtk-jpeg/mtk_jpeg_dec_hw.h
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_dec_hw.h
@@ -2,6 +2,7 @@
  * Copyright (c) 2016 MediaTek Inc.
  * Author: Ming Hsiu Tsai &lt;minghsiu.tsai@xxxxxxxxxxxx&gt;
  *         Rick Chang &lt;rick.chang@xxxxxxxxxxxx&gt;
+ *         Xia Jiang &lt;xia.jiang@xxxxxxxxxxxx&gt;
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,8 +14,8 @@
  * GNU General Public License for more details.
  */
 
-#ifndef _MTK_JPEG_HW_H
-#define _MTK_JPEG_HW_H
+#ifndef _MTK_JPEG_DEC_HW_H
+#define _MTK_JPEG_DEC_HW_H
 
 #include &lt;media/videobuf2-core.h&gt;
 
@@ -88,4 +89,4 @@ void mtk_jpeg_dec_set_config(void __iomem *base,
 void mtk_jpeg_dec_reset(void __iomem *dec_reg_base);
 void mtk_jpeg_dec_start(void __iomem *dec_reg_base);
 
-#endif /* _MTK_JPEG_HW_H */
+#endif /* _MTK_JPEG_DEC_HW_H */
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_hw.c b/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_hw.c
new file mode 100644
index 000000000000..b82d39f1022b
--- /dev/null
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_hw.c
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Xia Jiang &lt;xia.jiang@xxxxxxxxxxxx&gt;
+ *
+ */
+
+#include &lt;linux/io.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;media/videobuf2-core.h&gt;
+
+#include &quot;mtk_jpeg_enc_hw.h&quot;
+
+void mtk_jpeg_enc_reset(void __iomem *base)
+{
+	writel(0x00, base + JPGENC_RSTB);
+	writel(JPEG_ENC_RESET_BIT, base + JPGENC_RSTB);
+	writel(0x00, base + JPGENC_CODEC_SEL);
+}
+
+u32 mtk_jpeg_enc_get_int_status(void __iomem *base)
+{
+	u32 ret;
+
+	ret = readl(base + JPGENC_INT_STS) &amp;
+		    JPEG_DRV_ENC_INT_STATUS_MASK_ALLIRQ;
+	if (ret)
+		writel(0, base + JPGENC_INT_STS);
+
+	return ret;
+}
+
+u32 mtk_jpeg_enc_get_file_size(void __iomem *base)
+{
+	return readl(base + JPGENC_DMA_ADDR0) - readl(base + JPGENC_DST_ADDR0);
+}
+
+u32 mtk_jpeg_enc_enum_result(void __iomem *base, u32 irq_status, u32 *file_size)
+{
+	*file_size = mtk_jpeg_enc_get_file_size(base);
+	if (irq_status &amp; JPEG_DRV_ENC_INT_STATUS_DONE)
+		return MTK_JPEG_ENC_RESULT_DONE;
+	else if (irq_status &amp; JPEG_DRV_ENC_INT_STATUS_STALL)
+		return MTK_JPEG_ENC_RESULT_STALL;
+	else if (irq_status &amp; JPEG_DRV_ENC_INT_STATUS_VCODEC_IRQ)
+		return MTK_JPEG_ENC_RESULT_VCODEC_IRQ;
+	return MTK_JPEG_ENC_RESULT_ERROR_UNKNOWN;
+}
+
+static void mtk_jpeg_enc_set_blk_num(void __iomem *base, u32 blk_num)
+{
+	writel(blk_num, base + JPGENC_BLK_NUM);
+}
+
+static void mtk_jpeg_enc_set_encFormat(void __iomem *base, u32 enc_format)
+{
+	u32 value;
+
+	value = readl(base + JPGENC_CTRL);
+	value &amp;= ~JPEG_ENC_CTRL_YUV_BIT;
+	value |= JPGENC_FORMAT(enc_format);
+	writel(value, base + JPGENC_CTRL);
+}
+
+static void mtk_jpeg_enc_set_img_size(void __iomem *base, u32 width, u32 height)
+{
+	u32 value;
+
+	value = JPGENC_WIDTH_HEIGHT(width, height);
+	writel(value, base + JPGENC_IMG_SIZE);
+}
+
+static void mtk_jpeg_enc_set_src_img(void __iomem *base, u32 width,
+				     u32 height, u32 yuv_format,
+				     u32 total_encdu)
+{
+	mtk_jpeg_enc_set_img_size(base, width, height);
+	mtk_jpeg_enc_set_encFormat(base, yuv_format);
+	mtk_jpeg_enc_set_blk_num(base, total_encdu);
+}
+
+static void mtk_jpeg_enc_set_src_buf(void __iomem *base, u32 img_stride,
+				     u32 mem_stride, u32 src_addr,
+				     u32 src_addr_c)
+{
+	writel(img_stride, base + JPGENC_IMG_STRIDE);
+	writel(mem_stride, base + JPGENC_STRIDE);
+	writel(src_addr, base + JPGENC_SRC_LUMA_ADDR);
+	writel(src_addr_c, base + JPGENC_SRC_CHROMA_ADDR);
+}
+
+static void mtk_jpeg_enc_set_dst_buf(void __iomem *base, u32 dst_addr,
+				     u32 stall_size, u32 init_offset,
+				     u32 offset_mask)
+{
+	writel(JPGENC_INIT_OFFSET(init_offset), base + JPGENC_OFFSET_ADDR);
+	writel(JPGENC_OFFSET_MASK(offset_mask), base + JPGENC_BYTE_OFFSET_MASK);
+	writel(JPGENC_DST_ADDR(dst_addr), base + JPGENC_DST_ADDR0);
+	writel(JPGENC_STALL_ADDR(dst_addr, stall_size),
+	       base + JPGENC_STALL_ADDR0);
+}
+
+static void mtk_jpeg_enc_set_quality(void __iomem *base, u32 quality)
+{
+	u32 value;
+
+	value = readl(base + JPGENC_QUALITY);
+	value = JPGENC_SET_QUALITY(value, quality);
+	writel(value, base + JPGENC_QUALITY);
+}
+
+static void mtk_jpeg_enc_set_restart_interval(void __iomem *base,
+					      u32 restart_interval)
+{
+	u32 value;
+
+	value = readl(base + JPGENC_CTRL);
+	if (restart_interval)
+		value |= JPEG_ENC_CTRL_RESTART_EN_BIT;
+	else
+		value &amp;= ~JPEG_ENC_CTRL_RESTART_EN_BIT;
+	writel(value, base + JPGENC_CTRL);
+	writel(restart_interval, base + JPGENC_RST_MCU_NUM);
+}
+
+static void mtk_jpeg_enc_set_encode_mode(void __iomem *base, u32 exif_en)
+{
+	u32 value;
+
+	value = readl(base + JPGENC_CTRL);
+	value &amp;= ~JPEG_ENC_CTRL_FILE_FORMAT_BIT;
+	writel(value, base + JPGENC_CTRL);
+
+	if (exif_en) {
+		value = readl(base + JPGENC_CTRL);
+		value |= JPEG_ENC_EN_JFIF_EXIF;
+		writel(value, base + JPGENC_CTRL);
+	}
+}
+
+static void mtk_jpeg_enc_set_ctrl_cfg(void __iomem *base, u32 exif_en,
+				      u32 quality, u32 restart_interval)
+{
+	mtk_jpeg_enc_set_quality(base, quality);
+
+	mtk_jpeg_enc_set_restart_interval(base, restart_interval);
+
+	mtk_jpeg_enc_set_encode_mode(base, exif_en);
+}
+
+void mtk_jpeg_enc_start(void __iomem *base)
+{
+	u32 value;
+
+	value = readl(base + JPGENC_CTRL);
+	value |= JPEG_ENC_CTRL_INT_EN_BIT | JPEG_ENC_CTRL_ENABLE_BIT;
+	writel(value, base + JPGENC_CTRL);
+}
+
+void mtk_jpeg_enc_set_config(void __iomem *base,
+			     struct mtk_jpeg_enc_param *config,
+			     struct mtk_jpeg_enc_bs *bs,
+			     struct mtk_jpeg_enc_fb *fb)
+{
+	mtk_jpeg_enc_set_src_img(base, config-&gt;enc_w, config-&gt;enc_h,
+				 config-&gt;enc_format, config-&gt;total_encdu);
+	mtk_jpeg_enc_set_src_buf(base, config-&gt;img_stride, config-&gt;mem_stride,
+				 fb-&gt;fb_addr[0].dma_addr,
+				 fb-&gt;fb_addr[1].dma_addr);
+	mtk_jpeg_enc_set_dst_buf(base, bs-&gt;dma_addr, bs-&gt;size,
+				 bs-&gt;dma_addr_offset, bs-&gt;dma_addr_offsetmask);
+	mtk_jpeg_enc_set_ctrl_cfg(base, config-&gt;enable_exif,
+				  config-&gt;enc_quality,
+				  config-&gt;restart_interval);
+}
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_hw.h b/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_hw.h
new file mode 100644
index 000000000000..ef3e6d97cdcd
--- /dev/null
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_hw.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Xia Jiang &lt;xia.jiang@xxxxxxxxxxxx&gt;
+ *
+ */
+
+#ifndef _MTK_JPEG_ENC_HW_H
+#define _MTK_JPEG_ENC_HW_H
+
+#include &lt;media/videobuf2-core.h&gt;
+
+#include &quot;mtk_jpeg_core.h&quot;
+#include &quot;mtk_jpeg_enc_reg.h&quot;
+
+#define JPEG_ENC_DST_ADDR_OFFSET_MASK GENMASK(3, 0)
+
+#define JPEG_ENC_CTRL_YUV_BIT 0x18
+#define JPEG_ENC_CTRL_RESTART_EN_BIT            BIT(10)
+#define JPEG_ENC_CTRL_FILE_FORMAT_BIT           BIT(5)
+#define JPEG_ENC_EN_JFIF_EXIF                   BIT(5)
+#define JPEG_ENC_CTRL_INT_EN_BIT                BIT(2)
+#define JPEG_ENC_CTRL_ENABLE_BIT                BIT(0)
+#define JPEG_ENC_RESET_BIT                      BIT(0)
+
+enum {
+	MTK_JPEG_ENC_RESULT_DONE		= 0,
+	MTK_JPEG_ENC_RESULT_STALL,
+	MTK_JPEG_ENC_RESULT_VCODEC_IRQ,
+	MTK_JPEG_ENC_RESULT_ERROR_UNKNOWN
+};
+
+struct mtk_jpeg_enc_bs {
+	dma_addr_t	dma_addr;
+	size_t		size;
+	u32			dma_addr_offset;
+	u32			dma_addr_offsetmask;
+};
+
+struct mtk_jpeg_mem {
+	dma_addr_t	dma_addr;
+	size_t		size;
+};
+
+struct mtk_jpeg_enc_fb {
+	struct mtk_jpeg_mem	fb_addr[MTK_JPEG_COMP_MAX];
+	u32			num_planes;
+};
+
+void mtk_jpeg_enc_reset(void __iomem *base);
+u32 mtk_jpeg_enc_get_int_status(void __iomem *base);
+u32 mtk_jpeg_enc_get_file_size(void __iomem *base);
+u32 mtk_jpeg_enc_enum_result(void __iomem *base, u32 irq_status,
+			     u32 *file_size);
+void mtk_jpeg_enc_start(void __iomem *enc_reg_base);
+void mtk_jpeg_enc_set_config(void __iomem *base,
+			     struct mtk_jpeg_enc_param *config,
+			     struct mtk_jpeg_enc_bs *bs,
+			     struct mtk_jpeg_enc_fb *fb);
+#endif /* _MTK_JPEG_ENC_HW_H */
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_reg.h b/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_reg.h
new file mode 100644
index 000000000000..2e64fcd58bf6
--- /dev/null
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_enc_reg.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Xia Jiang &lt;xia.jiang@xxxxxxxxxxxx&gt;
+ *
+ */
+#ifndef _MTK_JPEG_ENC_REG_H
+#define _MTK_JPEG_ENC_REG_H
+#define MTK_JPEG_COMP_MAX		3
+
+#define JPEG_DRV_ENC_INT_STATUS_DONE			BIT(0)
+#define JPEG_DRV_ENC_INT_STATUS_STALL			BIT(1)
+#define JPEG_DRV_ENC_INT_STATUS_VCODEC_IRQ		BIT(4)
+#define JPEG_DRV_ENC_INT_STATUS_MASK_ALLIRQ		0x13
+
+#define JPGENC_RSTB				0x100
+#define JPGENC_CTRL				0x104
+#define JPGENC_QUALITY				0x108
+#define JPGENC_BLK_NUM				0x10C
+#define JPGENC_BLK_CNT				0x110
+#define JPGENC_INT_STS				0x11C
+#define JPGENC_DST_ADDR0			0x120
+#define JPGENC_DMA_ADDR0			0x124
+#define JPGENC_STALL_ADDR0			0x128
+#define JPGENC_OFFSET_ADDR			0x138
+#define JPGENC_RST_MCU_NUM			0x150
+#define JPGENC_IMG_SIZE				0x154
+#define JPGENC_DEBUG_INFO0			0x160
+#define JPGENC_DEBUG_INFO1			0x164
+#define JPGENC_TOTAL_CYCLE			0x168
+#define JPGENC_BYTE_OFFSET_MASK			0x16C
+#define JPGENC_SRC_LUMA_ADDR			0x170
+#define JPGENC_SRC_CHROMA_ADDR			0x174
+#define JPGENC_STRIDE				0x178
+#define JPGENC_IMG_STRIDE			0x17C
+#define JPGENC_DCM_CTRL				0x300
+#define JPGENC_CODEC_SEL			0x314
+#define JPGENC_ULTRA_THRES			0x318
+
+#define JPGENC_FORMAT(x)		(((x) &amp; 3) &lt;&lt; 3)
+#define JPGENC_WIDTH_HEIGHT(w, h)	(((w) &lt;&lt; 16) | (h))
+#define JPGENC_INIT_OFFSET(x)		((x) &amp; (~0xF))
+#define JPGENC_OFFSET_MASK(x)		((x) &amp; 0xF)
+#define JPGENC_DST_ADDR(x)		((x) &amp; (~0xF))
+#define JPGENC_STALL_ADDR(x, y)		(((x) + (y)) &amp; (~0xF))
+#define JPGENC_QUALITY_MASK		0xFFFF0000
+#define JPGENC_SET_QUALITY(x, y)	(((x) &amp; JPGENC_QUALITY_MASK) | (y))
+
+#endif /* _MTK_JPEG_ENC_REG_H */
diff --git a/drivers/media/v4l2-core/v4l2-ctrls.c b/drivers/media/v4l2-core/v4l2-ctrls.c
index 89a1fe564675..02826c0dceb9 100644
--- a/drivers/media/v4l2-core/v4l2-ctrls.c
+++ b/drivers/media/v4l2-core/v4l2-ctrls.c
@@ -1010,6 +1010,7 @@ const char *v4l2_ctrl_get_name(u32 id)
 	case V4L2_CID_JPEG_CHROMA_SUBSAMPLING:	return &quot;Chroma Subsampling&quot;;
 	case V4L2_CID_JPEG_RESTART_INTERVAL:	return &quot;Restart Interval&quot;;
 	case V4L2_CID_JPEG_COMPRESSION_QUALITY:	return &quot;Compression Quality&quot;;
+	case V4L2_CID_JPEG_ENABLE_EXIF:		return &quot;Enable Exif&quot;;
 	case V4L2_CID_JPEG_ACTIVE_MARKER:	return &quot;Active Markers&quot;;
 
 	/* Image source controls */
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
index 37807f23231e..863ea6f93562 100644
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -998,6 +998,8 @@ enum v4l2_jpeg_chroma_subsampling {
 #define	V4L2_JPEG_ACTIVE_MARKER_COM		(1 &lt;&lt; 16)
 #define	V4L2_JPEG_ACTIVE_MARKER_DQT		(1 &lt;&lt; 17)
 #define	V4L2_JPEG_ACTIVE_MARKER_DHT		(1 &lt;&lt; 18)
+#define	V4L2_CID_JPEG_ENABLE_EXIF		(V4L2_CID_JPEG_CLASS_BASE + 5)
+
 
 
 /* Image source controls */
-- 
2.18.0


_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@xxxxxxxxxxxxxxxxxxx
<a  rel="nofollow" href="http://lists.infradead.org/mailman/listinfo/linux-arm-kernel">http://lists.infradead.org/mailman/listinfo/linux-arm-kernel</a>



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="741522" href="msg741522.html">[PATCH v2 0/5]Add support for mt2701 JPEG ENC support</a></strong>
<ul><li><em>From:</em> Xia Jiang</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg741528.html">[PATCH 2/5] media: platform: Rename jpeg dec file name</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg741530.html">[PATCH 5/5] arm: dts: add jpeg enc device tree node</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg741528.html">[PATCH 2/5] media: platform: Rename jpeg dec file name</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg741530.html">[PATCH 5/5] arm: dts: add jpeg enc device tree node</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#741529"><strong>Date</strong></a></li>
<li><a href="threads.html#741529"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/kernel/>[Linux&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm/>[Linux&nbsp;ARM&nbsp;(vger)]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-arm-msm/>[Linux&nbsp;ARM&nbsp;MSM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;Omap]</a>
&nbsp;
&nbsp;
<a href=/lists/centos-arm-devel/>[CentOS&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/arm/>[Linux&nbsp;Arm]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-tegra/>[Linux&nbsp;Tegra]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-arm/>[Fedora&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-samsung-soc/>[Linux&nbsp;for&nbsp;Samsung&nbsp;SOC]</a>
&nbsp;
&nbsp;
<a href=/lists/ecos/>[eCos]</a>
&nbsp;
&nbsp;
<a href=/lists/fastboot/>[Linux&nbsp;Fastboot]</a>
&nbsp;
&nbsp;
<a href=/lists/gcchelp/>[Gcc&nbsp;Help]</a>
&nbsp;
&nbsp;
<a href=/lists/git/>[Git]</a>
&nbsp;
&nbsp;
<a href=/lists/dccp/>[DCCP]</a>
&nbsp;
&nbsp;
<a href=/lists/ietf-ann>[IETF&nbsp;Announce]</a>
&nbsp;
&nbsp;
<a href=/lists/security/>[Security]</a>
&nbsp;
&nbsp;
<a href=/lists/mips/>[Linux&nbsp;MIPS]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }

initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
