<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format -->
<!--X-From-R13: Vrvam [nhryfuntra &#60;znhryfuntraNerqung.pbz> -->
<!--X-Date: Fri, 29 Jun 2007 02:37:40 &#45;0700 -->
<!--X-Message-Id: 20070629093735.GL2980@redhat.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 200611221515.08246.jason.d.gaston@intel.com -->
<!--X-Reference: 200706281653.40019.jason.d.gaston@intel.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Re: [PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format &mdash; Linux ATA RAID Storage Archive">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Linux ATA RAID Storage &mdash; Re: [PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format</title>
<link rel="alternate" type="application/rss+xml" title="ATA RAID" href="//feeds2.feedburner.com/ataraid">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" async defer></script>
<h1 itemprop="name">Re: [PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format</h1>
[<a href="msg02910.html">Date Prev</a>][<a href="msg02912.html">Date Next</a>][<a href="msg02909.html">Thread Prev</a>][<a href="msg02928.html">Thread Next</a>][<a href="maillist.html#02911">Date Index</a>][<a href="threads.html#02911">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format</li>
<li><em>From</em>: Heinz Mauelshagen &lt;<a href="mailto:mauelshagen@DOMAIN.HIDDEN">mauelshagen@xxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Fri, 29 Jun 2007 11:37:35 +0200</li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:200706281653.40019.jason.d.gaston@DOMAIN.HIDDEN">200706281653.40019.jason.d.gaston@xxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:200611221515.08246.jason.d.gaston@DOMAIN.HIDDEN">200611221515.08246.jason.d.gaston@xxxxxxxxx</a>&gt;	&lt;<a href="mailto:200706281653.40019.jason.d.gaston@DOMAIN.HIDDEN">200706281653.40019.jason.d.gaston@xxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.5.14 (2007-02-12)</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" defer async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>
Jason,

thanks.
Will integrate and test.

Can you send me some metadata samples (in personal email)
created with &quot;dmraid -rD&quot; for referenece, please ?

Heinz

On Thu, Jun 28, 2007 at 04:53:39PM -0700, Jason Gaston wrote:
&gt; This patch adds raid10(0+1) nested raid level support to the Intel isw 
&gt; metadata format handler in dmraid 1.0.0.rc14. 
&gt; 
&gt; Signed-off-by: &#xA0;Jason Gaston &lt;jason.d.gaston@xxxxxxxxx&gt;
&gt; 
&gt; --- 1.0.0.rc14/lib/format/ataraid/isw.c.orig	2006-09-22 11:11:37.000000000 
&gt; -0700
&gt; +++ 1.0.0.rc14/lib/format/ataraid/isw.c	2007-06-28 14:06:31.000000000 -0700
&gt; @@ -25,30 +25,59 @@
&gt;  #endif
&gt;  
&gt;  static const char *handler = HANDLER;
&gt; +static struct isw_disk *_get_disk(struct isw *isw, struct dev_info *di);
&gt; +int is_raid10(struct isw *isw);
&gt;  
&gt; -/*
&gt; - * Make up RAID set name from family_num and volume name.
&gt; - */
&gt; -static size_t _name(struct isw *isw, struct isw_dev *dev,
&gt; -		     char *str, size_t len)
&gt; +static size_t _name(struct isw *isw, char *str, size_t len, int subset,
&gt; +						int num, struct isw_dev *dev)
&gt;  {
&gt; -	return snprintf(str, len, dev ? &quot;isw_%u_%s&quot; : &quot;isw_%u&quot;,
&gt; +	switch(subset) {
&gt; +	case 2:
&gt; +		return snprintf(str, len, &quot;isw_%u&quot;, isw-&gt;family_num);
&gt; +	case 1:
&gt; +		if(!is_raid10(isw))
&gt; +			return snprintf(str, len, &quot;isw_%u_%s&quot;,
&gt;  			isw-&gt;family_num, (char*) dev-&gt;volume);
&gt; -}
&gt; +		else	
&gt; +			return snprintf(str, len, &quot;isw_%u_%s-%u&quot;,
&gt; +				isw-&gt;family_num, (char*) dev-&gt;volume, num);
&gt; +	case 0:
&gt; +		return snprintf(str, len, &quot;isw_%u_%s&quot;, isw-&gt;family_num,
&gt; +							(char*) dev-&gt;volume);
&gt; +	}
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static char *name(struct lib_context *lc, struct raid_dev *rd,
&gt; +						unsigned int subset)
&gt; +{
&gt; +	size_t len;
&gt; +	char *ret = NULL;
&gt; +	int id = 0;
&gt; +	struct isw *isw = META(rd, isw);
&gt; +	struct isw_disk *disk = isw-&gt;disk;
&gt; +	struct isw_dev *dev = (struct isw_dev*) (isw-&gt;disk + isw-&gt;num_disks);
&gt;  
&gt; -static char *name(struct lib_context *lc, struct isw *isw, struct isw_dev 
&gt; *dev)
&gt; -{
&gt; -        size_t len;
&gt; -        char *ret;
&gt; +	if((subset == 1) &amp;&amp; (is_raid10(isw))) {
&gt; +		if ((disk = _get_disk(isw, rd-&gt;di))) {
&gt; +			if(disk == isw-&gt;disk)	id = 0;
&gt; +			else if(disk == isw-&gt;disk + 1)	id = 1;
&gt; +			else if(disk == isw-&gt;disk + 2)	id = 2;
&gt; +			else if(disk == isw-&gt;disk + 3)	id = 3;
&gt; +			else return ret;
&gt; +		}
&gt; +		id = id % 2;
&gt; +	}
&gt;  
&gt; -        if ((ret = dbg_malloc((len = _name(isw, dev, NULL, 0) + 1)))) {
&gt; -                _name(isw, dev, ret, len);
&gt; -		mk_alpha(lc, ret + HANDLER_LEN, len - HANDLER_LEN -
&gt; -			 (dev ? strlen((char*) dev-&gt;volume) - 2 : 1));
&gt; -        } else
&gt; +	if ((ret = dbg_malloc((len = _name(isw, ret, 0, subset, id,
&gt; +							dev) + 1)))) {
&gt; +					_name(isw, ret, len, subset, id, dev);
&gt; +		mk_alpha(lc, ret + HANDLER_LEN, snprintf(ret, 0, &quot;%u&quot;,
&gt; +							isw-&gt;family_num));
&gt; +	} else
&gt;  		log_alloc_err(lc, handler);
&gt;  
&gt; -        return ret;
&gt; +	return ret;
&gt;  }
&gt;  
&gt;  /* Find a disk table slot by serial number. */
&gt; @@ -59,7 +88,7 @@
&gt;  
&gt;  		do {
&gt;  			if (!strncmp(di-&gt;serial, (const char*) disk-&gt;serial,
&gt; -				     MAX_RAID_SERIAL_LEN))
&gt; +							MAX_RAID_SERIAL_LEN))
&gt;  				return disk;
&gt;  		} while (++disk &lt; isw-&gt;disk + isw-&gt;num_disks);
&gt;  	}
&gt; @@ -102,21 +131,38 @@
&gt;  }
&gt;  
&gt;  /* Neutralize disk type. */
&gt; -static enum type type(struct raid_dev *rd)
&gt; +static enum type type(struct isw *isw)
&gt;  {
&gt;  	/* Mapping of Intel types to generic types. */
&gt;  	static struct types types[] = {
&gt;  	        { ISW_T_RAID0, t_raid0},
&gt;  	        { ISW_T_RAID1, t_raid1},
&gt;  	        { ISW_T_RAID5, t_raid5_la},
&gt; +	        { ISW_T_RAID10, t_raid0},
&gt;  	        { 0, t_undef},
&gt;  	};
&gt; -	struct isw_dev *dev = rd-&gt;private.ptr;
&gt; +
&gt; +	struct isw_dev *dev = (struct isw_dev*) (isw-&gt;disk + isw-&gt;num_disks);
&gt; +	
&gt; +	if(is_raid10(isw))
&gt; +		dev-&gt;vol.map.raid_level = ISW_T_RAID10;
&gt;  
&gt;  	return dev ? rd_type(types, (unsigned int) dev-&gt;vol.map.raid_level) :
&gt;  		     t_group;
&gt;  }
&gt;  
&gt; +int is_raid10(struct isw *isw)
&gt; +{
&gt; +	int ret;
&gt; +	struct isw_dev *dev = (struct isw_dev*) (isw-&gt;disk + isw-&gt;num_disks);
&gt; +
&gt; +	ret = ((dev-&gt;vol.map.raid_level == ISW_T_RAID10) ||
&gt; +			(dev-&gt;vol.map.raid_level == ISW_T_RAID1 &amp;&amp;
&gt; +			isw-&gt;num_disks &gt; 3));
&gt; +
&gt; +	return ret;
&gt; +}
&gt; +
&gt;  /*
&gt;   * Generate checksum of Raid metadata for mpb_size/sizeof(u32) words
&gt;   * (checksum field itself ignored for this calculation).
&gt; @@ -298,7 +344,8 @@
&gt;  }
&gt;  
&gt;  /* Check for RAID disk ok. */
&gt; -static int disk_ok(struct lib_context *lc, struct dev_info *di, struct isw 
&gt; *isw)
&gt; +static int disk_ok(struct lib_context *lc, struct dev_info *di,
&gt; +						struct isw *isw)
&gt;  {
&gt;  	struct isw_disk *disk = get_disk(lc, di, isw);
&gt;  
&gt; @@ -306,15 +353,15 @@
&gt;  }
&gt;  
&gt;  static void *isw_read_metadata(struct lib_context *lc, struct dev_info *di,
&gt; -			       size_t *sz, uint64_t *offset,
&gt; -			       union read_info *info)
&gt; +						size_t *sz, uint64_t *offset,
&gt; +						union read_info *info)
&gt;  {
&gt;  	size_t size = ISW_DISK_BLOCK_SIZE;
&gt;  	uint64_t isw_sboffset = ISW_CONFIGOFFSET;
&gt;  	struct isw *isw;
&gt;  
&gt;  	if (!(isw = alloc_private_and_read(lc, handler, size,
&gt; -					   di-&gt;path, isw_sboffset)))
&gt; +					di-&gt;path, isw_sboffset)))
&gt;  		goto out;
&gt;  
&gt;  	/*
&gt; @@ -391,7 +438,7 @@
&gt;   */
&gt;  /* Check state if isw device map. */
&gt;  static int _check_map_state(struct lib_context *lc, struct raid_dev *rd,
&gt; -			    struct isw_dev *dev)
&gt; +							struct isw_dev *dev)
&gt;  {
&gt;  	/* FIXME: FAILED_MAP etc. */
&gt;  	switch (dev-&gt;vol.map.map_state) {
&gt; @@ -415,20 +462,27 @@
&gt;  	struct raid_dev *r;
&gt;  
&gt;  	if (!_check_map_state(lc, rd, dev) ||
&gt; -	    !(r = alloc_raid_dev(lc, handler)))
&gt; +		!(r = alloc_raid_dev(lc, handler)))
&gt;  		return NULL;
&gt;  
&gt;  	if (!(r-&gt;private.ptr = alloc_private(lc, handler, sizeof(*dev))))
&gt;  		goto free;
&gt; -
&gt;  	memcpy(r-&gt;private.ptr, dev, sizeof(*dev));
&gt; -	if ((r-&gt;type = type(r)) == t_undef) {
&gt; +
&gt; +	if (!(r-&gt;meta_areas = alloc_meta_areas(lc, rd, handler, 1)))
&gt; +		return 0;
&gt; +
&gt; +	r-&gt;meta_areas-&gt;offset = rd-&gt;meta_areas-&gt;offset;
&gt; +	r-&gt;meta_areas-&gt;size = rd-&gt;meta_areas-&gt;size; 
&gt; +	r-&gt;meta_areas-&gt;area = rd-&gt;meta_areas-&gt;area; 
&gt; +
&gt; +	if ((r-&gt;type = type(isw)) == t_undef) {
&gt;  		log_err(lc, &quot;%s: RAID type %u not supported&quot;,
&gt;  			handler, (unsigned int) dev-&gt;vol.map.raid_level);
&gt;  		goto free;
&gt;  	}
&gt;  
&gt; -        if (!(r-&gt;name = name(lc, isw, dev)))
&gt; +        if (!(r-&gt;name = name(lc, rd, 1)))
&gt;  		goto free;
&gt;  
&gt;  	r-&gt;di = rd-&gt;di;
&gt; @@ -460,43 +514,73 @@
&gt;  	return _get_disk(isw, RD(new)-&gt;di) &lt; _get_disk(isw, RD(pos)-&gt;di);
&gt;  }
&gt;  
&gt; +static void super_created(struct raid_set *super, void *private)
&gt; +{
&gt; +	super-&gt;type   = t_raid1;
&gt; +	super-&gt;stride = ((struct isw_dev*) private)-&gt;vol.map.blocks_per_strip;
&gt; +}
&gt; +
&gt; +static int set_sort(struct list_head *pos, struct list_head *new)
&gt; +{
&gt; +	return 0;
&gt; +}
&gt; +
&gt;  /*
&gt;   * rs_group contains the top-level group RAID set (type: t_group) on entry
&gt;   * and shall be returned on success (or NULL on error).
&gt;   */
&gt;  static struct raid_set *group_rd(struct lib_context *lc,
&gt; -				   struct raid_set *rs_group,
&gt; -				   struct raid_dev *rd_meta)
&gt; +				struct raid_set *rs_group,
&gt; +				struct raid_dev *rd_meta)
&gt;  {
&gt;  	unsigned int d;
&gt;  	void *private;
&gt;  	struct isw *isw = META(rd_meta, isw);
&gt;  	struct isw_dev *dev;
&gt;  	struct raid_dev *rd;
&gt; -	struct raid_set *rs;
&gt; -
&gt; +	struct raid_set *rs, *ss;
&gt; +	char *nm = NULL;
&gt; +		
&gt;  	/* Loop the device/volume table. */
&gt;  	for (d = 0; d &lt; isw-&gt;num_raid_devs; d++) {
&gt;  		dev = raiddev(isw, d);
&gt; -
&gt; +		
&gt;  		if (!(rd = _create_rd(lc, rd_meta, isw, dev)))
&gt;  			return NULL;
&gt;  
&gt; -		if (!(rs = find_or_alloc_raid_set(lc, rd-&gt;name, FIND_ALL,
&gt; -				      		  rd, &amp;rs_group-&gt;sets,
&gt; -						  create_rs, dev))) {
&gt; -			free_raid_dev(lc, &amp;rd);
&gt; -			return NULL;
&gt; +		if(is_raid10(isw)) {
&gt; +			nm = name(lc, rd, 0);
&gt; +			ss = find_or_alloc_raid_set(lc, nm, FIND_TOP, rd,
&gt; +						LC_RS(lc), super_created, dev);
&gt; +	 		if (!(rs = find_or_alloc_raid_set(lc, rd-&gt;name,
&gt; +					FIND_ALL, rd, &amp;ss-&gt;sets, create_rs,
&gt; +					dev))) {
&gt; +				free_raid_dev(lc, &amp;rd);
&gt; +				return NULL;
&gt; +			}
&gt; +		} else {
&gt; +			if (!(rs = find_or_alloc_raid_set(lc, rd-&gt;name,
&gt; +						FIND_ALL, rd, &amp;rs_group-&gt;sets,
&gt; +						create_rs, dev))) {
&gt; +				free_raid_dev(lc, &amp;rd);
&gt; +				return NULL;
&gt; +			}
&gt;  		}
&gt;  
&gt; +		rs-&gt;status = s_ok;
&gt; +
&gt;  		/* Save and set to enable dev_sort(). */
&gt;  		private = rd-&gt;private.ptr;
&gt;  		rd-&gt;private.ptr = isw;
&gt; -
&gt;  		list_add_sorted(lc, &amp;rs-&gt;devs, &amp;rd-&gt;devs, dev_sort);
&gt; -
&gt;  		/* Restore. */
&gt;  		rd-&gt;private.ptr = private;
&gt; +
&gt; +		if(is_raid10(isw)) {
&gt; +			ss = join_superset(lc, name, super_created, set_sort,
&gt; +								rs, rd);
&gt; +			return ss;
&gt; +		}
&gt;  	}
&gt;  
&gt;  	return rs_group;
&gt; @@ -504,31 +588,35 @@
&gt;  
&gt;  /* Add an Intel SW RAID device to a set */
&gt;  static struct raid_set *isw_group(struct lib_context *lc,
&gt; -				    struct raid_dev *rd_meta)
&gt; +		struct raid_dev *rd_meta)
&gt;  {
&gt; -	struct raid_set *rs_group;
&gt; +	struct raid_set *rs_group = NULL;
&gt; +	struct isw *isw = META(rd_meta, isw);
&gt;  
&gt;  	if (T_SPARE(rd_meta))
&gt;  		return NULL;
&gt;  
&gt; -	/*
&gt; -	 * Once we get here, an Intel SW RAID disk containing a metadata area
&gt; -	 * with a volume table has been discovered by isw_read.
&gt; -	 */
&gt; -	/* Check if a top level group RAID set already exists. */
&gt; -	if (!(rs_group = find_or_alloc_raid_set(lc, rd_meta-&gt;name, FIND_TOP,
&gt; -				      		rd_meta, LC_RS(lc),
&gt; -						NO_CREATE, NO_CREATE_ARG)))
&gt; -		return NULL;
&gt; +	if(!is_raid10(isw)) {
&gt; +		/*
&gt; +	 	* Once we get here, an Intel SW RAID disk containing a metadata
&gt; +		* area with a volume table has been discovered by isw_read.
&gt; +	 	*/
&gt; +		/* Check if a top level group RAID set already exists. */
&gt; +		if (!(rs_group = find_or_alloc_raid_set(lc, rd_meta-&gt;name,
&gt; +				FIND_TOP, rd_meta, LC_RS(lc),
&gt; +				NO_CREATE, NO_CREATE_ARG)))
&gt; +			return NULL;
&gt;  
&gt; -	/*
&gt; -	 * Add the whole underlying (meta) RAID device to the group set.
&gt; -	 * Sorting is no problem here, because RAID sets and devices will
&gt; -	 * be created for all the Volumes of an ISW set and those need sorting.
&gt; -	 */
&gt; -	rd_meta-&gt;private.ptr = rd_meta-&gt;meta_areas-&gt;area;
&gt; -	list_add_sorted(lc, &amp;rs_group-&gt;devs, &amp;rd_meta-&gt;devs, dev_sort);
&gt; -	rd_meta-&gt;private.ptr = NULL;
&gt; +		/*
&gt; +	 	* Add the whole underlying (meta) RAID device to the group set.
&gt; +	 	* Sorting is no problem here, because RAID sets and devices
&gt; +	 	* will be created for all the Volumes of an ISW set and those
&gt; +		* need sorting.
&gt; +	 	*/
&gt; +		rd_meta-&gt;private.ptr = rd_meta-&gt;meta_areas-&gt;area;
&gt; +		list_add_sorted(lc, &amp;rs_group-&gt;devs, &amp;rd_meta-&gt;devs, dev_sort);
&gt; +		rd_meta-&gt;private.ptr = NULL;
&gt; +	}
&gt;  
&gt;  	/*
&gt;  	 * We need to run through the volume table and create a RAID set and
&gt; @@ -552,17 +640,16 @@
&gt;  }
&gt;  
&gt;  static int check_rd(struct lib_context *lc, struct raid_set *rs,
&gt; -		    struct raid_dev *rd, void *context)
&gt; +				struct raid_dev *rd, void *context)
&gt;  {
&gt;  	struct isw_dev *dev = rd-&gt;private.ptr;
&gt;  
&gt;  	/* FIXME: more status checks ? */
&gt;  	if (dev-&gt;status)
&gt;  		LOG_ERR(lc, 0, &quot;%s device for volume \&quot;%s\&quot; broken on %s &quot;
&gt; -			&quot;in RAID set \&quot;%s\&quot;&quot;,
&gt; -			handler, dev-&gt;volume, rd-&gt;di-&gt;path, rs-&gt;name);
&gt; -
&gt; -	return 1;
&gt; +				&quot;in RAID set \&quot;%s\&quot;&quot;, handler, dev-&gt;volume,
&gt; +				rd-&gt;di-&gt;path, rs-&gt;name);
&gt; +		return 1;
&gt;  }
&gt;  
&gt;  static int _isw_check(struct lib_context *lc, struct raid_set *rs)
&gt; @@ -572,9 +659,14 @@
&gt;  
&gt;  static int isw_check(struct lib_context *lc, struct raid_set *rs)
&gt;  {
&gt; -	return T_GROUP(rs) ? _isw_check(lc, rs) : 0;
&gt; +	/* If it is a stacked set like RAID10 */
&gt; +	if((!T_GROUP(rs)) &amp;&amp; SETS(rs)) {
&gt; +		return check_raid_set(lc, rs, devices, NULL,
&gt; +				NO_CHECK_RD, NULL, handler);
&gt; +	} else {
&gt; +		return T_GROUP(rs) ? _isw_check(lc, rs) : 0;
&gt; +	}
&gt;  }
&gt; -
&gt;  /*
&gt;   * IO error event handler.
&gt;   */
&gt; @@ -585,7 +677,7 @@
&gt;  	struct isw_disk *disk;
&gt;  
&gt;  	if (!(disk = get_disk(lc, rd-&gt;di, isw)))
&gt; -		LOG_ERR(lc, 0, &quot;%s: disk&quot;, handler);
&gt; +			LOG_ERR(lc, 0, &quot;%s: disk&quot;, handler);
&gt;  
&gt;  	/* Avoid write trashing. */
&gt;  	if (S_BROKEN(status(lc, rd)))
&gt; @@ -629,7 +721,7 @@
&gt;  	for (i = 0; i &lt; ISW_FILLERS; i++) {
&gt;  		if (isw-&gt;filler[i])
&gt;          		P(&quot;filler[%i]: %u&quot;, isw,
&gt; -			  isw-&gt;filler[i], i, isw-&gt;filler[i]);
&gt; +					isw-&gt;filler[i], i, isw-&gt;filler[i]);
&gt;  	}
&gt;  
&gt;  	/* Disk table. */
&gt; @@ -744,7 +836,7 @@
&gt;  static struct dmraid_format isw_format = {
&gt;  	.name	= HANDLER,
&gt;  	.descr	= &quot;Intel Software RAID&quot;,
&gt; -	.caps	= &quot;0,1&quot;,
&gt; +	.caps	= &quot;0,1,10&quot;,
&gt;  	.format = FMT_RAID,
&gt;  	.read	= isw_read,
&gt;  	.write	= isw_write,
&gt; @@ -797,5 +889,7 @@
&gt;  	rd-&gt;status = status(lc, rd);
&gt;  	rd-&gt;type   = t_group;
&gt;  
&gt; -        return (rd-&gt;name = name(lc, isw, NULL)) ? 1 : 0;
&gt; +        return (rd-&gt;name = name(lc, rd, 2)) ? 1 : 0;
&gt;  }
&gt; +
&gt; +
&gt; --- 1.0.0.rc14/lib/format/ataraid/isw.h.orig	2006-01-24 07:02:54.000000000 
&gt; -0800
&gt; +++ 1.0.0.rc14/lib/format/ataraid/isw.h	2007-06-27 15:24:19.000000000 -0700
&gt; @@ -68,6 +68,7 @@
&gt;  	uint8_t  raid_level;
&gt;  #define	ISW_T_RAID0	0
&gt;  #define	ISW_T_RAID1	1
&gt; +#define	ISW_T_RAID10	2
&gt;  #define	ISW_T_RAID5	5		// since metadata version 1.2.02 ?
&gt;  	uint8_t  num_members;		// number of member disks
&gt;  	uint8_t  reserved[3];

-- 

Regards,
Heinz    -- The LVM Guy --

*** Software bugs are stupid.
    Nevertheless it needs not so stupid people to solve them ***

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Heinz Mauelshagen                                 Red Hat GmbH
Consulting Development Engineer                   Am Sonnenhang 11
Storage Development                               56242 Marienrachdorf
                                                  Germany
Mauelshagen@xxxxxxxxxx                            PHONE +49  171 7803392
                                                  FAX   +49 2626 924446
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

_______________________________________________
Ataraid-list mailing list
Ataraid-list@xxxxxxxxxx
<a  rel="nofollow" href="https://www.redhat.com/mailman/listinfo/ataraid-list">https://www.redhat.com/mailman/listinfo/ataraid-list</a>
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="02928" href="msg02928.html">RE: [PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format</a></strong>
<ul><li><em>From:</em> Gaston, Jason D</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="02909" href="msg02909.html">[PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format</a></strong>
<ul><li><em>From:</em> Jason Gaston</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg02910.html">RE: create metadata from DMRAID</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg02912.html">Re: dmraid -r -E segfault</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg02909.html">[PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg02928.html">RE: [PATCH dmraid 1.0.0.rc14] isw: raid10 support for isw format</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#02911"><strong>Date</strong></a></li>
<li><a href="threads.html#02911"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/raid/>[Linux&nbsp;RAID]</a>
&nbsp;
&nbsp;
<a href=/lists/dm-devel/>[Linux&nbsp;Device&nbsp;Mapper]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-ide/>[Linux&nbsp;IDE]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-scsi/>[Linux&nbsp;SCSI]</a>
&nbsp;
&nbsp;
<a href=/lists/kernel/>[Kernel]</a>
&nbsp;
&nbsp;
<a href=http://www.ske-art/z/biglist.php>[Linux&nbsp;Books]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-admin/>[Linux&nbsp;Admin]</a>
&nbsp;
&nbsp;
<a href=/lists/gfs/>[GFS]</a>
&nbsp;
&nbsp;
<a href=/lists/rpm/>[RPM]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info/>[Yosemite&nbsp;Campgrounds]</a>
&nbsp;
&nbsp;
<a href=/lists/amd64/>[AMD&nbsp;64]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
