<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic -->
<!--X-From-R13: Oaqevv @nxelvxb &#60;naqevv.anxelvxbNtznvy.pbz> -->
<!--X-Date: Wed, 10 Jul 2019 21:55:00 &#45;0700 -->
<!--X-Message-Id: CAEf4BzZ1XMuhAfVq=2q4xqwuFMqH8WOVU5LbtWPODtNsXK2Lug@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190710080840.2613160&#45;1&#45;andriin@fb.com -->
<!--X-Reference: f6bc7a95&#45;e8e1&#45;eec4&#45;9728&#45;3b9e36b434fa@fb.com -->
<!--X-Reference: CAEf4BzaVouFd=3whC1EjhQ9mit62b&#45;C+NhQuW4RiXW02Rq_1Ug@mail.gmail.com -->
<!--X-Reference: 304d8535&#45;5043&#45;836d&#45;2933&#45;1a5efb7aec72@fb.com -->
<!--X-Reference: CAEf4Bza6Y87C2_Fobj9CwU&#45;2YRTU32S61f8_8CQdhMPenJiJZQ@mail.gmail.com -->
<!--X-Reference: eebd6ac9&#45;d968&#45;9efb&#45;db07&#45;e5d877f7ae4c@fb.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="BPF: Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic &mdash; BPF</title>
<link rel="alternate" type="application/rss+xml" title="BPF" href="//feeds.feedburner.com/packetfilters">
<script type="text/javascript">
var addthis_config = addthis_config||{};
addthis_config.data_track_addressbar = false;
</script>
</head>
<body itemscope itemtype="//schema.org/Article" bgcolor=white vlink=green link=blue>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</h1>
[<a href="msg05217.html">Date Prev</a>][<a href="msg05219.html">Date Next</a>][<a href="msg05216.html">Thread Prev</a>][<a href="msg05217.html">Thread Next</a>][<a href="maillist.html#05218">Date Index</a>][<a href="index.html#05218">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</li>
<li><em>From</em>: Andrii Nakryiko &lt;andrii.nakryiko@xxxxxxxxx&gt;</li>
<li><em>Date</em>: Wed, 10 Jul 2019 21:54:41 -0700</li>
<li><em>Cc</em>: Andrii Nakryiko &lt;andriin@xxxxxx&gt;, Alexei Starovoitov &lt;ast@xxxxxx&gt;,        &quot;daniel@xxxxxxxxxxxxx&quot; &lt;daniel@xxxxxxxxxxxxx&gt;,        &quot;bpf@xxxxxxxxxxxxxxx&quot; &lt;bpf@xxxxxxxxxxxxxxx&gt;,        &quot;netdev@xxxxxxxxxxxxxxx&quot; &lt;netdev@xxxxxxxxxxxxxxx&gt;,        Kernel Team &lt;Kernel-team@xxxxxx&gt;, Martin Lau &lt;kafai@xxxxxx&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg05216.html">eebd6ac9-d968-9efb-db07-e5d877f7ae4c@fb.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Wed, Jul 10, 2019 at 6:53 PM Yonghong Song &lt;yhs@xxxxxx&gt; wrote:
&gt;<i></i>
&gt;<i></i>
&gt;<i></i>
&gt;<i> On 7/10/19 6:45 PM, Andrii Nakryiko wrote:</i>
&gt;<i> &gt; On Wed, Jul 10, 2019 at 5:36 PM Yonghong Song &lt;yhs@xxxxxx&gt; wrote:</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt; On 7/10/19 5:29 PM, Andrii Nakryiko wrote:</i>
&gt;<i> &gt;&gt;&gt; On Wed, Jul 10, 2019 at 5:16 PM Yonghong Song &lt;yhs@xxxxxx&gt; wrote:</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt; On 7/10/19 1:08 AM, Andrii Nakryiko wrote:</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; BTF verifier has Different logic depending on whether we are following</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; a PTR or STRUCT/ARRAY (or something else). This is an optimization to</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; stop early in DFS traversal while resolving BTF types. But it also</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; results in a size resolution bug, when there is a chain, e.g., of PTR -&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; TYPEDEF -&gt; ARRAY, in which case due to being in pointer context ARRAY</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; size won't be resolved, as it is considered to be a sink for pointer,</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; leading to TYPEDEF being in RESOLVED state with zero size, which is</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; completely wrong.</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; Optimization is doubtful, though, as btf_check_all_types() will iterate</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; over all BTF types anyways, so the only saving is a potentially slightly</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; shorter stack. But correctness is more important that tiny savings.</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; This bug manifests itself in rejecting BTF-defined maps that use array</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; typedef as a value type:</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; typedef int array_t[16];</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; struct {</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt;         __uint(type, BPF_MAP_TYPE_ARRAY);</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt;         __type(value, array_t); /* i.e., array_t *value; */</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; } test_map SEC(&quot;.maps&quot;);</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; Fixes: eb3f595dab40 (&quot;bpf: btf: Validate type reference&quot;)</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; Cc: Martin KaFai Lau &lt;kafai@xxxxxx&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;&gt; Signed-off-by: Andrii Nakryiko &lt;andriin@xxxxxx&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt; The change seems okay to me. Currently, looks like intermediate</i>
&gt;<i> &gt;&gt;&gt;&gt; modifier type will carry size = 0 (in the internal data structure).</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt; Yes, which is totally wrong, especially that we use that size in some</i>
&gt;<i> &gt;&gt;&gt; cases to reject map with specified BTF.</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt; If we remove RESOLVE logic, we probably want to double check</i>
&gt;<i> &gt;&gt;&gt;&gt; whether we handle circular types correctly or not. Maybe we will</i>
&gt;<i> &gt;&gt;&gt;&gt; be okay if all self tests pass.</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt; I checked, it does. We'll attempt to add referenced type unless it's a</i>
&gt;<i> &gt;&gt;&gt; &quot;resolve sink&quot; (where size is immediately known) or is already</i>
&gt;<i> &gt;&gt;&gt; resolved (it's state is RESOLVED). In other cases, we'll attempt to</i>
&gt;<i> &gt;&gt;&gt; env_stack_push(), which check that the state of that type is</i>
&gt;<i> &gt;&gt;&gt; NOT_VISITED. If it's RESOLVED or VISITED, it returns -EEXISTS. When</i>
&gt;<i> &gt;&gt;&gt; type is added into the stack, it's resolve state goes from NOT_VISITED</i>
&gt;<i> &gt;&gt;&gt; to VISITED.</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt; So, if there is a loop, then we'll detect it as soon as we'll attempt</i>
&gt;<i> &gt;&gt;&gt; to add the same type onto the stack second time.</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt; I may still be worthwhile to qualify the RESOLVE optimization benefit</i>
&gt;<i> &gt;&gt;&gt;&gt; before removing it.</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt; I don't think there is any, because every type will be visited exactly</i>
&gt;<i> &gt;&gt;&gt; once, due to DFS nature of algorithm. The only difference is that if</i>
&gt;<i> &gt;&gt;&gt; we have a long chain of modifiers, we can technically reach the max</i>
&gt;<i> &gt;&gt;&gt; limit and fail. But at 32 I think it's pretty unrealistic to have such</i>
&gt;<i> &gt;&gt;&gt; a long chain of PTR/TYPEDEF/CONST/VOLATILE/RESTRICTs :)</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt; Another possible change is, for external usage, removing</i>
&gt;<i> &gt;&gt;&gt;&gt; modifiers, before checking the size, something like below.</i>
&gt;<i> &gt;&gt;&gt;&gt; Note that I am not strongly advocating my below patch as</i>
&gt;<i> &gt;&gt;&gt;&gt; it has the same shortcoming that maintained modifier type</i>
&gt;<i> &gt;&gt;&gt;&gt; size may not be correct.</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt; I don't think your patch helps, it can actually confuse things even</i>
&gt;<i> &gt;&gt;&gt; more. It skips modifiers until underlying type is found, but you still</i>
&gt;<i> &gt;&gt;&gt; don't guarantee that at that time that underlying type will have its</i>
&gt;<i> &gt;&gt;&gt; size resolved.</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt; It actually does help. It does not change the internal btf type</i>
&gt;<i> &gt;&gt; traversal algorithms. It only change the implementation of</i>
&gt;<i> &gt;&gt; an external API btf_type_id_size(). Previously, this function</i>
&gt;<i> &gt;&gt; is used by externals and internal btf.c. I broke it into two,</i>
&gt;<i> &gt;&gt; one internal __btf_type_id_size(), and another external</i>
&gt;<i> &gt;&gt; btf_type_id_size(). The external one removes modifier before</i>
&gt;<i> &gt;&gt; finding type size. The external one is typically used only</i>
&gt;<i> &gt;&gt; after btf is validated.</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; Sure, for external callers yes, it solves the problem. But there is</i>
&gt;<i> &gt; deeper problem: we mark modifier types RESOLVED before types they</i>
&gt;<i> &gt; ultimately point to are resolved. Then in all those btf_xxx_resolve()</i>
&gt;<i> &gt; functions we have check:</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; if (!env_type_is_resolve_sink &amp;&amp; !env_type_is_resolved)</i>
&gt;<i> &gt;    return env_stack_push();</i>
&gt;<i> &gt; else {</i>
&gt;<i> &gt;</i>
&gt;<i> &gt;    /* here we assume that we can calculate size of the type */</i>
&gt;<i> &gt;    /* so even if we traverse through all the modifiers and find</i>
&gt;<i> &gt; underlying type */</i>
&gt;<i> &gt;    /* that type will have resolved_size = 0, because we haven't</i>
&gt;<i> &gt; processed it yet */</i>
&gt;<i> &gt;    /* but we will just incorrectly assume that zero is *final* size */</i>
&gt;<i> &gt; }</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; So I think that your patch is still just hiding the problem, not solving it.</i>
&gt;<i></i>
&gt;<i> That is why I am not advocating it.</i>
&gt;<i></i>
&gt;<i> The really long modifier chain (const volatile restrict ...) is rare.</i>
&gt;<i> So I agree removing this RESOLVE logic is okay.</i>

So :) thinking about this a bit more. Stack size is proportional not
to a longest chain of pointers and modifiers, but actually could be as
long as entire type graph (O(N)). So for this approach we'll need to
dynamically resize stack. This is easy to do, but I'm not sure how
much push back I'll get for such change.

But I'll think about doing it differently. The problem is with
resolved_sizes array, we assume it's filled for some types too early.
I'll see if I can get rid of it completely and instead just calculate
that on the fly by relying on resolved_ids. Will post v2 with one of
those approaches.

&gt;<i></i>
&gt;<i> &gt;</i>
&gt;<i> &gt; BTW, I've also identified part of btf_ptr_resolve() logic that can be</i>
&gt;<i> &gt; now safely removed (it's a special case that &quot;restarts&quot; DFS traversal</i>
&gt;<i> &gt; for modifiers, because they could have been prematurely marked</i>
&gt;<i> &gt; resolved). This is another sign that there is something wrong in an</i>
&gt;<i> &gt; algorithm.</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; I'd rather remove unnecessary complexity and fix underlying problem,</i>
&gt;<i> &gt; especially given that there is no performance or correctness penalty.</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; I'll post v2 soon.</i>
&gt;<i></i>
&gt;<i> Sounds good.</i>
&gt;<i></i>
&gt;<i> &gt;</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt; Will go through your other comments later.</i>
&gt;<i> &gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt; diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c</i>
&gt;<i> &gt;&gt;&gt;&gt; index 546ebee39e2a..6f927c3e0a89 100644</i>
&gt;<i> &gt;&gt;&gt;&gt; --- a/kernel/bpf/btf.c</i>
&gt;<i> &gt;&gt;&gt;&gt; +++ b/kernel/bpf/btf.c</i>
&gt;<i> &gt;&gt;&gt;&gt; @@ -620,6 +620,54 @@ static bool btf_type_int_is_regular(const struct</i>
&gt;<i> &gt;&gt;&gt;&gt; btf_type *t)</i>
&gt;<i> &gt;&gt;&gt;&gt;            return true;</i>
&gt;<i> &gt;&gt;&gt;&gt;     }</i>
&gt;<i> &gt;&gt;&gt;&gt;</i>
&gt;<i> &gt;&gt;&gt;&gt; +static const struct btf_type *__btf_type_id_size(const struct btf *btf,</i>
&gt;<i> &gt;&gt;&gt;&gt; +                                                u32 *type_id, u32</i>
&gt;<i> &gt;&gt;&gt;&gt; *ret_size,</i>
&gt;<i> &gt;&gt;&gt;&gt; +                                                bool skip_modifier)</i>
&gt;<i> &gt;&gt;&gt;&gt; +{</i>
&gt;<i> &gt;&gt;&gt;&gt; +       const struct btf_type *size_type;</i>
&gt;<i> &gt;&gt;&gt;&gt; +       u32 size_type_id = *type_id;</i>
&gt;<i> &gt;&gt;&gt;&gt; +       u32 size = 0;</i>
&gt;<i> &gt;&gt;&gt;&gt; +</i>
&gt;<i> &gt;&gt;&gt;&gt; +       size_type = btf_type_by_id(btf, size_type_id);</i>
&gt;<i> &gt;&gt;&gt;&gt; +       if (size_type &amp;&amp; skip_modifier) {</i>
&gt;<i> &gt;&gt;&gt;&gt; +               while (btf_type_is_modifier(size_type))</i>
&gt;<i> &gt;&gt;&gt;&gt; +                       size_type = btf_type_by_id(btf, size_type-&gt;type);</i>
&gt;<i> &gt;&gt;&gt;&gt; +       }</i>
&gt;<i> &gt;&gt;&gt;&gt; +</i>
&gt;<i> &gt;&gt;&gt;&gt; +       if (btf_type_nosize_or_null(size_type))</i>
&gt;<i> &gt;&gt;&gt;&gt; +               return NULL;</i>
&gt;<i> &gt;&gt;&gt;&gt; +</i>
&gt;<i> &gt;&gt;&gt;&gt; +       if (btf_type_has_size(size_type)) {</i>
&gt;<i> &gt;&gt;&gt;&gt; +               size = size_type-&gt;size;</i>
&gt;<i> &gt;&gt;&gt;&gt; +       } else if (btf_type_is_array(size_type)) {</i>
&gt;<i> &gt;&gt;&gt;&gt; +               size = btf-&gt;resolved_sizes[size_type_id];</i>
&gt;<i> &gt;&gt;&gt;&gt; +       } else if (btf_type_is_ptr(size_type)) {</i>
&gt;<i> &gt;&gt;&gt;&gt; +               size = sizeof(void *);</i>
&gt;<i> &gt;&gt;&gt;&gt; +       } else {</i>
&gt;<i> &gt;&gt;&gt;&gt; +               if (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &amp;&amp;</i>
&gt;<i> &gt;&gt;&gt;&gt; +                                !btf_type_is_var(size_type)))</i>
&gt;<i> &gt;&gt;&gt;&gt; +                       return NULL;</i>
&gt;<i> &gt;&gt;&gt;&gt; +</i>
&gt;<i> &gt;&gt;&gt;&gt; +               size = btf-&gt;resolved_sizes[size_type_id];</i>
&gt;<i> &gt;&gt;&gt;&gt; +               size_type_id = btf-&gt;resolved_ids[size_type_id];</i>
&gt;<i> &gt;&gt;&gt;&gt; +               size_type = btf_type_by_id(btf, size_type_id);</i>
&gt;<i> &gt;&gt;&gt;&gt; +               if (btf_type_nosize_or_null(size_type))</i>
&gt;<i> &gt;&gt;&gt;&gt; +                       return NULL;</i>
&gt;<i> &gt;&gt;&gt;&gt; +       }</i>
&gt;<i> &gt;&gt;&gt;&gt; +</i>
&gt;<i> &gt;&gt;&gt;&gt; +       *type_id = size_type_id;</i>
&gt;<i> &gt;&gt;&gt;&gt; +       if (ret_size)</i>
&gt;<i> &gt;&gt;&gt;&gt; +               *ret_size = size;</i>
&gt;<i> &gt;&gt;&gt;&gt; +</i>
&gt;<i> &gt;&gt;&gt;&gt; +       return size_type;</i>
&gt;<i> &gt;&gt;&gt;&gt; +}</i>
&gt;<i> &gt;&gt;&gt;&gt; +</i>
&gt;<i> &gt;&gt; [...]</i>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="05159" href="msg05159.html">[PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Andrii Nakryiko</li></ul></li>
<li><strong><a name="05210" href="msg05210.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Yonghong Song</li></ul></li>
<li><strong><a name="05211" href="msg05211.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Andrii Nakryiko</li></ul></li>
<li><strong><a name="05212" href="msg05212.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Yonghong Song</li></ul></li>
<li><strong><a name="05215" href="msg05215.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Andrii Nakryiko</li></ul></li>
<li><strong><a name="05216" href="msg05216.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Yonghong Song</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg05217.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg05219.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg05216.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg05217.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#05218"><strong>Date</strong></a></li>
<li><a href="index.html#05218"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-samsung-soc/>[Linux&nbsp;Samsung&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-rockchip/>[Linux&nbsp;Rockchip&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-actions/>[Linux&nbsp;Actions&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-snps-arc/>[Linux&nbsp;for&nbsp;Synopsys&nbsp;ARC&nbsp;Processors]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-nfs/>[Linux&nbsp;NFS]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-nilfs/>[Linux&nbsp;NILFS]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-usb/>[Linux&nbsp;USB&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/vfl/>[Video&nbsp;for&nbsp;Linux]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info/>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kernel/>[Linux&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-scsi/>[Linux&nbsp;SCSI]</a>
</font>
</center>
<p>
<hr>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
