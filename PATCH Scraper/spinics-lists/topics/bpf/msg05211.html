<!-- MHonArc v2.6.19 -->
<!--X-Subject: Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic -->
<!--X-From-R13: Oaqevv @nxelvxb &#60;naqevv.anxelvxbNtznvy.pbz> -->
<!--X-Date: Wed, 10 Jul 2019 17:29:37 &#45;0700 -->
<!--X-Message-Id: CAEf4BzaVouFd=3whC1EjhQ9mit62b&#45;C+NhQuW4RiXW02Rq_1Ug@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20190710080840.2613160&#45;1&#45;andriin@fb.com -->
<!--X-Reference: f6bc7a95&#45;e8e1&#45;eec4&#45;9728&#45;3b9e36b434fa@fb.com -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="BPF: Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic &mdash; BPF</title>
<link rel="alternate" type="application/rss+xml" title="BPF" href="//feeds.feedburner.com/packetfilters">
<script type="text/javascript">
var addthis_config = addthis_config||{};
addthis_config.data_track_addressbar = false;
</script>
</head>
<body itemscope itemtype="//schema.org/Article" bgcolor=white vlink=green link=blue>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</h1>
[<a href="msg05210.html">Date Prev</a>][<a href="msg05212.html">Date Next</a>][<a href="msg05210.html">Thread Prev</a>][<a href="msg05212.html">Thread Next</a>][<a href="maillist.html#05211">Date Index</a>][<a href="index.html#05211">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</li>
<li><em>From</em>: Andrii Nakryiko &lt;andrii.nakryiko@xxxxxxxxx&gt;</li>
<li><em>Date</em>: Wed, 10 Jul 2019 17:29:24 -0700</li>
<li><em>Cc</em>: Andrii Nakryiko &lt;andriin@xxxxxx&gt;, Alexei Starovoitov &lt;ast@xxxxxx&gt;,        &quot;daniel@xxxxxxxxxxxxx&quot; &lt;daniel@xxxxxxxxxxxxx&gt;,        &quot;bpf@xxxxxxxxxxxxxxx&quot; &lt;bpf@xxxxxxxxxxxxxxx&gt;,        &quot;netdev@xxxxxxxxxxxxxxx&quot; &lt;netdev@xxxxxxxxxxxxxxx&gt;,        Kernel Team &lt;Kernel-team@xxxxxx&gt;, Martin Lau &lt;kafai@xxxxxx&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg05210.html">f6bc7a95-e8e1-eec4-9728-3b9e36b434fa@fb.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Wed, Jul 10, 2019 at 5:16 PM Yonghong Song &lt;yhs@xxxxxx&gt; wrote:
&gt;<i></i>
&gt;<i></i>
&gt;<i></i>
&gt;<i> On 7/10/19 1:08 AM, Andrii Nakryiko wrote:</i>
&gt;<i> &gt; BTF verifier has Different logic depending on whether we are following</i>
&gt;<i> &gt; a PTR or STRUCT/ARRAY (or something else). This is an optimization to</i>
&gt;<i> &gt; stop early in DFS traversal while resolving BTF types. But it also</i>
&gt;<i> &gt; results in a size resolution bug, when there is a chain, e.g., of PTR -&gt;</i>
&gt;<i> &gt; TYPEDEF -&gt; ARRAY, in which case due to being in pointer context ARRAY</i>
&gt;<i> &gt; size won't be resolved, as it is considered to be a sink for pointer,</i>
&gt;<i> &gt; leading to TYPEDEF being in RESOLVED state with zero size, which is</i>
&gt;<i> &gt; completely wrong.</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; Optimization is doubtful, though, as btf_check_all_types() will iterate</i>
&gt;<i> &gt; over all BTF types anyways, so the only saving is a potentially slightly</i>
&gt;<i> &gt; shorter stack. But correctness is more important that tiny savings.</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; This bug manifests itself in rejecting BTF-defined maps that use array</i>
&gt;<i> &gt; typedef as a value type:</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; typedef int array_t[16];</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; struct {</i>
&gt;<i> &gt;       __uint(type, BPF_MAP_TYPE_ARRAY);</i>
&gt;<i> &gt;       __type(value, array_t); /* i.e., array_t *value; */</i>
&gt;<i> &gt; } test_map SEC(&quot;.maps&quot;);</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; Fixes: eb3f595dab40 (&quot;bpf: btf: Validate type reference&quot;)</i>
&gt;<i> &gt; Cc: Martin KaFai Lau &lt;kafai@xxxxxx&gt;</i>
&gt;<i> &gt; Signed-off-by: Andrii Nakryiko &lt;andriin@xxxxxx&gt;</i>
&gt;<i></i>
&gt;<i> The change seems okay to me. Currently, looks like intermediate</i>
&gt;<i> modifier type will carry size = 0 (in the internal data structure).</i>

Yes, which is totally wrong, especially that we use that size in some
cases to reject map with specified BTF.

&gt;<i></i>
&gt;<i> If we remove RESOLVE logic, we probably want to double check</i>
&gt;<i> whether we handle circular types correctly or not. Maybe we will</i>
&gt;<i> be okay if all self tests pass.</i>

I checked, it does. We'll attempt to add referenced type unless it's a
&quot;resolve sink&quot; (where size is immediately known) or is already
resolved (it's state is RESOLVED). In other cases, we'll attempt to
env_stack_push(), which check that the state of that type is
NOT_VISITED. If it's RESOLVED or VISITED, it returns -EEXISTS. When
type is added into the stack, it's resolve state goes from NOT_VISITED
to VISITED.

So, if there is a loop, then we'll detect it as soon as we'll attempt
to add the same type onto the stack second time.

&gt;<i></i>
&gt;<i> I may still be worthwhile to qualify the RESOLVE optimization benefit</i>
&gt;<i> before removing it.</i>

I don't think there is any, because every type will be visited exactly
once, due to DFS nature of algorithm. The only difference is that if
we have a long chain of modifiers, we can technically reach the max
limit and fail. But at 32 I think it's pretty unrealistic to have such
a long chain of PTR/TYPEDEF/CONST/VOLATILE/RESTRICTs :)

&gt;<i></i>
&gt;<i> Another possible change is, for external usage, removing</i>
&gt;<i> modifiers, before checking the size, something like below.</i>
&gt;<i> Note that I am not strongly advocating my below patch as</i>
&gt;<i> it has the same shortcoming that maintained modifier type</i>
&gt;<i> size may not be correct.</i>

I don't think your patch helps, it can actually confuse things even
more. It skips modifiers until underlying type is found, but you still
don't guarantee that at that time that underlying type will have its
size resolved.

&gt;<i></i>
&gt;<i> diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c</i>
&gt;<i> index 546ebee39e2a..6f927c3e0a89 100644</i>
&gt;<i> --- a/kernel/bpf/btf.c</i>
&gt;<i> +++ b/kernel/bpf/btf.c</i>
&gt;<i> @@ -620,6 +620,54 @@ static bool btf_type_int_is_regular(const struct</i>
&gt;<i> btf_type *t)</i>
&gt;<i>          return true;</i>
&gt;<i>   }</i>
&gt;<i></i>
&gt;<i> +static const struct btf_type *__btf_type_id_size(const struct btf *btf,</i>
&gt;<i> +                                                u32 *type_id, u32</i>
&gt;<i> *ret_size,</i>
&gt;<i> +                                                bool skip_modifier)</i>
&gt;<i> +{</i>
&gt;<i> +       const struct btf_type *size_type;</i>
&gt;<i> +       u32 size_type_id = *type_id;</i>
&gt;<i> +       u32 size = 0;</i>
&gt;<i> +</i>
&gt;<i> +       size_type = btf_type_by_id(btf, size_type_id);</i>
&gt;<i> +       if (size_type &amp;&amp; skip_modifier) {</i>
&gt;<i> +               while (btf_type_is_modifier(size_type))</i>
&gt;<i> +                       size_type = btf_type_by_id(btf, size_type-&gt;type);</i>
&gt;<i> +       }</i>
&gt;<i> +</i>
&gt;<i> +       if (btf_type_nosize_or_null(size_type))</i>
&gt;<i> +               return NULL;</i>
&gt;<i> +</i>
&gt;<i> +       if (btf_type_has_size(size_type)) {</i>
&gt;<i> +               size = size_type-&gt;size;</i>
&gt;<i> +       } else if (btf_type_is_array(size_type)) {</i>
&gt;<i> +               size = btf-&gt;resolved_sizes[size_type_id];</i>
&gt;<i> +       } else if (btf_type_is_ptr(size_type)) {</i>
&gt;<i> +               size = sizeof(void *);</i>
&gt;<i> +       } else {</i>
&gt;<i> +               if (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &amp;&amp;</i>
&gt;<i> +                                !btf_type_is_var(size_type)))</i>
&gt;<i> +                       return NULL;</i>
&gt;<i> +</i>
&gt;<i> +               size = btf-&gt;resolved_sizes[size_type_id];</i>
&gt;<i> +               size_type_id = btf-&gt;resolved_ids[size_type_id];</i>
&gt;<i> +               size_type = btf_type_by_id(btf, size_type_id);</i>
&gt;<i> +               if (btf_type_nosize_or_null(size_type))</i>
&gt;<i> +                       return NULL;</i>
&gt;<i> +       }</i>
&gt;<i> +</i>
&gt;<i> +       *type_id = size_type_id;</i>
&gt;<i> +       if (ret_size)</i>
&gt;<i> +               *ret_size = size;</i>
&gt;<i> +</i>
&gt;<i> +       return size_type;</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i> +const struct btf_type *btf_type_id_size(const struct btf *btf,</i>
&gt;<i> +                                       u32 *type_id, u32 *ret_size)</i>
&gt;<i> +{</i>
&gt;<i> +       return __btf_type_id_size(btf, type_id, ret_size, true);</i>
&gt;<i> +}</i>
&gt;<i> +</i>
&gt;<i>   /*</i>
&gt;<i>    * Check that given struct member is a regular int with expected</i>
&gt;<i>    * offset and size.</i>
&gt;<i> @@ -633,7 +681,7 @@ bool btf_member_is_reg_int(const struct btf *btf,</i>
&gt;<i> const struct btf_type *s,</i>
&gt;<i>          u8 nr_bits;</i>
&gt;<i></i>
&gt;<i>          id = m-&gt;type;</i>
&gt;<i> -       t = btf_type_id_size(btf, &amp;id, NULL);</i>
&gt;<i> +       t = __btf_type_id_size(btf, &amp;id, NULL, false);</i>
&gt;<i>          if (!t || !btf_type_is_int(t))</i>
&gt;<i>                  return false;</i>
&gt;<i></i>
&gt;<i> @@ -1051,42 +1099,6 @@ static const struct btf_type</i>
&gt;<i> *btf_type_id_resolve(const struct btf *btf,</i>
&gt;<i>          return btf_type_by_id(btf, *type_id);</i>
&gt;<i>   }</i>
&gt;<i></i>
&gt;<i> -const struct btf_type *btf_type_id_size(const struct btf *btf,</i>
&gt;<i> -                                       u32 *type_id, u32 *ret_size)</i>
&gt;<i> -{</i>
&gt;<i> -       const struct btf_type *size_type;</i>
&gt;<i> -       u32 size_type_id = *type_id;</i>
&gt;<i> -       u32 size = 0;</i>
&gt;<i> -</i>
&gt;<i> -       size_type = btf_type_by_id(btf, size_type_id);</i>
&gt;<i> -       if (btf_type_nosize_or_null(size_type))</i>
&gt;<i> -               return NULL;</i>
&gt;<i> -</i>
&gt;<i> -       if (btf_type_has_size(size_type)) {</i>
&gt;<i> -               size = size_type-&gt;size;</i>
&gt;<i> -       } else if (btf_type_is_array(size_type)) {</i>
&gt;<i> -               size = btf-&gt;resolved_sizes[size_type_id];</i>
&gt;<i> -       } else if (btf_type_is_ptr(size_type)) {</i>
&gt;<i> -               size = sizeof(void *);</i>
&gt;<i> -       } else {</i>
&gt;<i> -               if (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &amp;&amp;</i>
&gt;<i> -                                !btf_type_is_var(size_type)))</i>
&gt;<i> -                       return NULL;</i>
&gt;<i> -</i>
&gt;<i> -               size = btf-&gt;resolved_sizes[size_type_id];</i>
&gt;<i> -               size_type_id = btf-&gt;resolved_ids[size_type_id];</i>
&gt;<i> -               size_type = btf_type_by_id(btf, size_type_id);</i>
&gt;<i> -               if (btf_type_nosize_or_null(size_type))</i>
&gt;<i> -                       return NULL;</i>
&gt;<i> -       }</i>
&gt;<i> -</i>
&gt;<i> -       *type_id = size_type_id;</i>
&gt;<i> -       if (ret_size)</i>
&gt;<i> -               *ret_size = size;</i>
&gt;<i> -</i>
&gt;<i> -       return size_type;</i>
&gt;<i> -}</i>
&gt;<i> -</i>
&gt;<i>   static int btf_df_check_member(struct btf_verifier_env *env,</i>
&gt;<i>                                 const struct btf_type *struct_type,</i>
&gt;<i>                                 const struct btf_member *member,</i>
&gt;<i> @@ -1489,7 +1501,7 @@ static int btf_modifier_check_member(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>          struct btf_member resolved_member;</i>
&gt;<i>          struct btf *btf = env-&gt;btf;</i>
&gt;<i></i>
&gt;<i> -       resolved_type = btf_type_id_size(btf, &amp;resolved_type_id, NULL);</i>
&gt;<i> +       resolved_type = __btf_type_id_size(btf, &amp;resolved_type_id, NULL,</i>
&gt;<i> false);</i>
&gt;<i>          if (!resolved_type) {</i>
&gt;<i>                  btf_verifier_log_member(env, struct_type, member,</i>
&gt;<i>                                          &quot;Invalid member&quot;);</i>
&gt;<i> @@ -1514,7 +1526,7 @@ static int btf_modifier_check_kflag_member(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>          struct btf_member resolved_member;</i>
&gt;<i>          struct btf *btf = env-&gt;btf;</i>
&gt;<i></i>
&gt;<i> -       resolved_type = btf_type_id_size(btf, &amp;resolved_type_id, NULL);</i>
&gt;<i> +       resolved_type = __btf_type_id_size(btf, &amp;resolved_type_id, NULL,</i>
&gt;<i> false);</i>
&gt;<i>          if (!resolved_type) {</i>
&gt;<i>                  btf_verifier_log_member(env, struct_type, member,</i>
&gt;<i>                                          &quot;Invalid member&quot;);</i>
&gt;<i> @@ -1620,7 +1632,7 @@ static int btf_modifier_resolve(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>           * save us a few type-following when we use it later (e.g. in</i>
&gt;<i>           * pretty print).</i>
&gt;<i>           */</i>
&gt;<i> -       if (!btf_type_id_size(btf, &amp;next_type_id, &amp;next_type_size)) {</i>
&gt;<i> +       if (!__btf_type_id_size(btf, &amp;next_type_id, &amp;next_type_size,</i>
&gt;<i> false)) {</i>
&gt;<i>                  if (env_type_is_resolved(env, next_type_id))</i>
&gt;<i>                          next_type = btf_type_id_resolve(btf,</i>
&gt;<i> &amp;next_type_id);</i>
&gt;<i></i>
&gt;<i> @@ -1675,7 +1687,7 @@ static int btf_var_resolve(struct btf_verifier_env</i>
&gt;<i> *env,</i>
&gt;<i>           * forward types or similar that would resolve to size of</i>
&gt;<i>           * zero is allowed.</i>
&gt;<i>           */</i>
&gt;<i> -       if (!btf_type_id_size(btf, &amp;next_type_id, &amp;next_type_size)) {</i>
&gt;<i> +       if (!__btf_type_id_size(btf, &amp;next_type_id, &amp;next_type_size,</i>
&gt;<i> false)) {</i>
&gt;<i>                  btf_verifier_log_type(env, v-&gt;t, &quot;Invalid type_id&quot;);</i>
&gt;<i>                  return -EINVAL;</i>
&gt;<i>          }</i>
&gt;<i> @@ -1725,7 +1737,7 @@ static int btf_ptr_resolve(struct btf_verifier_env</i>
&gt;<i> *env,</i>
&gt;<i>                                                resolved_type_id);</i>
&gt;<i>          }</i>
&gt;<i></i>
&gt;<i> -       if (!btf_type_id_size(btf, &amp;next_type_id, NULL)) {</i>
&gt;<i> +       if (!__btf_type_id_size(btf, &amp;next_type_id, NULL, false)) {</i>
&gt;<i>                  if (env_type_is_resolved(env, next_type_id))</i>
&gt;<i>                          next_type = btf_type_id_resolve(btf,</i>
&gt;<i> &amp;next_type_id);</i>
&gt;<i></i>
&gt;<i> @@ -1851,7 +1863,7 @@ static int btf_array_check_member(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>          }</i>
&gt;<i></i>
&gt;<i>          array_type_id = member-&gt;type;</i>
&gt;<i> -       btf_type_id_size(btf, &amp;array_type_id, &amp;array_size);</i>
&gt;<i> +       __btf_type_id_size(btf, &amp;array_type_id, &amp;array_size, false);</i>
&gt;<i>          struct_size = struct_type-&gt;size;</i>
&gt;<i>          bytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);</i>
&gt;<i>          if (struct_size - bytes_offset &lt; array_size) {</i>
&gt;<i> @@ -1938,7 +1950,7 @@ static int btf_array_resolve(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>              !env_type_is_resolved(env, index_type_id))</i>
&gt;<i>                  return env_stack_push(env, index_type, index_type_id);</i>
&gt;<i></i>
&gt;<i> -       index_type = btf_type_id_size(btf, &amp;index_type_id, NULL);</i>
&gt;<i> +       index_type = __btf_type_id_size(btf, &amp;index_type_id, NULL, false);</i>
&gt;<i>          if (!index_type || !btf_type_is_int(index_type) ||</i>
&gt;<i>              !btf_type_int_is_regular(index_type)) {</i>
&gt;<i>                  btf_verifier_log_type(env, v-&gt;t, &quot;Invalid index&quot;);</i>
&gt;<i> @@ -1959,7 +1971,7 @@ static int btf_array_resolve(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>              !env_type_is_resolved(env, elem_type_id))</i>
&gt;<i>                  return env_stack_push(env, elem_type, elem_type_id);</i>
&gt;<i></i>
&gt;<i> -       elem_type = btf_type_id_size(btf, &amp;elem_type_id, &amp;elem_size);</i>
&gt;<i> +       elem_type = __btf_type_id_size(btf, &amp;elem_type_id, &amp;elem_size,</i>
&gt;<i> false);</i>
&gt;<i>          if (!elem_type) {</i>
&gt;<i>                  btf_verifier_log_type(env, v-&gt;t, &quot;Invalid elem&quot;);</i>
&gt;<i>                  return -EINVAL;</i>
&gt;<i> @@ -2000,7 +2012,7 @@ static void btf_array_seq_show(const struct btf</i>
&gt;<i> *btf, const struct btf_type *t,</i>
&gt;<i>          u32 i, elem_size, elem_type_id;</i>
&gt;<i></i>
&gt;<i>          elem_type_id = array-&gt;type;</i>
&gt;<i> -       elem_type = btf_type_id_size(btf, &amp;elem_type_id, &amp;elem_size);</i>
&gt;<i> +       elem_type = __btf_type_id_size(btf, &amp;elem_type_id, &amp;elem_size,</i>
&gt;<i> false);</i>
&gt;<i>          elem_ops = btf_type_ops(elem_type);</i>
&gt;<i>          seq_puts(m, &quot;[&quot;);</i>
&gt;<i>          for (i = 0; i &lt; array-&gt;nelems; i++) {</i>
&gt;<i> @@ -2732,7 +2744,7 @@ static int btf_datasec_resolve(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>                  }</i>
&gt;<i></i>
&gt;<i>                  type_id = var_type-&gt;type;</i>
&gt;<i> -               if (!btf_type_id_size(btf, &amp;type_id, &amp;type_size)) {</i>
&gt;<i> +               if (!__btf_type_id_size(btf, &amp;type_id, &amp;type_size, false)) {</i>
&gt;<i>                          btf_verifier_log_vsi(env, v-&gt;t, vsi, &quot;Invalid</i>
&gt;<i> type&quot;);</i>
&gt;<i>                          return -EINVAL;</i>
&gt;<i>                  }</i>
&gt;<i> @@ -2813,7 +2825,7 @@ static int btf_func_proto_check(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>                  }</i>
&gt;<i></i>
&gt;<i>                  /* Ensure the return type is a type that has a size */</i>
&gt;<i> -               if (!btf_type_id_size(btf, &amp;ret_type_id, NULL)) {</i>
&gt;<i> +               if (!__btf_type_id_size(btf, &amp;ret_type_id, NULL, false)) {</i>
&gt;<i>                          btf_verifier_log_type(env, t, &quot;Invalid return</i>
&gt;<i> type&quot;);</i>
&gt;<i>                          return -EINVAL;</i>
&gt;<i>                  }</i>
&gt;<i> @@ -2861,7 +2873,7 @@ static int btf_func_proto_check(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>                                  break;</i>
&gt;<i>                  }</i>
&gt;<i></i>
&gt;<i> -               if (!btf_type_id_size(btf, &amp;arg_type_id, NULL)) {</i>
&gt;<i> +               if (!__btf_type_id_size(btf, &amp;arg_type_id, NULL, false)) {</i>
&gt;<i>                          btf_verifier_log_type(env, t, &quot;Invalid arg#%u&quot;,</i>
&gt;<i> i + 1);</i>
&gt;<i>                          err = -EINVAL;</i>
&gt;<i>                          break;</i>
&gt;<i> @@ -3014,7 +3026,7 @@ static bool btf_resolve_valid(struct</i>
&gt;<i> btf_verifier_env *env,</i>
&gt;<i>                  u32 elem_type_id = array-&gt;type;</i>
&gt;<i>                  u32 elem_size;</i>
&gt;<i></i>
&gt;<i> -               elem_type = btf_type_id_size(btf, &amp;elem_type_id,</i>
&gt;<i> &amp;elem_size);</i>
&gt;<i> +               elem_type = __btf_type_id_size(btf, &amp;elem_type_id,</i>
&gt;<i> &amp;elem_size, false);</i>
&gt;<i>                  return elem_type &amp;&amp; !btf_type_is_modifier(elem_type) &amp;&amp;</i>
&gt;<i>                          (array-&gt;nelems * elem_size ==</i>
&gt;<i>                           btf-&gt;resolved_sizes[type_id]);</i>
&gt;<i></i>
&gt;<i></i>
&gt;<i> &gt; ---</i>
&gt;<i> &gt;   kernel/bpf/btf.c | 42 +++---------------------------------------</i>
&gt;<i> &gt;   1 file changed, 3 insertions(+), 39 deletions(-)</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c</i>
&gt;<i> &gt; index cad09858a5f2..c68c7e73b0d1 100644</i>
&gt;<i> &gt; --- a/kernel/bpf/btf.c</i>
&gt;<i> &gt; +++ b/kernel/bpf/btf.c</i>
&gt;<i> &gt; @@ -231,14 +231,6 @@ enum visit_state {</i>
&gt;<i> &gt;       RESOLVED,</i>
&gt;<i> &gt;   };</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; -enum resolve_mode {</i>
&gt;<i> &gt; -     RESOLVE_TBD,    /* To Be Determined */</i>
&gt;<i> &gt; -     RESOLVE_PTR,    /* Resolving for Pointer */</i>
&gt;<i> &gt; -     RESOLVE_STRUCT_OR_ARRAY,        /* Resolving for struct/union</i>
&gt;<i> &gt; -                                      * or array</i>
&gt;<i> &gt; -                                      */</i>
&gt;<i> &gt; -};</i>
&gt;<i> &gt; -</i>
&gt;<i> &gt;   #define MAX_RESOLVE_DEPTH 32</i>
&gt;<i> &gt;</i>
&gt;<i> &gt;   struct btf_sec_info {</i>
&gt;<i> &gt; @@ -254,7 +246,6 @@ struct btf_verifier_env {</i>
&gt;<i> &gt;       u32 log_type_id;</i>
&gt;<i> &gt;       u32 top_stack;</i>
&gt;<i> &gt;       enum verifier_phase phase;</i>
&gt;<i> &gt; -     enum resolve_mode resolve_mode;</i>
&gt;<i> &gt;   };</i>
&gt;<i> &gt;</i>
&gt;<i> &gt;   static const char * const btf_kind_str[NR_BTF_KINDS] = {</i>
&gt;<i> &gt; @@ -964,26 +955,7 @@ static void btf_verifier_env_free(struct btf_verifier_env *env)</i>
&gt;<i> &gt;   static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,</i>
&gt;<i> &gt;                                    const struct btf_type *next_type)</i>
&gt;<i> &gt;   {</i>
&gt;<i> &gt; -     switch (env-&gt;resolve_mode) {</i>
&gt;<i> &gt; -     case RESOLVE_TBD:</i>
&gt;<i> &gt; -             /* int, enum or void is a sink */</i>
&gt;<i> &gt; -             return !btf_type_needs_resolve(next_type);</i>
&gt;<i> &gt; -     case RESOLVE_PTR:</i>
&gt;<i> &gt; -             /* int, enum, void, struct, array, func or func_proto is a sink</i>
&gt;<i> &gt; -              * for ptr</i>
&gt;<i> &gt; -              */</i>
&gt;<i> &gt; -             return !btf_type_is_modifier(next_type) &amp;&amp;</i>
&gt;<i> &gt; -                     !btf_type_is_ptr(next_type);</i>
&gt;<i> &gt; -     case RESOLVE_STRUCT_OR_ARRAY:</i>
&gt;<i> &gt; -             /* int, enum, void, ptr, func or func_proto is a sink</i>
&gt;<i> &gt; -              * for struct and array</i>
&gt;<i> &gt; -              */</i>
&gt;<i> &gt; -             return !btf_type_is_modifier(next_type) &amp;&amp;</i>
&gt;<i> &gt; -                     !btf_type_is_array(next_type) &amp;&amp;</i>
&gt;<i> &gt; -                     !btf_type_is_struct(next_type);</i>
&gt;<i> &gt; -     default:</i>
&gt;<i> &gt; -             BUG();</i>
&gt;<i> &gt; -     }</i>
&gt;<i> &gt; +     return !btf_type_needs_resolve(next_type);</i>
&gt;<i> &gt;   }</i>
&gt;<i> &gt;</i>
&gt;<i> &gt;   static bool env_type_is_resolved(const struct btf_verifier_env *env,</i>
&gt;<i> &gt; @@ -1010,13 +982,6 @@ static int env_stack_push(struct btf_verifier_env *env,</i>
&gt;<i> &gt;       v-&gt;type_id = type_id;</i>
&gt;<i> &gt;       v-&gt;next_member = 0;</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; -     if (env-&gt;resolve_mode == RESOLVE_TBD) {</i>
&gt;<i> &gt; -             if (btf_type_is_ptr(t))</i>
&gt;<i> &gt; -                     env-&gt;resolve_mode = RESOLVE_PTR;</i>
&gt;<i> &gt; -             else if (btf_type_is_struct(t) || btf_type_is_array(t))</i>
&gt;<i> &gt; -                     env-&gt;resolve_mode = RESOLVE_STRUCT_OR_ARRAY;</i>
&gt;<i> &gt; -     }</i>
&gt;<i> &gt; -</i>
&gt;<i> &gt;       return 0;</i>
&gt;<i> &gt;   }</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; @@ -1038,7 +1003,7 @@ static void env_stack_pop_resolved(struct btf_verifier_env *env,</i>
&gt;<i> &gt;       env-&gt;visit_states[type_id] = RESOLVED;</i>
&gt;<i> &gt;   }</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; -static const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)</i>
&gt;<i> &gt; +static const struct resolve_vertex *env_stack_peek(struct btf_verifier_env *env)</i>
&gt;<i> &gt;   {</i>
&gt;<i> &gt;       return env-&gt;top_stack ? &amp;env-&gt;stack[env-&gt;top_stack - 1] : NULL;</i>
&gt;<i> &gt;   }</i>
&gt;<i> &gt; @@ -3030,9 +2995,8 @@ static int btf_resolve(struct btf_verifier_env *env,</i>
&gt;<i> &gt;       const struct resolve_vertex *v;</i>
&gt;<i> &gt;       int err = 0;</i>
&gt;<i> &gt;</i>
&gt;<i> &gt; -     env-&gt;resolve_mode = RESOLVE_TBD;</i>
&gt;<i> &gt;       env_stack_push(env, t, type_id);</i>
&gt;<i> &gt; -     while (!err &amp;&amp; (v = env_stack_peak(env))) {</i>
&gt;<i> &gt; +     while (!err &amp;&amp; (v = env_stack_peek(env))) {</i>
&gt;<i> &gt;               env-&gt;log_type_id = v-&gt;type_id;</i>
&gt;<i> &gt;               err = btf_type_ops(v-&gt;t)-&gt;resolve(env, v);</i>
&gt;<i> &gt;       }</i>
&gt;<i> &gt;</i>


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="05212" href="msg05212.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Yonghong Song</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="05159" href="msg05159.html">[PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Andrii Nakryiko</li></ul></li>
<li><strong><a name="05210" href="msg05210.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
<ul><li><em>From:</em> Yonghong Song</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg05210.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg05212.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg05210.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg05212.html">Re: [PATCH bpf] bpf: fix BTF verifier size resolution logic</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#05211"><strong>Date</strong></a></li>
<li><a href="index.html#05211"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-samsung-soc/>[Linux&nbsp;Samsung&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-rockchip/>[Linux&nbsp;Rockchip&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-actions/>[Linux&nbsp;Actions&nbsp;SoC]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-snps-arc/>[Linux&nbsp;for&nbsp;Synopsys&nbsp;ARC&nbsp;Processors]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-nfs/>[Linux&nbsp;NFS]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-nilfs/>[Linux&nbsp;NILFS]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-usb/>[Linux&nbsp;USB&nbsp;Devel]</a>
&nbsp;
&nbsp;
<a href=/lists/vfl/>[Video&nbsp;for&nbsp;Linux]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info/>[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=/lists/kernel/>[Linux&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-scsi/>[Linux&nbsp;SCSI]</a>
</font>
</center>
<p>
<hr>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
