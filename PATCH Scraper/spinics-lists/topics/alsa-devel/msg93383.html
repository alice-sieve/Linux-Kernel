<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH RFC V3] ALSA: usb&#45;audio: Scarlett Gen 2 mixer	interface -->
<!--X-From-R13: "Urbsserl R. Praargg" &#60;tNo4.ih> -->
<!--X-Date: Sun, 30 Jun 2019 08:01:38 &#45;0700 -->
<!--X-Message-Id: 20190630150025.GA12073@b4.vu -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="[PATCH RFC V3] ALSA: usb-audio: Scarlett Gen 2 mixer	interface &mdash; ALSA Devel">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>[PATCH RFC V3] ALSA: usb-audio: Scarlett Gen 2 mixer	interface &mdash; ALSA Devel</title>
<link rel="alternate" type="application/rss+xml" title="ALSA Devel" href="//feedproxy.google.com/AlsaDevel">
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:9580497365" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="25" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH RFC V3] ALSA: usb-audio: Scarlett Gen 2 mixer	interface</h1>
[<a href="msg93382.html">Date Prev</a>][<a href="msg93384.html">Date Next</a>][<a href="msg93380.html">Thread Prev</a>][<a href="msg93388.html">Thread Next</a>][<a href="maillist.html#93383">Date Index</a>][<a href="threads.html#93383">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: alsa-devel@xxxxxxxxxxxxxxxx</li>
<li><em>Subject</em>: [PATCH RFC V3] ALSA: usb-audio: Scarlett Gen 2 mixer	interface</li>
<li><em>From</em>: &quot;Geoffrey D. Bennett&quot; &lt;g@xxxxx&gt;</li>
<li><em>Date</em>: Mon, 1 Jul 2019 00:30:25 +0930</li>
<li><em>Cc</em>: Takashi Iwai &lt;tiwai@xxxxxxx&gt;</li>
<li><em>User-agent</em>: Mutt/1.4.2.2i</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Add mixer quirk for the Focusrite Scarlett 6i6, 18i8, and 18i20 Gen 2
audio interfaces. Although the interfaces are USB compliant,
additional input/output level controls and hardware routing/mixing
functionality are available using proprietary USB requests.

Signed-off-by: Geoffrey D. Bennett &lt;g@xxxxx&gt;
---
Hi all,

This patch adds the following controls for the Scarlett 6i6, 18i8, and
18i20 Gen 2:
- Master volume knob indicator (18i20 only)
- Mute and dim switches (18i20 only)
- Volume controls for the analogue HW outputs
- HW/SW volume switches for the 10 analogue HW outputs (18i20 only)
- Line Level/Instrument Level and Pad controls (6i6 and 18i8 only)
- Output mux (where the sound for the HW outputs comes from; defaults
  to PCM outputs)
- Capture mux (where the sound for PCM recording comes from; defaults
  to HW inputs)
- Matrix mux (where the sound going into the mixer comes from; 18
  inputs default off)
- Mixer matrix (18 inputs * 10 outputs = 180 controls)
- Level meters

Changes since v1:
- Add support for the Scarlett 18i8 Gen 2
- Save configuration parameters to NVRAM
- Implemented feedback from Takashi's email 24/Apr/2019
- Moved private field from struct snd_usb_audio to struct
  usb_mixer_interface
- Added timer and buffer fields to struct usb_mixer_interface
- Other small code fixes/cleanups/improvements

Changes since v2:
- Add support for the Scarlett 6i6 Gen 2
- Add support for controlling the mute/dim switches (18i20 only)
- Implemented feedback from Takashi's email 29/Apr/2019: One pointer
  field private_data and one function pointer private_free. Replaced
  timer with delayed work (thanks for that suggestion; it makes the
  code a *lot* simpler!).
- The new functionality is disabled by default as there were reports
  of some Gen 2 devices not responding to the initialisation sequence
  and hanging. Added module parameter &quot;scarlett_gen2_mixer_enable&quot;.
  If this parameter is not set, logs a message &quot;Focusrite Scarlett Gen
  2 Mixer Driver disabled; use options snd_usb_audio
  scarlett_gen2_mixer_enable=1 to enable and report any issues to
  g@xxxxx&quot;.

Outstanding issues/questions:

- Takashi, you wrote last time &quot;Also, the delayed work needs to be
  canceled or flushed at PM suspend callback as well as
  disconnecting.&quot; I'm not sure why it should be cancelled; is it not
  okay to do on resume? But I tested suspending while the delayed work
  was waiting and it seemed like the delayed work was cancelled
  anyway. Probably better to do a flush on suspend though; should this
  be done through a hook like:

diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index 2444737a14b2..1572a89267c6 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -3547,6 +3547,8 @@ static int snd_usb_mixer_activate(struct usb_mixer_interface *mixer)
 int snd_usb_mixer_suspend(struct usb_mixer_interface *mixer)
 {
        snd_usb_mixer_inactivate(mixer);
+       if (mixer-&gt;private_suspend)
+               mixer-&gt;private_suspend(mixer);
        return 0;
 }
 
diff --git a/sound/usb/mixer.h b/sound/usb/mixer.h
index fa6e216a06f0..d94c688c65f7 100644
--- a/sound/usb/mixer.h
+++ b/sound/usb/mixer.h
@@ -28,6 +28,7 @@ struct usb_mixer_interface {
 
        void *private_data;
        void (*private_free)(struct usb_mixer_interface *private_data);
+       void (*private_suspend)(struct usb_mixer_interface *);
 };
 
 #define MAX_CHANNELS   16      /* max logical channels */

  ?

Thanks,
Geoffrey.

diff --git a/sound/usb/Makefile b/sound/usb/Makefile
index d330f74c90e6..8cf7081e17cb 100644
--- a/sound/usb/Makefile
+++ b/sound/usb/Makefile
@@ -11,6 +11,7 @@ snd-usb-audio-objs := 	card.o \
 			mixer.o \
 			mixer_quirks.o \
 			mixer_scarlett.o \
+			mixer_scarlett_gen2.o \
 			mixer_us16x08.o \
 			pcm.o \
 			power.o \
diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index 53dccbfe392b..2444737a14b2 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -3518,6 +3518,8 @@ void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)
 		usb_kill_urb(mixer-&gt;urb);
 	if (mixer-&gt;rc_urb)
 		usb_kill_urb(mixer-&gt;rc_urb);
+	if (mixer-&gt;private_free)
+		mixer-&gt;private_free(mixer);
 	mixer-&gt;disconnected = true;
 }
 
diff --git a/sound/usb/mixer.h b/sound/usb/mixer.h
index 3d12af8bf191..fa6e216a06f0 100644
--- a/sound/usb/mixer.h
+++ b/sound/usb/mixer.h
@@ -25,6 +25,9 @@ struct usb_mixer_interface {
 	u8 rc_buffer[6];
 
 	bool disconnected;
+
+	void *private_data;
+	void (*private_free)(struct usb_mixer_interface *);
 };
 
 #define MAX_CHANNELS	16	/* max logical channels */
diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c
index a751a18ca4c2..1ae00a1e6c47 100644
--- a/sound/usb/mixer_quirks.c
+++ b/sound/usb/mixer_quirks.c
@@ -45,6 +45,7 @@
 #include &quot;mixer.h&quot;
 #include &quot;mixer_quirks.h&quot;
 #include &quot;mixer_scarlett.h&quot;
+#include &quot;mixer_scarlett_gen2.h&quot;
 #include &quot;mixer_us16x08.h&quot;
 #include &quot;helper.h&quot;
 
@@ -2271,6 +2272,12 @@ int snd_usb_mixer_apply_create_quirk(struct usb_mixer_interface *mixer)
 		err = snd_scarlett_controls_create(mixer);
 		break;
 
+	case USB_ID(0x1235, 0x8203): /* Focusrite Scarlett 6i6 2nd Gen */
+	case USB_ID(0x1235, 0x8204): /* Focusrite Scarlett 18i8 2nd Gen */
+	case USB_ID(0x1235, 0x8201): /* Focusrite Scarlett 18i20 2nd Gen */
+		err = snd_scarlett_gen2_controls_create(mixer);
+		break;
+
 	case USB_ID(0x041e, 0x323b): /* Creative Sound Blaster E1 */
 		err = snd_soundblaster_e1_switch_create(mixer);
 		break;
diff --git a/sound/usb/mixer_scarlett_gen2.c b/sound/usb/mixer_scarlett_gen2.c
new file mode 100644
index 000000000000..05a8e47a85f4
--- /dev/null
+++ b/sound/usb/mixer_scarlett_gen2.c
@@ -0,0 +1,2078 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *   Focusrite Scarlett 6i6/18i8/18i20 Gen 2 Driver for ALSA
+ *
+ *   Copyright (c) 2018-2019 by Geoffrey D. Bennett &lt;g at b4.vu&gt;
+ *
+ *   Based on the Scarlett (Gen 1) Driver for ALSA:
+ *
+ *   Copyright (c) 2013 by Tobias Hoffmann
+ *   Copyright (c) 2013 by Robin Gareus &lt;robin at gareus.org&gt;
+ *   Copyright (c) 2002 by Takashi Iwai &lt;tiwai at suse.de&gt;
+ *   Copyright (c) 2014 by Chris J Arges &lt;chris.j.arges at canonical.com&gt;
+ *
+ *   Many codes borrowed from audio.c by
+ *     Alan Cox (alan at lxorguk.ukuu.org.uk)
+ *     Thomas Sailer (sailer at ife.ee.ethz.ch)
+ *
+ *   Code cleanup:
+ *   David Henningsson &lt;david.henningsson at canonical.com&gt;
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ */
+
+/* Mixer Interface for the Focusrite Scarlett 6i6/18i8/18i20 Gen 2 audio
+ * interface. Based on the Gen 1 driver and rewritten.
+ */
+
+/* The protocol was reverse engineered by looking at the communication
+ * between Focusrite Control 2.3.4 and the Focusrite(R) Scarlett 18i20
+ * (firmware 1083) using usbmon in July-August 2018.
+ *
+ * Scarlett 18i8 support added in April 2019.
+ *
+ * Scarlett 6i6 support added in June 2019 (thanks to Martin Wittmann
+ * for providing usbmon output and testing).
+ *
+ * This ALSA mixer gives access to:
+ *  - input, output, mixer-matrix muxes
+ *  - 18x10 mixer-matrix gain stages
+ *  - gain/volume controls
+ *  - level meters
+ *  - line/inst level and pad controls
+ *
+ * &lt;ditaa&gt;
+ *    /--------------\    18chn            20chn     /--------------\
+ *    | Hardware  in +--+------\    /-------------+--+ ALSA PCM out |
+ *    \--------------/  |      |    |             |  \--------------/
+ *                      |      |    |    /-----\  |
+ *                      |      |    |    |     |  |
+ *                      |      v    v    v     |  |
+ *                      |   +---------------+  |  |
+ *                      |    \ Matrix  Mux /   |  |
+ *                      |     +-----+-----+    |  |
+ *                      |           |          |  |
+ *                      |           |18chn     |  |
+ *                      |           |          |  |
+ *                      |           |     10chn|  |
+ *                      |           v          |  |
+ *                      |     +------------+   |  |
+ *                      |     | Mixer      |   |  |
+ *                      |     |     Matrix |   |  |
+ *                      |     |            |   |  |
+ *                      |     | 18x10 Gain |   |  |
+ *                      |     |   stages   |   |  |
+ *                      |     +-----+------+   |  |
+ *                      |           |          |  |
+ *                      |18chn      |10chn     |  |20chn
+ *                      |           |          |  |
+ *                      |           +----------/  |
+ *                      |           |             |
+ *                      v           v             v
+ *                      ===========================
+ *               +---------------+       +--&#x2014;------------+
+ *                \ Output  Mux /         \ Capture Mux /
+ *                 +---+---+---+           +-----+-----+
+ *                     |   |                     |
+ *                10chn|   |                     |18chn
+ *                     |   |                     |
+ *  /--------------\   |   |                     |   /--------------\
+ *  | S/PDIF, ADAT |&lt;--/   |10chn                \--&gt;| ALSA PCM in  |
+ *  | Hardware out |       |                         \--------------/
+ *  \--------------/       |
+ *                         v
+ *                  +-------------+    Software gain per channel.
+ *                  | Master Gain |&lt;-- 18i20 only: Switch per channel
+ *                  +------+------+    to select HW or SW gain control.
+ *                         |
+ *                         |10chn
+ *  /--------------\       |
+ *  | Analogue     |&lt;------/
+ *  | Hardware out |
+ *  \--------------/
+ * &lt;/ditaa&gt;
+ *
+ */
+
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/moduleparam.h&gt;
+
+#include &lt;sound/control.h&gt;
+#include &lt;sound/tlv.h&gt;
+
+#include &quot;usbaudio.h&quot;
+#include &quot;mixer.h&quot;
+#include &quot;helper.h&quot;
+
+#include &quot;mixer_scarlett_gen2.h&quot;
+
+static int scarlett_gen2_mixer_enable = 0;
+module_param(scarlett_gen2_mixer_enable, int, 0444);
+MODULE_PARM_DESC(scarlett_gen2_mixer_enable,
+		 &quot;Focusrite Scarlett Gen 2 Mixer Driver Enable&quot;);
+
+/* some gui mixers can't handle negative ctl values */
+#define SCARLETT_VOLUME_BIAS 127
+
+/* mixer range from -80dB to +6dB in 0.5dB steps */
+#define SCARLETT_MIXER_MIN_DB -80
+#define SCARLETT_MIXER_BIAS (-SCARLETT_MIXER_MIN_DB * 2)
+#define SCARLETT_MIXER_MAX_DB 6
+#define SCARLETT_MIXER_MAX_VALUE \
+	((SCARLETT_MIXER_MAX_DB - SCARLETT_MIXER_MIN_DB) * 2)
+
+/* map from (dB + 80) * 2 to mixer value
+ * for dB in 0 .. 172: int(8192 * pow(10, ((dB - 160) / 2 / 20)))
+ */
+static const u16 scarlett2_mixer_values[173] = {
+	0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
+	2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8,
+	9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+	23, 24, 25, 27, 29, 30, 32, 34, 36, 38, 41, 43, 46, 48, 51,
+	54, 57, 61, 65, 68, 73, 77, 81, 86, 91, 97, 103, 109, 115,
+	122, 129, 137, 145, 154, 163, 173, 183, 194, 205, 217, 230,
+	244, 259, 274, 290, 307, 326, 345, 365, 387, 410, 434, 460,
+	487, 516, 547, 579, 614, 650, 689, 730, 773, 819, 867, 919,
+	973, 1031, 1092, 1157, 1225, 1298, 1375, 1456, 1543, 1634,
+	1731, 1833, 1942, 2057, 2179, 2308, 2445, 2590, 2744, 2906,
+	3078, 3261, 3454, 3659, 3876, 4105, 4349, 4606, 4879, 5168,
+	5475, 5799, 6143, 6507, 6892, 7301, 7733, 8192, 8677, 9191,
+	9736, 10313, 10924, 11571, 12257, 12983, 13752, 14567, 15430,
+	16345
+};
+
+/* Maximum number of analogue outputs */
+#define SCARLETT2_ANALOGUE_MAX 10
+
+/* Maximum number of level and pad switches */
+#define SCARLETT2_LEVEL_SWITCH_MAX 2
+#define SCARLETT2_PAD_SWITCH_MAX 4
+
+/* Maximum number of inputs to the mixer */
+#define SCARLETT2_INPUT_MIX_MAX 18
+
+/* Maximum number of outputs from the mixer */
+#define SCARLETT2_OUTPUT_MIX_MAX 10
+
+/* Maximum size of the data in the USB mux assignment message:
+ * 18 inputs, 20 outputs, 18 matrix inputs, 8 spare
+ */
+#define SCARLETT2_MUX_MAX 64
+
+/* Number of meters:
+ * 18 inputs, 20 outputs, 18 matrix inputs
+ */
+#define SCARLETT2_NUM_METERS 56
+
+/* Hardware port types:
+ * - None (no input to mux)
+ * - Analogue I/O
+ * - S/PDIF I/O
+ * - ADAT I/O
+ * - Mixer I/O
+ * - PCM I/O
+ */
+enum {
+	SCARLETT2_PORT_TYPE_NONE = 0,
+	SCARLETT2_PORT_TYPE_ANALOGUE = 1,
+	SCARLETT2_PORT_TYPE_SPDIF = 2,
+	SCARLETT2_PORT_TYPE_ADAT = 3,
+	SCARLETT2_PORT_TYPE_MIX = 4,
+	SCARLETT2_PORT_TYPE_PCM = 5,
+	SCARLETT2_PORT_TYPE_COUNT = 6,
+};
+
+/* Count of total I/O and number available at each sample rate */
+enum {
+	SCARLETT2_PORT_IN = 0,
+	SCARLETT2_PORT_OUT = 1,
+	SCARLETT2_PORT_OUT_44 = 2,
+	SCARLETT2_PORT_OUT_88 = 3,
+	SCARLETT2_PORT_OUT_176 = 4,
+	SCARLETT2_PORT_DIRECTIONS = 5,
+};
+
+/* Hardware buttons on the 18i20 */
+#define SCARLETT2_BUTTON_MAX 2
+
+static const char *const scarlett2_button_names[SCARLETT2_BUTTON_MAX] = {
+	&quot;Mute&quot;, &quot;Dim&quot;
+};
+
+/* Description of each hardware port type:
+ * - id: hardware ID for this port type
+ * - num: number of sources/destinations of this port type
+ * - src_descr: printf format string for mux input selections
+ * - src_num_offset: added to channel number for the fprintf
+ * - dst_descr: printf format string for mixer controls
+ */
+struct scarlett2_ports {
+	u16 id;
+	int num[SCARLETT2_PORT_DIRECTIONS];
+	const char * const src_descr;
+	int src_num_offset;
+	const char * const dst_descr;
+};
+
+struct scarlett2_device_info {
+	u8 line_out_hw_vol; /* line out hw volume is sw controlled */
+	u8 button_count; /* number of buttons */
+	u8 level_input_count; /* inputs with level selectable */
+	u8 pad_input_count; /* inputs with pad selectable */
+	const char * const line_out_descrs[SCARLETT2_ANALOGUE_MAX];
+	struct scarlett2_ports ports[SCARLETT2_PORT_TYPE_COUNT];
+};
+
+struct scarlett2_mixer_data {
+	struct usb_mixer_interface *mixer;
+	struct mutex usb_mutex; /* prevent sending concurrent USB requests */
+	struct mutex data_mutex; /* lock access to this data */
+	struct delayed_work work;
+	const struct scarlett2_device_info *info;
+	int num_mux_srcs;
+	u16 scarlett2_seq;
+	u8 vol_updated;
+	u8 master_vol;
+	u8 vol[SCARLETT2_ANALOGUE_MAX];
+	u8 vol_sw_hw_switch[SCARLETT2_ANALOGUE_MAX];
+	u8 level_switch[SCARLETT2_LEVEL_SWITCH_MAX];
+	u8 pad_switch[SCARLETT2_PAD_SWITCH_MAX];
+	u8 buttons[SCARLETT2_BUTTON_MAX];
+	struct snd_kcontrol *master_vol_ctl;
+	struct snd_kcontrol *vol_ctls[SCARLETT2_ANALOGUE_MAX];
+	struct snd_kcontrol *button_ctls[SCARLETT2_BUTTON_MAX];
+	u8 mux[SCARLETT2_MUX_MAX];
+	u8 mix[SCARLETT2_INPUT_MIX_MAX * SCARLETT2_OUTPUT_MIX_MAX];
+};
+
+static void snd_scarlett_gen2_private_free(struct usb_mixer_interface *);
+
+/*** Model-specific data ***/
+
+static const struct scarlett2_device_info s6i6_gen2_info = {
+	/* The first two analogue inputs can be switched between line
+	 * and instrument levels.
+	 */
+	.level_input_count = 2,
+
+	/* The first two analogue inputs have an optional pad. */
+	.pad_input_count = 2,
+
+	.line_out_descrs = {
+		&quot;Monitor L&quot;,
+		&quot;Monitor R&quot;,
+		&quot;Headphones L&quot;,
+		&quot;Headphones R&quot;,
+	},
+
+	.ports = {
+		{
+			.id = 0x000,
+			.num = { 1, 0, 8, 8, 8 },
+			.src_descr = &quot;Off&quot;,
+			.src_num_offset = 0,
+		},
+		{
+			.id = 0x080,
+			.num = { 4, 4, 4, 4, 4 },
+			.src_descr = &quot;Analogue %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;Analogue Output %02d Playback&quot;
+		},
+		{
+			.id = 0x180,
+			.num = { 2, 2, 2, 2, 2 },
+			.src_descr = &quot;S/PDIF %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;S/PDIF Output %d Playback&quot;
+		},
+		{
+			.id = 0x300,
+			.num = { 10, 18, 18, 18, 18 },
+			.src_descr = &quot;Mix %c&quot;,
+			.src_num_offset = 65,
+			.dst_descr = &quot;Mixer Input %02d Capture&quot;
+		},
+		{
+			.id = 0x600,
+			.num = { 6, 6, 6, 6, 6 },
+			.src_descr = &quot;PCM %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;PCM %02d Capture&quot;
+		},
+	},
+};
+
+static const struct scarlett2_device_info s18i8_gen2_info = {
+	/* The first two analogue inputs can be switched between line
+	 * and instrument levels.
+	 */
+	.level_input_count = 2,
+
+	/* The first four analogue inputs have an optional pad. */
+	.pad_input_count = 4,
+
+	.line_out_descrs = {
+		&quot;Monitor L&quot;,
+		&quot;Monitor R&quot;,
+		&quot;Headphones 1 L&quot;,
+		&quot;Headphones 1 R&quot;,
+		&quot;Headphones 2 L&quot;,
+		&quot;Headphones 2 R&quot;,
+	},
+
+	.ports = {
+		{
+			.id = 0x000,
+			.num = { 1, 0, 8, 8, 4 },
+			.src_descr = &quot;Off&quot;,
+			.src_num_offset = 0,
+		},
+		{
+			.id = 0x080,
+			.num = { 8, 6, 6, 6, 6 },
+			.src_descr = &quot;Analogue %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;Analogue Output %02d Playback&quot;
+		},
+		{
+			/* S/PDIF outputs aren't available at 192KHz
+			 * but are included in the USB mux I/O
+			 * assignment message anyway
+			 */
+			.id = 0x180,
+			.num = { 2, 2, 2, 2, 2 },
+			.src_descr = &quot;S/PDIF %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;S/PDIF Output %d Playback&quot;
+		},
+		{
+			.id = 0x200,
+			.num = { 8, 0, 0, 0, 0 },
+			.src_descr = &quot;ADAT %d&quot;,
+			.src_num_offset = 1,
+		},
+		{
+			.id = 0x300,
+			.num = { 10, 18, 18, 18, 18 },
+			.src_descr = &quot;Mix %c&quot;,
+			.src_num_offset = 65,
+			.dst_descr = &quot;Mixer Input %02d Capture&quot;
+		},
+		{
+			.id = 0x600,
+			.num = { 20, 18, 18, 14, 10 },
+			.src_descr = &quot;PCM %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;PCM %02d Capture&quot;
+		},
+	},
+};
+
+static const struct scarlett2_device_info s18i20_gen2_info = {
+	/* The analogue line outputs on the 18i20 can be switched
+	 * between software and hardware volume control
+	 */
+	.line_out_hw_vol = 1,
+
+	/* Mute and dim buttons */
+	.button_count = 2,
+
+	.line_out_descrs = {
+		&quot;Monitor L&quot;,
+		&quot;Monitor R&quot;,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		&quot;Headphones 1 L&quot;,
+		&quot;Headphones 1 R&quot;,
+		&quot;Headphones 2 L&quot;,
+		&quot;Headphones 2 R&quot;,
+	},
+
+	.ports = {
+		{
+			.id = 0x000,
+			.num = { 1, 0, 8, 8, 6 },
+			.src_descr = &quot;Off&quot;,
+			.src_num_offset = 0,
+		},
+		{
+			.id = 0x080,
+			.num = { 8, 10, 10, 10, 10 },
+			.src_descr = &quot;Analogue %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;Analogue Output %02d Playback&quot;
+		},
+		{
+			/* S/PDIF outputs aren't available at 192KHz
+			 * but are included in the USB mux I/O
+			 * assignment message anyway
+			 */
+			.id = 0x180,
+			.num = { 2, 2, 2, 2, 2 },
+			.src_descr = &quot;S/PDIF %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;S/PDIF Output %d Playback&quot;
+		},
+		{
+			.id = 0x200,
+			.num = { 8, 8, 8, 4, 0 },
+			.src_descr = &quot;ADAT %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;ADAT Output %d Playback&quot;
+		},
+		{
+			.id = 0x300,
+			.num = { 10, 18, 18, 18, 18 },
+			.src_descr = &quot;Mix %c&quot;,
+			.src_num_offset = 65,
+			.dst_descr = &quot;Mixer Input %02d Capture&quot;
+		},
+		{
+			.id = 0x600,
+			.num = { 20, 18, 18, 14, 10 },
+			.src_descr = &quot;PCM %d&quot;,
+			.src_num_offset = 1,
+			.dst_descr = &quot;PCM %02d Capture&quot;
+		},
+	},
+};
+
+/* get the starting port index number for a given port type/direction */
+static int scarlett2_get_port_start_num(const struct scarlett2_ports *ports,
+					int direction, int port_type)
+{
+	int i, num = 0;
+
+	for (i = 0; i &lt; port_type; i++)
+		num += ports[i].num[direction];
+
+	return num;
+}
+
+/*** USB Interactions ***/
+
+/* Vendor-Specific Interface, Endpoint, MaxPacketSize, Interval */
+#define SCARLETT2_USB_VENDOR_SPECIFIC_INTERFACE 5
+#define SCARLETT2_USB_INTERRUPT_ENDPOINT 4
+#define SCARLETT2_USB_INTERRUPT_MAX_DATA 64
+#define SCARLETT2_USB_INTERRUPT_INTERVAL 3
+
+/* Interrupt flags for volume and mute/dim button changes */
+#define SCARLETT2_USB_INTERRUPT_VOL_CHANGE 0x400000
+#define SCARLETT2_USB_INTERRUPT_BUTTON_CHANGE 0x200000
+
+/* Commands for sending/receiving requests/responses */
+#define SCARLETT2_USB_VENDOR_SPECIFIC_CMD_REQ 2
+#define SCARLETT2_USB_VENDOR_SPECIFIC_CMD_RESP 3
+
+#define SCARLETT2_USB_INIT_SEQ 0x00000000
+#define SCARLETT2_USB_GET_METER_LEVELS 0x00001001
+#define SCARLETT2_USB_SET_MIX 0x00002002
+#define SCARLETT2_USB_SET_MUX 0x00003002
+#define SCARLETT2_USB_GET_DATA 0x00800000
+#define SCARLETT2_USB_SET_DATA 0x00800001
+#define SCARLETT2_USB_DATA_CMD 0x00800002
+#define SCARLETT2_USB_CONFIG_SAVE 6
+
+#define SCARLETT2_USB_VOLUME_STATUS_OFFSET 0x31
+#define SCARLETT2_USB_METER_LEVELS_GET_MAGIC 1
+
+/* volume status is read together (matches scarlett2_config_items[]) */
+struct scarlett2_usb_volume_status {
+	/* mute &amp; dim buttons */
+	u8 buttons[SCARLETT2_BUTTON_MAX];
+
+	u8 pad1;
+
+	/* software volume setting */
+	s16 sw_vol[SCARLETT2_ANALOGUE_MAX];
+
+	/* actual volume of output inc. dim (-18dB) */
+	s16 hw_vol[SCARLETT2_ANALOGUE_MAX];
+
+	u8 pad2[SCARLETT2_ANALOGUE_MAX];
+
+	/* sw (0) or hw (1) controlled */
+	u8 sw_hw_switch[SCARLETT2_ANALOGUE_MAX];
+
+	u8 pad3[6];
+
+	/* front panel volume knob */
+	s16 master_vol;
+} __packed;
+
+/* Configuration parameters that can be read and written */
+enum {
+	SCARLETT2_CONFIG_BUTTONS = 0,
+	SCARLETT2_CONFIG_LINE_OUT_VOLUME = 1,
+	SCARLETT2_CONFIG_SW_HW_SWITCH = 2,
+	SCARLETT2_CONFIG_LEVEL_SWITCH = 3,
+	SCARLETT2_CONFIG_PAD_SWITCH = 4,
+	SCARLETT2_CONFIG_COUNT = 5
+};
+
+/* Location, size, and activation command number for the configuration
+ * parameters
+ */
+struct scarlett2_config {
+	u8 offset;
+	u8 size;
+	u8 activate;
+};
+
+static const struct scarlett2_config
+		scarlett2_config_items[SCARLETT2_CONFIG_COUNT] = {
+	/* Mute/Dim Buttons */
+	{
+		.offset = 0x31,
+		.size = 1,
+		.activate = 2
+	},
+
+	/* Line Out Volume */
+	{
+		.offset = 0x34,
+		.size = 2,
+		.activate = 1
+	},
+
+	/* SW/HW Volume Switch */
+	{
+		.offset = 0x66,
+		.size = 1,
+		.activate = 3
+	},
+
+	/* Level Switch */
+	{
+		.offset = 0x7c,
+		.size = 1,
+		.activate = 7
+	},
+
+	/* Pad Switch */
+	{
+		.offset = 0x84,
+		.size = 1,
+		.activate = 8
+	}
+};
+
+/* proprietary request/response format */
+struct scarlett2_usb_packet {
+	u32 cmd;
+	u16 size;
+	u16 seq;
+	u32 error;
+	u32 pad;
+	u8 data[];
+};
+
+#define SCARLETT2_USB_PACKET_LEN (sizeof(struct scarlett2_usb_packet))
+
+static void scarlett2_fill_request_header(struct scarlett2_mixer_data *private,
+					  struct scarlett2_usb_packet *req,
+					  u32 cmd, u16 req_size)
+{
+	/* sequence must go up by 1 for each request */
+	u16 seq = private-&gt;scarlett2_seq++;
+
+	req-&gt;cmd = cpu_to_le32(cmd);
+	req-&gt;size = cpu_to_le16(req_size);
+	req-&gt;seq = cpu_to_le16(seq);
+	req-&gt;error = 0;
+	req-&gt;pad = 0;
+}
+
+/* Send a proprietary format request to the Scarlett interface */
+static int scarlett2_usb(
+	struct usb_mixer_interface *mixer, u32 cmd,
+	void *req_data, u16 req_size, void *resp_data, u16 resp_size)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	u16 req_buf_size = sizeof(struct scarlett2_usb_packet) + req_size;
+	u16 resp_buf_size = sizeof(struct scarlett2_usb_packet) + resp_size;
+
+	struct scarlett2_usb_packet *req = 0, *resp = 0;
+
+	int err = 0;
+
+	mutex_lock(&amp;private-&gt;usb_mutex);
+
+	/* build request message and send it */
+
+	req = kmalloc(req_buf_size, GFP_KERNEL);
+	if (!req) {
+		err = -ENOMEM;
+		goto unlock;
+	}
+
+	scarlett2_fill_request_header(private, req, cmd, req_size);
+
+	if (req_size)
+		memcpy(req-&gt;data, req_data, req_size);
+
+	err = snd_usb_ctl_msg(mixer-&gt;chip-&gt;dev,
+			usb_sndctrlpipe(mixer-&gt;chip-&gt;dev, 0),
+			SCARLETT2_USB_VENDOR_SPECIFIC_CMD_REQ,
+			USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,
+			0,
+			SCARLETT2_USB_VENDOR_SPECIFIC_INTERFACE,
+			req,
+			req_buf_size);
+
+	if (err != req_buf_size) {
+		usb_audio_err(
+			mixer-&gt;chip,
+			&quot;Scarlett Gen 2 USB request result cmd %x was %d\n&quot;,
+			cmd, err);
+		err = -EINVAL;
+		goto unlock;
+	}
+
+	/* send a second message to get the response */
+
+	resp = kmalloc(resp_buf_size, GFP_KERNEL);
+	if (!resp) {
+		err = -ENOMEM;
+		goto unlock;
+	}
+
+	err = snd_usb_ctl_msg(mixer-&gt;chip-&gt;dev,
+			usb_sndctrlpipe(mixer-&gt;chip-&gt;dev, 0),
+			SCARLETT2_USB_VENDOR_SPECIFIC_CMD_RESP,
+			USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,
+			0,
+			SCARLETT2_USB_VENDOR_SPECIFIC_INTERFACE,
+			resp,
+			resp_buf_size);
+
+	/* validate the response */
+
+	if (err != resp_buf_size) {
+		usb_audio_err(
+			mixer-&gt;chip,
+			&quot;Scarlett Gen 2 USB response result cmd %x was %d\n&quot;,
+			cmd, err);
+		err = -EINVAL;
+		goto unlock;
+	}
+
+	if (resp-&gt;cmd != req-&gt;cmd ||
+	    resp-&gt;seq != req-&gt;seq ||
+	    resp_size != le16_to_cpu(resp-&gt;size) ||
+	    resp-&gt;error ||
+	    resp-&gt;pad) {
+		usb_audio_err(
+			mixer-&gt;chip,
+			&quot;Scarlett Gen 2 USB invalid response; &quot;
+			   &quot;cmd tx/rx %d/%d seq %d/%d size %d/%d &quot;
+			   &quot;error %d pad %d\n&quot;,
+			le16_to_cpu(req-&gt;cmd), le16_to_cpu(resp-&gt;cmd),
+			le16_to_cpu(req-&gt;seq), le16_to_cpu(resp-&gt;seq),
+			resp_size, le16_to_cpu(resp-&gt;size),
+			le16_to_cpu(resp-&gt;error),
+			le16_to_cpu(resp-&gt;pad));
+		err = -EINVAL;
+		goto unlock;
+	}
+
+	if (resp_size &gt; 0)
+		memcpy(resp_data, resp-&gt;data, resp_size);
+
+unlock:
+	kfree(req);
+	kfree(resp);
+	mutex_unlock(&amp;private-&gt;usb_mutex);
+	return err;
+}
+
+/* Send SCARLETT2_USB_DATA_CMD SCARLETT2_USB_CONFIG_SAVE */
+static void scarlett2_config_save(struct work_struct *work)
+{
+	struct scarlett2_mixer_data *private =
+		container_of(work, struct scarlett2_mixer_data, work.work);
+	struct usb_mixer_interface *mixer = private-&gt;mixer;
+	u32 req = cpu_to_le32(SCARLETT2_USB_CONFIG_SAVE);
+
+	scarlett2_usb(mixer, SCARLETT2_USB_DATA_CMD,
+		      &amp;req, sizeof(u32),
+		      NULL, 0);
+}
+
+/* Send a USB message to set a configuration parameter (volume level,
+ * sw/hw volume switch, line/inst level switch, or pad switch)
+ */
+static int scarlett2_usb_set_config(
+	struct usb_mixer_interface *mixer,
+	int config_item_num, int index, int value)
+{
+	const struct scarlett2_config config_item =
+	       scarlett2_config_items[config_item_num];
+	struct {
+		u32 offset;
+		u32 bytes;
+		s32 value;
+	} __packed req;
+	u32 req2;
+	int err;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	/* Send the configuration parameter data */
+	req.offset = cpu_to_le32(config_item.offset + index * config_item.size);
+	req.bytes = cpu_to_le32(config_item.size);
+	req.value = cpu_to_le32(value);
+	err = scarlett2_usb(mixer, SCARLETT2_USB_SET_DATA,
+			    &amp;req, sizeof(u32) * 2 + config_item.size,
+			    NULL, 0);
+	if (err &lt; 0)
+		return err;
+
+	/* Activate the change */
+	req2 = cpu_to_le32(config_item.activate);
+	err = scarlett2_usb(mixer, SCARLETT2_USB_DATA_CMD,
+			    &amp;req2, sizeof(req2), NULL, 0);
+	if (err &lt; 0)
+		return err;
+
+	/* Schedule the change to be written to NVRAM */
+	schedule_delayed_work(&amp;private-&gt;work, msecs_to_jiffies(2000));
+
+	return 0;
+}
+
+/* Send a USB message to get data; result placed in *buf */
+static int scarlett2_usb_get(
+	struct usb_mixer_interface *mixer,
+	int offset, void *buf, int size)
+{
+	struct {
+		u32 offset;
+		u32 size;
+	} __packed req;
+
+	req.offset = cpu_to_le32(offset);
+	req.size = cpu_to_le32(size);
+	return scarlett2_usb(mixer, SCARLETT2_USB_GET_DATA,
+			     &amp;req, sizeof(req), buf, size);
+}
+
+/* Send a USB message to get configuration parameters; result placed in *buf */
+static int scarlett2_usb_get_config(
+	struct usb_mixer_interface *mixer,
+	int config_item_num, int count, void *buf)
+{
+	const struct scarlett2_config config_item =
+	       scarlett2_config_items[config_item_num];
+	int size = config_item.size * count;
+
+	return scarlett2_usb_get(mixer, config_item.offset, buf, size);
+}
+
+/* Send a USB message to get volume status; result placed in *buf */
+static int scarlett2_usb_get_volume_status(
+	struct usb_mixer_interface *mixer,
+	struct scarlett2_usb_volume_status *buf)
+{
+	return scarlett2_usb_get(mixer, SCARLETT2_USB_VOLUME_STATUS_OFFSET,
+				 buf, sizeof(*buf));
+}
+
+/* Send a USB message to set the volumes for all inputs of one mix
+ * (values obtained from private-&gt;mix[])
+ */
+static int scarlett2_usb_set_mix(struct usb_mixer_interface *mixer,
+				     int mix_num)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_device_info *info = private-&gt;info;
+
+	struct {
+		u16 mix_num;
+		u16 data[SCARLETT2_INPUT_MIX_MAX];
+	} __packed req;
+
+	int i, j;
+	int num_mixer_in =
+		info-&gt;ports[SCARLETT2_PORT_TYPE_MIX].num[SCARLETT2_PORT_OUT];
+
+	req.mix_num = cpu_to_le16(mix_num);
+
+	for (i = 0, j = mix_num * num_mixer_in; i &lt; num_mixer_in; i++, j++)
+		req.data[i] = cpu_to_le16(
+			scarlett2_mixer_values[private-&gt;mix[j]]
+		);
+
+	return scarlett2_usb(mixer, SCARLETT2_USB_SET_MIX,
+			     &amp;req, (num_mixer_in + 1) * sizeof(u16),
+			     NULL, 0);
+}
+
+/* Convert a port number index (per info-&gt;ports) to a hardware ID */
+static u32 scarlett2_mux_src_num_to_id(const struct scarlett2_ports *ports,
+				       int num)
+{
+	int port_type;
+
+	for (port_type = 0;
+	     port_type &lt; SCARLETT2_PORT_TYPE_COUNT;
+	     port_type++) {
+		if (num &lt; ports[port_type].num[SCARLETT2_PORT_IN])
+			return ports[port_type].id | num;
+		num -= ports[port_type].num[SCARLETT2_PORT_IN];
+	}
+
+	/* Oops */
+	return 0;
+}
+
+/* Send USB messages to set mux inputs */
+static int scarlett2_usb_set_mux(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_device_info *info = private-&gt;info;
+	const struct scarlett2_ports *ports = info-&gt;ports;
+	int rate, port_dir_rate;
+
+	static const int assignment_order[SCARLETT2_PORT_TYPE_COUNT] = {
+		SCARLETT2_PORT_TYPE_PCM,
+		SCARLETT2_PORT_TYPE_ANALOGUE,
+		SCARLETT2_PORT_TYPE_SPDIF,
+		SCARLETT2_PORT_TYPE_ADAT,
+		SCARLETT2_PORT_TYPE_MIX,
+		SCARLETT2_PORT_TYPE_NONE,
+	};
+
+	struct {
+		u16 pad;
+		u16 num;
+		u32 data[SCARLETT2_MUX_MAX];
+	} __packed req;
+
+	req.pad = 0;
+
+	/* mux settings for each rate */
+	for (rate = 0, port_dir_rate = SCARLETT2_PORT_OUT_44;
+	     port_dir_rate &lt;= SCARLETT2_PORT_OUT_176;
+	     rate++, port_dir_rate++) {
+		int order_num, i, err;
+
+		req.num = cpu_to_le16(rate);
+
+		for (order_num = 0, i = 0;
+		     order_num &lt; SCARLETT2_PORT_TYPE_COUNT;
+		     order_num++) {
+			int port_type = assignment_order[order_num];
+			int j = scarlett2_get_port_start_num(ports,
+							     SCARLETT2_PORT_OUT,
+							     port_type);
+			int port_id = ports[port_type].id;
+			int channel;
+
+			for (channel = 0;
+			     channel &lt; ports[port_type].num[port_dir_rate];
+			     channel++, i++, j++)
+				/* lower 12 bits for the destination and
+				 * next 12 bits for the source
+				 */
+				req.data[i] = !port_id
+					? 0
+					: cpu_to_le32(
+						port_id |
+						channel |
+						scarlett2_mux_src_num_to_id(
+							ports, private-&gt;mux[j]
+						) &lt;&lt; 12
+					  );
+
+			/* skip private-&gt;mux[j] entries not output */
+			j += ports[port_type].num[SCARLETT2_PORT_OUT] -
+			     ports[port_type].num[port_dir_rate];
+		}
+
+		err = scarlett2_usb(mixer, SCARLETT2_USB_SET_MUX,
+				    &amp;req, (i + 1) * sizeof(u32),
+				    NULL, 0);
+		if (err &lt; 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Send USB message to get meter levels */
+static int scarlett2_usb_get_meter_levels(struct usb_mixer_interface *mixer,
+					  u16 *levels)
+{
+	struct {
+		u16 pad;
+		u16 num_meters;
+		u32 magic;
+	} __packed req;
+	u32 resp[SCARLETT2_NUM_METERS];
+	int i, err;
+
+	req.pad = 0;
+	req.num_meters = cpu_to_le16(SCARLETT2_NUM_METERS);
+	req.magic = cpu_to_le32(SCARLETT2_USB_METER_LEVELS_GET_MAGIC);
+	err = scarlett2_usb(mixer, SCARLETT2_USB_GET_METER_LEVELS,
+			    &amp;req, sizeof(req), resp, sizeof(resp));
+	if (err &lt; 0)
+		return err;
+
+	/* copy, convert to u16 */
+	for (i = 0; i &lt; SCARLETT2_NUM_METERS; i++)
+		levels[i] = resp[i];
+
+	return 0;
+}
+
+/*** Control Functions ***/
+
+/* helper function to create a new control */
+static int scarlett2_add_new_ctl(struct usb_mixer_interface *mixer,
+				 const struct snd_kcontrol_new *ncontrol,
+				 int index, int channels, const char *name,
+				 struct snd_kcontrol **kctl_return)
+{
+	struct snd_kcontrol *kctl;
+	struct usb_mixer_elem_info *elem;
+	int err;
+
+	elem = kzalloc(sizeof(*elem), GFP_KERNEL);
+	if (!elem)
+		return -ENOMEM;
+
+	elem-&gt;head.mixer = mixer;
+	elem-&gt;control = index;
+	elem-&gt;head.id = index;
+	elem-&gt;channels = channels;
+
+	kctl = snd_ctl_new1(ncontrol, elem);
+	if (!kctl) {
+		kfree(elem);
+		return -ENOMEM;
+	}
+	kctl-&gt;private_free = snd_usb_mixer_elem_free;
+
+	strlcpy(kctl-&gt;id.name, name, sizeof(kctl-&gt;id.name));
+
+	err = snd_usb_mixer_add_control(&amp;elem-&gt;head, kctl);
+	if (err &lt; 0)
+		return err;
+
+	if (kctl_return)
+		*kctl_return = kctl;
+
+	return 0;
+}
+
+/*** Analogue Line Out Volume Controls ***/
+
+/* Update hardware volume controls after receiving notification that
+ * they have changed
+ */
+static int scarlett2_update_volumes(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_ports *ports = private-&gt;info-&gt;ports;
+	struct scarlett2_usb_volume_status volume_status;
+	int num_line_out =
+		ports[SCARLETT2_PORT_TYPE_ANALOGUE].num[SCARLETT2_PORT_OUT];
+	int err, i;
+
+	private-&gt;vol_updated = 0;
+
+	err = scarlett2_usb_get_volume_status(mixer, &amp;volume_status);
+	if (err &lt; 0)
+		return err;
+
+	private-&gt;master_vol = clamp(
+		volume_status.master_vol + SCARLETT_VOLUME_BIAS,
+		0, SCARLETT_VOLUME_BIAS);
+
+	for (i = 0; i &lt; num_line_out; i++) {
+		if (private-&gt;vol_sw_hw_switch[i])
+			private-&gt;vol[i] = private-&gt;master_vol;
+	}
+
+	for (i = 0; i &lt; private-&gt;info-&gt;button_count; i++)
+		private-&gt;buttons[i] = !!volume_status.buttons[i];
+
+	return 0;
+}
+
+static int scarlett2_volume_ctl_info(struct snd_kcontrol *kctl,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+
+	uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo-&gt;count = elem-&gt;channels;
+	uinfo-&gt;value.integer.min = 0;
+	uinfo-&gt;value.integer.max = SCARLETT_VOLUME_BIAS;
+	uinfo-&gt;value.integer.step = 1;
+	return 0;
+}
+
+static int scarlett2_master_volume_ctl_get(struct snd_kcontrol *kctl,
+					   struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	if (private-&gt;vol_updated) {
+		mutex_lock(&amp;private-&gt;data_mutex);
+		scarlett2_update_volumes(mixer);
+		mutex_unlock(&amp;private-&gt;data_mutex);
+	}
+
+	ucontrol-&gt;value.integer.value[0] = private-&gt;master_vol;
+	return 0;
+}
+
+static int scarlett2_volume_ctl_get(struct snd_kcontrol *kctl,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	int index = elem-&gt;control;
+
+	if (private-&gt;vol_updated) {
+		mutex_lock(&amp;private-&gt;data_mutex);
+		scarlett2_update_volumes(mixer);
+		mutex_unlock(&amp;private-&gt;data_mutex);
+	}
+
+	ucontrol-&gt;value.integer.value[0] = private-&gt;vol[index];
+	return 0;
+}
+
+static int scarlett2_volume_ctl_put(struct snd_kcontrol *kctl,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	int index = elem-&gt;control;
+	int oval, val, err = 0;
+
+	cancel_delayed_work_sync(&amp;private-&gt;work);
+	mutex_lock(&amp;private-&gt;data_mutex);
+
+	oval = private-&gt;vol[index];
+	val = ucontrol-&gt;value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private-&gt;vol[index] = val;
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_LINE_OUT_VOLUME,
+				       index, val - SCARLETT_VOLUME_BIAS);
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&amp;private-&gt;data_mutex);
+	return err;
+}
+
+static const DECLARE_TLV_DB_MINMAX(
+	db_scale_scarlett_gain, -SCARLETT_VOLUME_BIAS * 100, 0
+);
+
+static const struct snd_kcontrol_new scarlett2_master_volume_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |
+		  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
+	.name = &quot;&quot;,
+	.info = scarlett2_volume_ctl_info,
+	.get  = scarlett2_master_volume_ctl_get,
+	.private_value = 0, /* max value */
+	.tlv = { .p = db_scale_scarlett_gain }
+};
+
+static const struct snd_kcontrol_new scarlett2_line_out_volume_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
+	.name = &quot;&quot;,
+	.info = scarlett2_volume_ctl_info,
+	.get  = scarlett2_volume_ctl_get,
+	.put  = scarlett2_volume_ctl_put,
+	.private_value = 0, /* max value */
+	.tlv = { .p = db_scale_scarlett_gain }
+};
+
+/*** HW/SW Volume Switch Controls ***/
+
+static int scarlett2_sw_hw_enum_ctl_info(struct snd_kcontrol *kctl,
+					 struct snd_ctl_elem_info *uinfo)
+{
+	static const char *const values[2] = {
+		&quot;SW&quot;, &quot;HW&quot;
+	};
+
+	return snd_ctl_enum_info(uinfo, 1, 2, values);
+}
+
+static int scarlett2_sw_hw_enum_ctl_get(struct snd_kcontrol *kctl,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct scarlett2_mixer_data *private = elem-&gt;head.mixer-&gt;private_data;
+
+	ucontrol-&gt;value.enumerated.item[0] =
+		private-&gt;vol_sw_hw_switch[elem-&gt;control];
+	return 0;
+}
+
+static int scarlett2_sw_hw_enum_ctl_put(struct snd_kcontrol *kctl,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	int index = elem-&gt;control;
+	int oval, val, err = 0;
+
+	cancel_delayed_work_sync(&amp;private-&gt;work);
+	mutex_lock(&amp;private-&gt;data_mutex);
+
+	oval = private-&gt;vol_sw_hw_switch[index];
+	val = !!ucontrol-&gt;value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private-&gt;vol_sw_hw_switch[index] = val;
+
+	/* Change access mode to RO (hardware controlled volume)
+	 * or RW (software controlled volume)
+	 */
+	if (val)
+		private-&gt;vol_ctls[index]-&gt;vd[0].access &amp;=
+			~SNDRV_CTL_ELEM_ACCESS_WRITE;
+	else
+		private-&gt;vol_ctls[index]-&gt;vd[0].access |=
+			SNDRV_CTL_ELEM_ACCESS_WRITE;
+
+	/* Reset volume to master volume */
+	private-&gt;vol[index] = private-&gt;master_vol;
+
+	/* Set SW volume to current HW volume */
+	err = scarlett2_usb_set_config(
+		mixer, SCARLETT2_CONFIG_LINE_OUT_VOLUME,
+		index, private-&gt;master_vol - SCARLETT_VOLUME_BIAS);
+	if (err &lt; 0)
+		goto unlock;
+
+	/* Notify of RO/RW change */
+	snd_ctl_notify(mixer-&gt;chip-&gt;card, SNDRV_CTL_EVENT_MASK_INFO,
+		       &amp;private-&gt;vol_ctls[index]-&gt;id);
+
+	/* Send SW/HW switch change to the device */
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_SW_HW_SWITCH,
+				       index, val);
+
+unlock:
+	mutex_unlock(&amp;private-&gt;data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_sw_hw_enum_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = &quot;&quot;,
+	.info = scarlett2_sw_hw_enum_ctl_info,
+	.get  = scarlett2_sw_hw_enum_ctl_get,
+	.put  = scarlett2_sw_hw_enum_ctl_put,
+};
+
+/*** Line Level/Instrument Level Switch Controls ***/
+
+static int scarlett2_level_enum_ctl_info(struct snd_kcontrol *kctl,
+					 struct snd_ctl_elem_info *uinfo)
+{
+	static const char *const values[2] = {
+		&quot;Line&quot;, &quot;Inst&quot;
+	};
+
+	return snd_ctl_enum_info(uinfo, 1, 2, values);
+}
+
+static int scarlett2_level_enum_ctl_get(struct snd_kcontrol *kctl,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct scarlett2_mixer_data *private = elem-&gt;head.mixer-&gt;private_data;
+
+	ucontrol-&gt;value.enumerated.item[0] =
+		private-&gt;level_switch[elem-&gt;control];
+	return 0;
+}
+
+static int scarlett2_level_enum_ctl_put(struct snd_kcontrol *kctl,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	int index = elem-&gt;control;
+	int oval, val, err = 0;
+
+	cancel_delayed_work_sync(&amp;private-&gt;work);
+	mutex_lock(&amp;private-&gt;data_mutex);
+
+	oval = private-&gt;level_switch[index];
+	val = !!ucontrol-&gt;value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private-&gt;level_switch[index] = val;
+
+	/* Send switch change to the device */
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_LEVEL_SWITCH,
+				       index, val);
+
+unlock:
+	mutex_unlock(&amp;private-&gt;data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_level_enum_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = &quot;&quot;,
+	.info = scarlett2_level_enum_ctl_info,
+	.get  = scarlett2_level_enum_ctl_get,
+	.put  = scarlett2_level_enum_ctl_put,
+};
+
+/*** Pad Switch Controls ***/
+
+static int scarlett2_pad_ctl_get(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct scarlett2_mixer_data *private = elem-&gt;head.mixer-&gt;private_data;
+
+	ucontrol-&gt;value.enumerated.item[0] =
+		private-&gt;pad_switch[elem-&gt;control];
+	return 0;
+}
+
+static int scarlett2_pad_ctl_put(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	int index = elem-&gt;control;
+	int oval, val, err = 0;
+
+	cancel_delayed_work_sync(&amp;private-&gt;work);
+	mutex_lock(&amp;private-&gt;data_mutex);
+
+	oval = private-&gt;pad_switch[index];
+	val = !!ucontrol-&gt;value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private-&gt;pad_switch[index] = val;
+
+	/* Send switch change to the device */
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_PAD_SWITCH,
+				       index, val);
+
+unlock:
+	mutex_unlock(&amp;private-&gt;data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_pad_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = &quot;&quot;,
+	.info = snd_ctl_boolean_mono_info,
+	.get  = scarlett2_pad_ctl_get,
+	.put  = scarlett2_pad_ctl_put,
+};
+
+/*** Mute/Dim Controls ***/
+
+static int scarlett2_button_ctl_get(struct snd_kcontrol *kctl,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	if (private-&gt;vol_updated) {
+		mutex_lock(&amp;private-&gt;data_mutex);
+		scarlett2_update_volumes(mixer);
+		mutex_unlock(&amp;private-&gt;data_mutex);
+	}
+
+	ucontrol-&gt;value.enumerated.item[0] = private-&gt;buttons[elem-&gt;control];
+	return 0;
+}
+
+static int scarlett2_button_ctl_put(struct snd_kcontrol *kctl,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	int index = elem-&gt;control;
+	int oval, val, err = 0;
+
+	cancel_delayed_work_sync(&amp;private-&gt;work);
+	mutex_lock(&amp;private-&gt;data_mutex);
+
+	oval = private-&gt;buttons[index];
+	val = !!ucontrol-&gt;value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private-&gt;buttons[index] = val;
+
+	/* Send switch change to the device */
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_BUTTONS,
+				       index, val);
+
+unlock:
+	mutex_unlock(&amp;private-&gt;data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_button_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = &quot;&quot;,
+	.info = snd_ctl_boolean_mono_info,
+	.get  = scarlett2_button_ctl_get,
+	.put  = scarlett2_button_ctl_put
+};
+
+/*** Create the analogue output controls ***/
+
+static int scarlett2_add_line_out_ctls(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_device_info *info = private-&gt;info;
+	const struct scarlett2_ports *ports = info-&gt;ports;
+	int num_line_out =
+		ports[SCARLETT2_PORT_TYPE_ANALOGUE].num[SCARLETT2_PORT_OUT];
+	int err, i;
+	char s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+
+	/* Add R/O HW volume control */
+	if (info-&gt;line_out_hw_vol) {
+		snprintf(s, sizeof(s), &quot;Master HW Playback Volume&quot;);
+		err = scarlett2_add_new_ctl(mixer,
+					    &amp;scarlett2_master_volume_ctl,
+					    0, 1, s, &amp;private-&gt;master_vol_ctl);
+		if (err &lt; 0)
+			return err;
+	}
+
+	/* Add volume controls */
+	for (i = 0; i &lt; num_line_out; i++) {
+
+		/* Fader */
+		if (info-&gt;line_out_descrs[i])
+			snprintf(s, sizeof(s),
+				 &quot;Line %02d (%s) Playback Volume&quot;,
+				 i + 1, info-&gt;line_out_descrs[i]);
+		else
+			snprintf(s, sizeof(s),
+				 &quot;Line %02d Playback Volume&quot;,
+				 i + 1);
+		err = scarlett2_add_new_ctl(mixer,
+					    &amp;scarlett2_line_out_volume_ctl,
+					    i, 1, s, &amp;private-&gt;vol_ctls[i]);
+		if (err &lt; 0)
+			return err;
+
+		/* Make the fader read-only if the SW/HW switch is set to HW */
+		if (private-&gt;vol_sw_hw_switch[i])
+			private-&gt;vol_ctls[i]-&gt;vd[0].access &amp;=
+				~SNDRV_CTL_ELEM_ACCESS_WRITE;
+
+		/* SW/HW Switch */
+		if (info-&gt;line_out_hw_vol) {
+			snprintf(s, sizeof(s),
+				 &quot;Line Out %02d Volume Control Playback Enum&quot;,
+				 i + 1);
+			err = scarlett2_add_new_ctl(mixer,
+						    &amp;scarlett2_sw_hw_enum_ctl,
+						    i, 1, s, NULL);
+			if (err &lt; 0)
+				return err;
+		}
+	}
+
+	/* Add HW button controls */
+	for (i = 0; i &lt; private-&gt;info-&gt;button_count; i++) {
+		err = scarlett2_add_new_ctl(mixer, &amp;scarlett2_button_ctl,
+					    i, 1, scarlett2_button_names[i],
+					    &amp;private-&gt;button_ctls[i]);
+		if (err &lt; 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/*** Create the analogue input controls ***/
+
+static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_device_info *info = private-&gt;info;
+	int err, i;
+	char s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+
+	/* Add input level (line/inst) controls */
+	for (i = 0; i &lt; info-&gt;level_input_count; i++) {
+		snprintf(s, sizeof(s), &quot;Line In %d Level Capture Enum&quot;, i + 1);
+		err = scarlett2_add_new_ctl(mixer, &amp;scarlett2_level_enum_ctl,
+					    i, 1, s, NULL);
+		if (err &lt; 0)
+			return err;
+	}
+
+	/* Add input pad controls */
+	for (i = 0; i &lt; info-&gt;pad_input_count; i++) {
+		snprintf(s, sizeof(s), &quot;Line In %d Pad Capture Switch&quot;, i + 1);
+		err = scarlett2_add_new_ctl(mixer, &amp;scarlett2_pad_ctl,
+					    i, 1, s, NULL);
+		if (err &lt; 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/*** Mixer Volume Controls ***/
+
+static int scarlett2_mixer_ctl_info(struct snd_kcontrol *kctl,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+
+	uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo-&gt;count = elem-&gt;channels;
+	uinfo-&gt;value.integer.min = 0;
+	uinfo-&gt;value.integer.max = SCARLETT_MIXER_MAX_VALUE;
+	uinfo-&gt;value.integer.step = 1;
+	return 0;
+}
+
+static int scarlett2_mixer_ctl_get(struct snd_kcontrol *kctl,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct scarlett2_mixer_data *private = elem-&gt;head.mixer-&gt;private_data;
+
+	ucontrol-&gt;value.integer.value[0] = private-&gt;mix[elem-&gt;control];
+	return 0;
+}
+
+static int scarlett2_mixer_ctl_put(struct snd_kcontrol *kctl,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_device_info *info = private-&gt;info;
+	const struct scarlett2_ports *ports = info-&gt;ports;
+	int oval, val, num_mixer_in, mix_num, err = 0;
+
+	mutex_lock(&amp;private-&gt;data_mutex);
+
+	oval = private-&gt;mix[elem-&gt;control];
+	val = ucontrol-&gt;value.integer.value[0];
+	num_mixer_in = ports[SCARLETT2_PORT_TYPE_MIX].num[SCARLETT2_PORT_OUT];
+	mix_num = elem-&gt;control / num_mixer_in;
+
+	if (oval == val)
+		goto unlock;
+
+	private-&gt;mix[elem-&gt;control] = val;
+	err = scarlett2_usb_set_mix(mixer, mix_num);
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&amp;private-&gt;data_mutex);
+	return err;
+}
+
+static const DECLARE_TLV_DB_MINMAX(
+	db_scale_scarlett_mixer,
+	SCARLETT_MIXER_MIN_DB * 100,
+	SCARLETT_MIXER_MAX_DB * 100
+);
+
+static const struct snd_kcontrol_new scarlett2_mixer_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
+	.name = &quot;&quot;,
+	.info = scarlett2_mixer_ctl_info,
+	.get  = scarlett2_mixer_ctl_get,
+	.put  = scarlett2_mixer_ctl_put,
+	.private_value = SCARLETT_MIXER_MAX_DB, /* max value */
+	.tlv = { .p = db_scale_scarlett_mixer }
+};
+
+static int scarlett2_add_mixer_ctls(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_ports *ports = private-&gt;info-&gt;ports;
+	int err, i, j;
+	int index;
+	char s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+
+	int num_inputs = ports[SCARLETT2_PORT_TYPE_MIX].num[SCARLETT2_PORT_OUT];
+	int num_outputs = ports[SCARLETT2_PORT_TYPE_MIX].num[SCARLETT2_PORT_IN];
+
+	for (i = 0, index = 0; i &lt; num_outputs; i++) {
+		for (j = 0; j &lt; num_inputs; j++, index++) {
+			snprintf(s, sizeof(s),
+				 &quot;Mix %c Input %02d Playback Volume&quot;,
+				 'A' + i, j + 1);
+			err = scarlett2_add_new_ctl(mixer, &amp;scarlett2_mixer_ctl,
+						    index, 1, s, NULL);
+			if (err &lt; 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+/*** Mux Source Selection Controls ***/
+
+static int scarlett2_mux_src_enum_ctl_info(struct snd_kcontrol *kctl,
+					   struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct scarlett2_mixer_data *private = elem-&gt;head.mixer-&gt;private_data;
+	const struct scarlett2_ports *ports = private-&gt;info-&gt;ports;
+	unsigned int item = uinfo-&gt;value.enumerated.item;
+	int items = private-&gt;num_mux_srcs;
+	int port_type;
+
+	uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo-&gt;count = elem-&gt;channels;
+	uinfo-&gt;value.enumerated.items = items;
+
+	if (item &gt;= items)
+		item = uinfo-&gt;value.enumerated.item = items - 1;
+
+	for (port_type = 0;
+	     port_type &lt; SCARLETT2_PORT_TYPE_COUNT;
+	     port_type++) {
+		if (item &lt; ports[port_type].num[SCARLETT2_PORT_IN]) {
+			sprintf(uinfo-&gt;value.enumerated.name,
+				ports[port_type].src_descr,
+				item + ports[port_type].src_num_offset);
+			return 0;
+		}
+		item -= ports[port_type].num[SCARLETT2_PORT_IN];
+	}
+
+	return -EINVAL;
+}
+
+static int scarlett2_mux_src_enum_ctl_get(struct snd_kcontrol *kctl,
+					  struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct scarlett2_mixer_data *private = elem-&gt;head.mixer-&gt;private_data;
+
+	ucontrol-&gt;value.enumerated.item[0] = private-&gt;mux[elem-&gt;control];
+	return 0;
+}
+
+static int scarlett2_mux_src_enum_ctl_put(struct snd_kcontrol *kctl,
+					  struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	struct usb_mixer_interface *mixer = elem-&gt;head.mixer;
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	int index = elem-&gt;control;
+	int oval, val, err = 0;
+
+	mutex_lock(&amp;private-&gt;data_mutex);
+
+	oval = private-&gt;mux[index];
+	val = clamp(ucontrol-&gt;value.integer.value[0],
+		    0L, private-&gt;num_mux_srcs - 1L);
+
+	if (oval == val)
+		goto unlock;
+
+	private-&gt;mux[index] = val;
+	err = scarlett2_usb_set_mux(mixer);
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&amp;private-&gt;data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_mux_src_enum_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = &quot;&quot;,
+	.info = scarlett2_mux_src_enum_ctl_info,
+	.get  = scarlett2_mux_src_enum_ctl_get,
+	.put  = scarlett2_mux_src_enum_ctl_put,
+};
+
+static int scarlett2_add_mux_enums(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_ports *ports = private-&gt;info-&gt;ports;
+	int port_type, channel, i;
+
+	for (i = 0, port_type = 0;
+	     port_type &lt; SCARLETT2_PORT_TYPE_COUNT;
+	     port_type++) {
+		for (channel = 0;
+		     channel &lt; ports[port_type].num[SCARLETT2_PORT_OUT];
+		     channel++, i++) {
+			int err;
+			char s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+			const char *const descr = ports[port_type].dst_descr;
+
+			snprintf(s, sizeof(s) - 5, descr, channel + 1);
+			strcat(s, &quot; Enum&quot;);
+
+			err = scarlett2_add_new_ctl(mixer,
+						    &amp;scarlett2_mux_src_enum_ctl,
+						    i, 1, s, NULL);
+			if (err &lt; 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+/*** Meter Controls ***/
+
+static int scarlett2_meter_ctl_info(struct snd_kcontrol *kctl,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+
+	uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo-&gt;count = elem-&gt;channels;
+	uinfo-&gt;value.integer.min = 0;
+	uinfo-&gt;value.integer.max = 4095;
+	uinfo-&gt;value.integer.step = 1;
+	return 0;
+}
+
+static int scarlett2_meter_ctl_get(struct snd_kcontrol *kctl,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl-&gt;private_data;
+	u16 meter_levels[SCARLETT2_NUM_METERS];
+	int i, err;
+
+	err = scarlett2_usb_get_meter_levels(elem-&gt;head.mixer, meter_levels);
+	if (err &lt; 0)
+		return err;
+
+	for (i = 0; i &lt; elem-&gt;channels; i++)
+		ucontrol-&gt;value.integer.value[i] = meter_levels[i];
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new scarlett2_meter_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.name = &quot;&quot;,
+	.info = scarlett2_meter_ctl_info,
+	.get  = scarlett2_meter_ctl_get
+};
+
+static int scarlett2_add_meter_ctl(struct usb_mixer_interface *mixer)
+{
+	return scarlett2_add_new_ctl(mixer, &amp;scarlett2_meter_ctl,
+				     0, SCARLETT2_NUM_METERS,
+				     &quot;Level Meter&quot;, NULL);
+}
+
+/*** Initialisation ***/
+
+static int scarlett2_count_mux_srcs(const struct scarlett2_ports *ports)
+{
+	int port_type, count = 0;
+
+	for (port_type = 0;
+	     port_type &lt; SCARLETT2_PORT_TYPE_COUNT;
+	     port_type++)
+		count += ports[port_type].num[SCARLETT2_PORT_IN];
+
+	return count;
+}
+
+/* Default routing connects PCM outputs and inputs to Analogue,
+ * S/PDIF, then ADAT
+ */
+static void scarlett2_init_routing(u8 *mux,
+				   const struct scarlett2_ports *ports)
+{
+	int i, input_num, input_count, port_type;
+	int output_num, output_count, port_type_connect_num;
+
+	static const int connect_order[] = {
+		SCARLETT2_PORT_TYPE_ANALOGUE,
+		SCARLETT2_PORT_TYPE_SPDIF,
+		SCARLETT2_PORT_TYPE_ADAT,
+		-1
+	};
+
+	/* Assign PCM inputs (routing outputs) */
+	output_num = scarlett2_get_port_start_num(ports,
+						  SCARLETT2_PORT_OUT,
+						  SCARLETT2_PORT_TYPE_PCM);
+	output_count = ports[SCARLETT2_PORT_TYPE_PCM].num[SCARLETT2_PORT_OUT];
+
+	for (port_type = connect_order[port_type_connect_num = 0];
+	     port_type &gt;= 0;
+	     port_type = connect_order[++port_type_connect_num]) {
+		input_num = scarlett2_get_port_start_num(
+			ports, SCARLETT2_PORT_IN, port_type);
+		input_count = ports[port_type].num[SCARLETT2_PORT_IN];
+		for (i = 0;
+		     i &lt; input_count &amp;&amp; output_count;
+		     i++, output_count--)
+			mux[output_num++] = input_num++;
+	}
+
+	/* Assign PCM outputs (routing inputs) */
+	input_num = scarlett2_get_port_start_num(ports,
+						 SCARLETT2_PORT_IN,
+						 SCARLETT2_PORT_TYPE_PCM);
+	input_count = ports[SCARLETT2_PORT_TYPE_PCM].num[SCARLETT2_PORT_IN];
+
+	for (port_type = connect_order[port_type_connect_num = 0];
+	     port_type &gt;= 0;
+	     port_type = connect_order[++port_type_connect_num]) {
+		output_num = scarlett2_get_port_start_num(
+			ports, SCARLETT2_PORT_OUT, port_type);
+		output_count = ports[port_type].num[SCARLETT2_PORT_OUT];
+		for (i = 0;
+		     i &lt; output_count &amp;&amp; input_count;
+		     i++, input_count--)
+			mux[output_num++] = input_num++;
+	}
+}
+
+/* Initialise private data, routing, sequence number */
+static int scarlett2_init_private(struct usb_mixer_interface *mixer,
+				  const struct scarlett2_device_info *info)
+{
+	struct scarlett2_mixer_data *private =
+		kzalloc(sizeof(struct scarlett2_mixer_data), GFP_KERNEL);
+
+	if (!private)
+		return -ENOMEM;
+
+	mutex_init(&amp;private-&gt;usb_mutex);
+	mutex_init(&amp;private-&gt;data_mutex);
+	INIT_DELAYED_WORK(&amp;private-&gt;work, scarlett2_config_save);
+	private-&gt;info = info;
+	private-&gt;num_mux_srcs = scarlett2_count_mux_srcs(info-&gt;ports);
+	private-&gt;scarlett2_seq = 0;
+	private-&gt;mixer = mixer;
+	mixer-&gt;private_data = private;
+	mixer-&gt;private_free = snd_scarlett_gen2_private_free;
+
+	/* Setup default routing */
+	scarlett2_init_routing(private-&gt;mux, info-&gt;ports);
+
+	/* Initialise the sequence number used for the proprietary commands */
+	return scarlett2_usb(mixer, SCARLETT2_USB_INIT_SEQ,
+			     NULL, 0, NULL, 0);
+}
+
+/* Read line-in config and line-out volume settings on start */
+static int scarlett2_read_configs(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_device_info *info = private-&gt;info;
+	const struct scarlett2_ports *ports = info-&gt;ports;
+	int num_line_out =
+		ports[SCARLETT2_PORT_TYPE_ANALOGUE].num[SCARLETT2_PORT_OUT];
+	u8 level_switches[SCARLETT2_LEVEL_SWITCH_MAX];
+	u8 pad_switches[SCARLETT2_PAD_SWITCH_MAX];
+	struct scarlett2_usb_volume_status volume_status;
+	int err, i;
+
+	if (info-&gt;level_input_count) {
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_LEVEL_SWITCH,
+			info-&gt;level_input_count,
+			level_switches);
+		if (err &lt; 0)
+			return err;
+		for (i = 0; i &lt; info-&gt;level_input_count; i++)
+			private-&gt;level_switch[i] = level_switches[i];
+	}
+
+	if (info-&gt;pad_input_count) {
+		err = scarlett2_usb_get_config(
+			mixer,
+			SCARLETT2_CONFIG_PAD_SWITCH,
+			info-&gt;pad_input_count,
+			pad_switches);
+		if (err &lt; 0)
+			return err;
+		for (i = 0; i &lt; info-&gt;pad_input_count; i++)
+			private-&gt;pad_switch[i] = pad_switches[i];
+	}
+
+	err = scarlett2_usb_get_volume_status(mixer, &amp;volume_status);
+	if (err &lt; 0)
+		return err;
+
+	private-&gt;master_vol = clamp(
+		volume_status.master_vol + SCARLETT_VOLUME_BIAS,
+		0, SCARLETT_VOLUME_BIAS);
+
+	for (i = 0; i &lt; num_line_out; i++) {
+		int volume;
+
+		private-&gt;vol_sw_hw_switch[i] =
+			info-&gt;line_out_hw_vol
+				&amp;&amp; volume_status.sw_hw_switch[i];
+
+		volume = private-&gt;vol_sw_hw_switch[i]
+			   ? volume_status.master_vol
+			   : volume_status.sw_vol[i];
+		volume = clamp(volume + SCARLETT_VOLUME_BIAS,
+			       0, SCARLETT_VOLUME_BIAS);
+		private-&gt;vol[i] = volume;
+	}
+
+	for (i = 0; i &lt; info-&gt;button_count; i++)
+		private-&gt;buttons[i] = !!volume_status.buttons[i];
+
+	return 0;
+}
+
+/* Notify on volume change */
+static void scarlett2_mixer_interrupt_vol_change(
+	struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	const struct scarlett2_ports *ports = private-&gt;info-&gt;ports;
+	int num_line_out =
+		ports[SCARLETT2_PORT_TYPE_ANALOGUE].num[SCARLETT2_PORT_OUT];
+	int i;
+
+	private-&gt;vol_updated = 1;
+
+	snd_ctl_notify(mixer-&gt;chip-&gt;card, SNDRV_CTL_EVENT_MASK_VALUE,
+		       &amp;private-&gt;master_vol_ctl-&gt;id);
+
+	for (i = 0; i &lt; num_line_out; i++) {
+		if (!private-&gt;vol_sw_hw_switch[i])
+			continue;
+		snd_ctl_notify(mixer-&gt;chip-&gt;card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &amp;private-&gt;vol_ctls[i]-&gt;id);
+	}
+}
+
+/* Notify on button change */
+static void scarlett2_mixer_interrupt_button_change(
+	struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+	int i;
+
+	private-&gt;vol_updated = 1;
+
+	for (i = 0; i &lt; private-&gt;info-&gt;button_count; i++)
+		snd_ctl_notify(mixer-&gt;chip-&gt;card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &amp;private-&gt;button_ctls[i]-&gt;id);
+}
+
+/* Interrupt callback */
+static void scarlett2_mixer_interrupt(struct urb *urb)
+{
+	struct usb_mixer_interface *mixer = urb-&gt;context;
+	int len = urb-&gt;actual_length;
+	int ustatus = urb-&gt;status;
+	u32 data;
+
+	if (ustatus != 0)
+		goto requeue;
+
+	if (len == 8) {
+		data = le32_to_cpu(*(u32 *)urb-&gt;transfer_buffer);
+		if (data &amp; SCARLETT2_USB_INTERRUPT_VOL_CHANGE)
+			scarlett2_mixer_interrupt_vol_change(mixer);
+		if (data &amp; SCARLETT2_USB_INTERRUPT_BUTTON_CHANGE)
+			scarlett2_mixer_interrupt_button_change(mixer);
+	} else {
+		usb_audio_err(mixer-&gt;chip,
+			      &quot;scarlett mixer interrupt length %d\n&quot;, len);
+	}
+
+requeue:
+	if (ustatus != -ENOENT &amp;&amp;
+	    ustatus != -ECONNRESET &amp;&amp;
+	    ustatus != -ESHUTDOWN) {
+		urb-&gt;dev = mixer-&gt;chip-&gt;dev;
+		usb_submit_urb(urb, GFP_ATOMIC);
+	}
+}
+
+static int scarlett2_mixer_status_create(struct usb_mixer_interface *mixer)
+{
+	void *transfer_buffer;
+
+	if (mixer-&gt;urb) {
+		usb_audio_err(mixer-&gt;chip,
+			      &quot;%s: mixer urb already in use!\n&quot;, __func__);
+		return 0;
+	}
+
+	mixer-&gt;urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!mixer-&gt;urb)
+		return -ENOMEM;
+
+	transfer_buffer = kmalloc(SCARLETT2_USB_INTERRUPT_MAX_DATA, GFP_KERNEL);
+	if (!transfer_buffer)
+		return -ENOMEM;
+
+	usb_fill_int_urb(
+		mixer-&gt;urb,
+		mixer-&gt;chip-&gt;dev,
+		usb_rcvintpipe(mixer-&gt;chip-&gt;dev,
+			       SCARLETT2_USB_INTERRUPT_ENDPOINT),
+		transfer_buffer,
+		SCARLETT2_USB_INTERRUPT_MAX_DATA,
+		scarlett2_mixer_interrupt,
+		mixer,
+		SCARLETT2_USB_INTERRUPT_INTERVAL);
+
+	return usb_submit_urb(mixer-&gt;urb, GFP_KERNEL);
+}
+
+/* Entry point */
+int snd_scarlett_gen2_controls_create(struct usb_mixer_interface *mixer)
+{
+	const struct scarlett2_device_info *info;
+	int err;
+
+	/* only use UAC_VERSION_2 */
+	if (!mixer-&gt;protocol)
+		return 0;
+
+	switch (mixer-&gt;chip-&gt;usb_id) {
+	case USB_ID(0x1235, 0x8203):
+		info = &amp;s6i6_gen2_info;
+		break;
+	case USB_ID(0x1235, 0x8204):
+		info = &amp;s18i8_gen2_info;
+		break;
+	case USB_ID(0x1235, 0x8201):
+		info = &amp;s18i20_gen2_info;
+		break;
+	default: /* device not (yet) supported */
+		return -EINVAL;
+	}
+
+	if (!scarlett_gen2_mixer_enable) {
+		usb_audio_err(mixer-&gt;chip,
+			&quot;Focusrite Scarlett Gen 2 Mixer Driver disabled; use &quot;
+			&quot;options snd_usb_audio scarlett_gen2_mixer_enable=1 &quot;
+			&quot;to enable and report any issues to g@xxxxx&quot;);
+		return 0;
+	}
+
+	/* Initialise private data, routing, sequence number */
+	err = scarlett2_init_private(mixer, info);
+	if (err &lt; 0)
+		return err;
+
+	/* Read volume levels and controls from the interface */
+	err = scarlett2_read_configs(mixer);
+	if (err &lt; 0)
+		return err;
+
+	/* Create the analogue output controls */
+	err = scarlett2_add_line_out_ctls(mixer);
+	if (err &lt; 0)
+		return err;
+
+	/* Create the analogue input controls */
+	err = scarlett2_add_line_in_ctls(mixer);
+	if (err &lt; 0)
+		return err;
+
+	/* Create the input, output, and mixer mux input selections */
+	err = scarlett2_add_mux_enums(mixer);
+	if (err &lt; 0)
+		return err;
+
+	/* Create the matrix mixer controls */
+	err = scarlett2_add_mixer_ctls(mixer);
+	if (err &lt; 0)
+		return err;
+
+	/* Create the level meter controls */
+	err = scarlett2_add_meter_ctl(mixer);
+	if (err &lt; 0)
+		return err;
+
+	/* Set up the interrupt polling if there are hardware buttons */
+	if (info-&gt;button_count) {
+		err = scarlett2_mixer_status_create(mixer);
+		if (err &lt; 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static void snd_scarlett_gen2_private_free(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_mixer_data *private = mixer-&gt;private_data;
+
+	cancel_delayed_work_sync(&amp;private-&gt;work);
+	kfree(private);
+	mixer-&gt;private_data = NULL;
+}
diff --git a/sound/usb/mixer_scarlett_gen2.h b/sound/usb/mixer_scarlett_gen2.h
new file mode 100644
index 000000000000..52e1dad77afd
--- /dev/null
+++ b/sound/usb/mixer_scarlett_gen2.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __USB_MIXER_SCARLETT_GEN2_H
+#define __USB_MIXER_SCARLETT_GEN2_H
+
+int snd_scarlett_gen2_controls_create(struct usb_mixer_interface *mixer);
+
+#endif /* __USB_MIXER_SCARLETT_GEN2_H */
_______________________________________________
Alsa-devel mailing list
Alsa-devel@xxxxxxxxxxxxxxxx
<a  rel="nofollow" href="https://mailman.alsa-project.org/mailman/listinfo/alsa-devel">https://mailman.alsa-project.org/mailman/listinfo/alsa-devel</a>




</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg93382.html">Re:  focusrite scarlett 18i20 : Mixer controls with	corrupted names for</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg93384.html">Re:  [Xen-devel] [PATCH] ALSA: xen-front: fix unintention integer overflow on left shifts</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg93380.html">[PATCH -next] ASoC: madera: Remove duplicated include	from cs47l35.c</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg93388.html">[PATCH] ALSA: hda: Fix a headphone detection issue	when using SOF</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#93383"><strong>Date</strong></a></li>
<li><a href="threads.html#93383"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/alsa-user/>[ALSA&nbsp;User]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-audio-users/>[Linux&nbsp;Audio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=/lists/pulse-audio/>[Pulse&nbsp;Audio]</a>
&nbsp;
&nbsp;
<a href=/lists/kernel/>[Kernel&nbsp;Archive]</a>
&nbsp;
&nbsp;
<a href=/lists/asterisk/>[Asterisk&nbsp;PBX]</a>
&nbsp;
&nbsp;
<a href=http://yosemitephotos.net/>[Photo&nbsp;Sharing]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/linux-sound/>[Linux&nbsp;Sound]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-media/>[Video&nbsp;4&nbsp;Linux]</a>
&nbsp;
&nbsp;
<a href=/lists/gimp/>[Gimp]</a>
&nbsp;
&nbsp;
<a href=https://yosemitenews.info>[Yosemite&nbsp;News]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
