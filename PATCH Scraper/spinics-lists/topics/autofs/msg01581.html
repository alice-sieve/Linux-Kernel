<!-- MHonArc v2.6.19 -->
<!--X-Subject: [PATCH 12/34] autofs&#45;5.1.2 &#45; add support for amd browsable option -->
<!--X-From-R13: Wna Yrag &#60;eniraNgurznj.arg> -->
<!--X-Date: Sun, 23 Apr 2017 18:11:21 &#45;0700 -->
<!--X-Message-Id: 149299567495.23475.4753139944325347128.stgit@pluto.themaw.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 149299547753.23475.9924538846721477415.stgit@pluto.themaw.net -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-3422782820843221",
          enable_page_level_ads: true
     });
</script>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="[PATCH 12/34] autofs-5.1.2 - add support for amd browsable option &mdash; Linux AutoFS">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>[PATCH 12/34] autofs-5.1.2 - add support for amd browsable option &mdash; Linux AutoFS</title>
<link rel="alternate" type="application/rss+xml" title="Linux AutoFS" href="//feeds.feedburner.com/autofs">
<script type="text/javascript">
var addthis_config = addthis_config||{};
addthis_config.data_track_addressbar = false;
</script>
</head>
<body itemscope itemtype="//schema.org/Article" vlink=green>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action="//www.google.com/cse" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-3422782820843221:isdiegq275o" />
    <input type="hidden" name="ie" value="ISO-8859-1" />
    <input type="text" name="q" size="37" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<h1 itemprop="name">[PATCH 12/34] autofs-5.1.2 - add support for amd browsable option</h1>
[<a href="msg01580.html">Date Prev</a>][<a href="msg01582.html">Date Next</a>][<a href="msg01580.html">Thread Prev</a>][<a href="msg01582.html">Thread Next</a>][<a href="maillist.html#01581">Date Index</a>][<a href="index.html#01581">Thread Index</a>]


<p>&nbsp;<br>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive test for archives -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="6345952567"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: autofs mailing list &lt;autofs@xxxxxxxxxxxxxxx&gt;</li>
<li><em>Subject</em>: [PATCH 12/34] autofs-5.1.2 - add support for amd browsable option</li>
<li><em>From</em>: Ian Kent &lt;raven@xxxxxxxxxx&gt;</li>
<li><em>Date</em>: Mon, 24 Apr 2017 09:01:15 +0800</li>
<li><em>In-reply-to</em>: &lt;<a href="msg01553.html">149299547753.23475.9924538846721477415.stgit@pluto.themaw.net</a>&gt;</li>
<li><em>References</em>: &lt;<a href="msg01553.html">149299547753.23475.9924538846721477415.stgit@pluto.themaw.net</a>&gt;</li>
<li><em>User-agent</em>: StGit/0.17.1-dirty</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style ">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5196c2ae1be43d18&async=1&domready=1" async></script>
<!-- AddThis Button END -->
<hr>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- responsive link 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="8681825769"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>
<div class="content" itemprop="articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>From: Ian Kent &lt;ikent@xxxxxxxxxx&gt;

Add support for the &quot;browsable_dirs&quot; configuration option and the
pseudo mount option &quot;browsable&quot; of amd format maps.

Note that support for the configuration option &quot;browsable_dirs = full&quot;
and the pseudo mount option &quot;fullybrowsable&quot; of type auto map entries
cannot be implemented using  the existing kernel to user space autofs
implementation.

Signed-off-by: Ian Kent &lt;raven@xxxxxxxxxx&gt;
---
 CHANGELOG                      |    1 
 README.amd-maps                |    2 -
 daemon/lookup.c                |  106 ++++++++++++++++++++++++++++++++--------
 lib/master_parse.y             |   14 ++++-
 man/autofs.conf.5.in           |    7 ++-
 modules/amd_parse.y            |    3 -
 modules/mount_autofs.c         |    8 ++-
 modules/parse_amd.c            |    2 -
 redhat/autofs.conf.default.in  |    7 ++-
 samples/autofs.conf.default.in |    7 ++-
 10 files changed, 120 insertions(+), 37 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index fb6243b..b67fd56 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -38,6 +38,7 @@ xx/xx/2016 autofs-5.1.3
 - honor last rw in mount options when doing a bind mount.
 - fix typos in README.amd-maps.
 - add ref counting to struct map_source.
+- add support for amd browsable option.
 
 15/06/2016 autofs-5.1.2
 =======================
diff --git a/README.amd-maps b/README.amd-maps
index e79f521..4f1d58d 100644
--- a/README.amd-maps
+++ b/README.amd-maps
@@ -101,7 +101,7 @@ What hasn't been implemented
 ----------------------------
 
 The configuration options fully_qualified_hosts, unmount_on_exit and
-browsable_dirs (and a couple of others) aren't implemented.
+browsable_dirs = full (and a couple of others) aren't implemented.
 
 Map types (sources) ndbm, passwd are not implemented.
 The map source &quot;sss&quot; can't be used for amd format maps.
diff --git a/daemon/lookup.c b/daemon/lookup.c
index 5ff837d..583d3d3 100644
--- a/daemon/lookup.c
+++ b/daemon/lookup.c
@@ -663,6 +663,56 @@ int lookup_nss_read_map(struct autofs_point *ap, struct map_source *source, time
 	return 0;
 }
 
+static char *make_browse_path(unsigned int logopt,
+			      const char *root, const char *key,
+			      const char *prefix)
+{
+	unsigned int l_prefix;
+	unsigned int k_len, r_len;
+	char *k_start;
+	char *path;
+
+	k_start = (char *) key;
+	k_len = strlen(key);
+	l_prefix = 0;
+
+	if (prefix) {
+		l_prefix = strlen(prefix);
+
+		if (l_prefix &gt; k_len)
+			return NULL;
+
+		/* If the prefix doesn't match the beginning
+		 * of the key this entry isn't a sub directory
+		 * at this level.
+		 */
+		if (strncmp(key, prefix, l_prefix))
+			return NULL;
+
+		/* Directory entry starts following the prefix */
+		k_start += l_prefix;
+	}
+
+	/* No remaining &quot;/&quot; allowed here */
+	if (strchr(k_start, '/'))
+		return NULL;
+
+	r_len = strlen(root);
+
+	if ((r_len + strlen(k_start)) &gt; KEY_MAX_LEN)
+		return NULL;
+
+	path = malloc(r_len + k_len + 2);
+	if (!path) {
+		warn(logopt, &quot;failed to allocate full path&quot;);
+		return NULL;
+	}
+
+	sprintf(path, &quot;%s/%s&quot;, root, k_start);
+
+	return path;
+}
+
 int lookup_ghost(struct autofs_point *ap, const char *root)
 {
 	struct master_mapent *entry = ap-&gt;entry;
@@ -706,10 +756,19 @@ int lookup_ghost(struct autofs_point *ap, const char *root)
 			if (!me-&gt;mapent)
 				goto next;
 
-			if (!strcmp(me-&gt;key, &quot;*&quot;))
+			/* Wildcard cannot be a browse directory and amd map
+			 * keys may end with the wildcard.
+			 */
+			if (strchr(me-&gt;key, '*'))
 				goto next;
 
+			/* This will also take care of amd &quot;/defaults&quot; entry as
+			 * amd map keys are not allowd to start with &quot;/&quot;
+			 */
 			if (*me-&gt;key == '/') {
+				if (map-&gt;flags &amp; MAP_FLAG_FORMAT_AMD)
+					goto next;
+
 				/* It's a busy multi-mount - leave till next time */
 				if (list_empty(&amp;me-&gt;multi_list))
 					error(ap-&gt;logopt,
@@ -717,12 +776,10 @@ int lookup_ghost(struct autofs_point *ap, const char *root)
 				goto next;
 			}
 
-			fullpath = malloc(strlen(me-&gt;key) + strlen(root) + 3);
-			if (!fullpath) {
-				warn(ap-&gt;logopt, &quot;failed to allocate full path&quot;);
+			fullpath = make_browse_path(ap-&gt;logopt,
+						    root, me-&gt;key, ap-&gt;pref);
+			if (!fullpath)
 				goto next;
-			}
-			sprintf(fullpath, &quot;%s/%s&quot;, root, me-&gt;key);
 
 			ret = stat(fullpath, &amp;st);
 			if (ret == -1 &amp;&amp; errno != ENOENT) {
@@ -732,6 +789,17 @@ int lookup_ghost(struct autofs_point *ap, const char *root)
 				goto next;
 			}
 
+			/* Directory already exists? */
+			if (!ret) {
+				/* Shouldn't need this
+				me-&gt;dev = st.st_dev;
+				me-&gt;ino = st.st_ino;
+				*/
+				debug(ap-&gt;logopt, &quot;me-&gt;dev %d me-&gt;ino %d&quot;, me-&gt;dev, me-&gt;ino);
+				free(fullpath);
+				goto next;
+			}
+
 			ret = mkdir_path(fullpath, 0555);
 			if (ret &lt; 0 &amp;&amp; errno != EEXIST) {
 				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
@@ -1241,28 +1309,23 @@ void lookup_close_lookup(struct autofs_point *ap)
 	return;
 }
 
-static char *make_fullpath(const char *root, const char *key)
+static char *make_fullpath(struct autofs_point *ap, const char *key)
 {
+	char *path = NULL;
 	int l;
-	char *path;
 
-	if (*key == '/') {
+	if (*key != '/')
+		path = make_browse_path(ap-&gt;logopt, ap-&gt;path, key, ap-&gt;pref);
+	else {
 		l = strlen(key) + 1;
 		if (l &gt; KEY_MAX_LEN)
-			return NULL;
+			goto out;
 		path = malloc(l);
 		if (!path)
-			return NULL;
+			goto out;
 		strcpy(path, key);
-	} else {
-		l = strlen(key) + 1 + strlen(root) + 1;
-		if (l &gt; KEY_MAX_LEN)
-			return NULL;
-		path = malloc(l);
-		if (!path)
-			return NULL;
-		sprintf(path, &quot;%s/%s&quot;, root, key);
 	}
+out:
 	return path;
 }
 
@@ -1293,13 +1356,14 @@ void lookup_prune_one_cache(struct autofs_point *ap, struct mapent_cache *mc, ti
 
 		key = strdup(me-&gt;key);
 		me = cache_enumerate(mc, me);
-		if (!key || !strcmp(key, &quot;*&quot;)) {
+		/* Don't consider any entries with a wildcard */
+		if (!key || strchr(key, '*')) {
 			if (key)
 				free(key);
 			continue;
 		}
 
-		path = make_fullpath(ap-&gt;path, key);
+		path = make_fullpath(ap, key);
 		if (!path) {
 			warn(ap-&gt;logopt, &quot;can't malloc storage for path&quot;);
 			free(key);
diff --git a/lib/master_parse.y b/lib/master_parse.y
index 0011429..7536324 100644
--- a/lib/master_parse.y
+++ b/lib/master_parse.y
@@ -811,14 +811,22 @@ int master_parse_entry(const char *buffer, unsigned int default_timeout, unsigne
 
 	if (format &amp;&amp; !strcmp(format, &quot;amd&quot;)) {
 		unsigned int loglevel = conf_amd_get_log_options();
+		unsigned int flags = conf_amd_get_flags(path);
+
 		if (loglevel &lt;= LOG_DEBUG &amp;&amp; loglevel &gt; LOG_INFO)
 			logopt = LOGOPT_DEBUG;
 		else if (loglevel &lt;= LOG_INFO &amp;&amp; loglevel &gt; LOG_ERR)
 			logopt = LOGOPT_VERBOSE;
-		/* amd mounts don't support browse mode */
-		ghost = 0;
-	}
 
+		/* It isn't possible to provide the fullybrowsable amd
+		 * browsing functionality within the autofs framework.
+		 * This flag will not be set if browsable_dirs = full
+		 * in the configuration or fullybrowsable is present as
+		 * an option.
+		 */
+		if (flags &amp; CONF_BROWSABLE_DIRS)
+			ghost = 1;
+	}
 
 	if (timeout &lt; 0) {
 		/*
diff --git a/man/autofs.conf.5.in b/man/autofs.conf.5.in
index a9a08f9..a9ed1c3 100644
--- a/man/autofs.conf.5.in
+++ b/man/autofs.conf.5.in
@@ -355,7 +355,12 @@ and that will be done.
 .TP
 .B browsable_dirs
 .br
-Not yet implemented.
+Allow map keys to be shown in directory listings. This option
+can have values of &quot;yes&quot; or &quot;no&quot;. The default is &quot;no&quot;. A variation
+of this option, &quot;browsable&quot;, can be used as a pseudo mount option
+in type &quot;auto&quot; map entries to provide provide browsing funtionality
+in sub-mounts. The amd &quot;browsable_dirs = full&quot; option cannot be
+implemented within the current autofs framework and is not supported.
 .TP
 .B exec_map_timeout
 .br
diff --git a/modules/amd_parse.y b/modules/amd_parse.y
index bfa1d51..b33250a 100644
--- a/modules/amd_parse.y
+++ b/modules/amd_parse.y
@@ -433,8 +433,7 @@ option_assignment: MAP_OPTION OPTION_ASSIGN FS_TYPE
 
 options: OPTION
 	{
-		if (!strcmp($1, &quot;browsable&quot;) ||
-		    !strcmp($1, &quot;fullybrowsable&quot;) ||
+		if (!strcmp($1, &quot;fullybrowsable&quot;) ||
 		    !strcmp($1, &quot;nounmount&quot;) ||
 		    !strcmp($1, &quot;unmount&quot;)) {
 			sprintf(msg_buf, &quot;option %s is not currently &quot;
diff --git a/modules/mount_autofs.c b/modules/mount_autofs.c
index 3ba5271..e404c83 100644
--- a/modules/mount_autofs.c
+++ b/modules/mount_autofs.c
@@ -121,11 +121,13 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name,
 			while (*comma != '\0' &amp;&amp; *comma != ',')
 				comma++;
 
-			if (_strncmp(&quot;nobrowse&quot;, cp, 8) == 0)
+			if (_strncmp(&quot;nobrowse&quot;, cp, 8) == 0 ||
+			    _strncmp(&quot;nobrowsable&quot;, cp, 11) == 0)
 				ghost = 0;
 			else if (_strncmp(&quot;nobind&quot;, cp, 6) == 0)
 				nobind = 1;
-			else if (_strncmp(&quot;browse&quot;, cp, 6) == 0)
+			else if (_strncmp(&quot;browse&quot;, cp, 6) == 0 ||
+				 _strncmp(&quot;browsable&quot;, cp, 9) == 0)
 				ghost = 1;
 			else if (_strncmp(&quot;symlink&quot;, cp, 7) == 0)
 				symlnk = 1;
@@ -287,8 +289,6 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name,
 			nap-&gt;pref = am_entry-&gt;pref;
 			am_entry-&gt;pref = NULL;
 		}
-		/* amd mounts don't support browse mode */
-		nap-&gt;flags &amp;= ~MOUNT_FLAG_GHOST;
 	}
 
 	if (handle_mounts_startup_cond_init(&amp;suc)) {
diff --git a/modules/parse_amd.c b/modules/parse_amd.c
index 38d76b8..2ff43fa 100644
--- a/modules/parse_amd.c
+++ b/modules/parse_amd.c
@@ -930,7 +930,7 @@ static int do_auto_mount(struct autofs_point *ap, const char *name,
 	}
 
 	return do_mount(ap, ap-&gt;path,
-			name, strlen(name), target, &quot;autofs&quot;, NULL);
+			name, strlen(name), target, &quot;autofs&quot;, entry-&gt;opts);
 }
 
 static int do_link_mount(struct autofs_point *ap, const char *name,
diff --git a/redhat/autofs.conf.default.in b/redhat/autofs.conf.default.in
index c7e4d97..4a4b582 100644
--- a/redhat/autofs.conf.default.in
+++ b/redhat/autofs.conf.default.in
@@ -274,8 +274,6 @@ mount_nfs_default_protocol = 4
 #	is a sensible option to implement and that will be
 #	done.
 #
-# browsable_dirs - not yet implemented.
-#
 # exec_map_timeout - a timeout is not currently used for
 #	for program maps, might be implemented.
 #
@@ -318,6 +316,11 @@ mount_nfs_default_protocol = 4
 #	takes its default value from the autofs internal default
 #	of 600 seconds.
 #
+# browsable_dirs - make map keys visible in directory listings.
+#	Note that support for the &quot;fullybrowsable&quot; option cannot
+#	be added using the existing kernel to user space autofs
+#	implementation.
+#
 # autofs_use_lofs - if set to &quot;yes&quot; autofs will attempt to use bind
 #	mounts for type &quot;auto&quot; when possible.
 #
diff --git a/samples/autofs.conf.default.in b/samples/autofs.conf.default.in
index d52ad85..4af05aa 100644
--- a/samples/autofs.conf.default.in
+++ b/samples/autofs.conf.default.in
@@ -273,8 +273,6 @@ browse_mode = no
 #	is a sensible option to implement and that will be
 #	done.
 #
-# browsable_dirs - not yet implemented.
-#
 # exec_map_timeout - a timeout is not currently used for
 #	for program maps, might be implemented.
 #
@@ -317,6 +315,11 @@ browse_mode = no
 #	takes its default value from the autofs internal default
 #	of 600 seconds.
 #
+# browsable_dirs - make map keys visible in directory listings.
+#	Note that support for the &quot;fullybrowsable&quot; option cannot
+#	be added using the existing kernel to user space autofs
+#	implementation.
+#
 # autofs_use_lofs - if set to &quot;yes&quot; autofs will attempt to use bind
 #	mounts for type &quot;auto&quot; when possible.
 #

--
To unsubscribe from this list: send the line &quot;unsubscribe autofs&quot; in


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="01553" href="msg01553.html">[PATCH 00/34] fyi ... current patch list</a></strong>
<ul><li><em>From:</em> Ian Kent</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg01580.html">[PATCH 32/34] autofs-5.1.2 - use malloc for expanded map location</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg01582.html">[PATCH 10/34] autofs-5.1.2 - fix typos in README.amd-maps</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg01580.html">[PATCH 32/34] autofs-5.1.2 - use malloc for expanded map location</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg01582.html">[PATCH 10/34] autofs-5.1.2 - fix typos in README.amd-maps</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#01581"><strong>Date</strong></a></li>
<li><a href="index.html#01581"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=-1>
<a href=/lists/>[Index&nbsp;of&nbsp;Archives]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-fsdevel/>[Linux&nbsp;Filesystem&nbsp;Development]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-ext4/>[Linux&nbsp;Ext4]</a>
&nbsp;
&nbsp;
<a href=/lists/arm-kernel/>[Linux&nbsp;ARM&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=/lists/arm/>[Linux&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;Omap]</a>
&nbsp;
&nbsp;
<a href=/linux/fedora/fedora-arm/>[Fedora&nbsp;ARM]</a>
&nbsp;
&nbsp;
<a href=/lists/ietf-ann/>[IETF&nbsp;Annouce]</a>
&nbsp;
&nbsp;
<a href=/lists/security/>[Security]</a>
&nbsp;
&nbsp;
<a href=/lists/bugtraq/>[Bugtraq]</a>
&nbsp;
&nbsp;
<a href=/linux/>[Linux]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-omap/>[Linux&nbsp;OMAP]</a>
&nbsp;
&nbsp;
<a href=/lists/mips/>[Linux&nbsp;MIPS]</a>
&nbsp;
&nbsp;
<a href=/lists/ecos/>[ECOS]</a>
&nbsp;
&nbsp;
<a href=/lists/asterisk/>[Asterisk&nbsp;Internet&nbsp;PBX]</a>
&nbsp;
&nbsp;
<a href=/lists/linux-api/>[Linux&nbsp;API]</a>
</font>
</center>
<hr>
<p>
<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-3422782820843221"
     data-ad-slot="1424524564"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<table width=100%>
<tr>
<td align=left>&nbsp;</td>
<td align=right><a href=/lists/><img src=/button_01.gif border=0 alt="Powered by Linux"></a></td>
</tr>
</table>
<!--X-User-Footer-End-->
<script type="text/javascript"> 
 function initAddThis() {
    addthis.init()
 }
initAddThis();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-760190-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
